[21.3 <--- ](21_3.md) [   Зміст   ](README.md) [--> 21.5](21_5.md)

**21.1**     **MODEL-TO-MODEL** **INTEGRATION** **AND** **TRANSLATION:** **FROM** **SIMULINK****®** **TO** **AUTOSAR** **AND FROM AUTOSAR TO SIMULINK****®**

Because of the AUTOSAR limitations, including the difficulty in the definition and integration of plant models, it is quite unlikely that an AUTOSAR model is used for the early stages of control validation. Therefore, it is important to allow designers to develop controls first in a suitable environment, such as, for example Simulink. Later, the information can be translated into an AUTOSAR model that can provide the additional definition of the execution architecture and the software architecture, including the task model, with the delays and overheads that are characteristic of the execution platform, such as scheduling latencies and communication delays.

In this second step, however, there are several difficulties involved. Simulink is based on a synchronous/reactive MoC, even if without a formal definition of the model semantics. In a Simulink model in which the continuous part of the model is solved with a fixed-step solver (which is a practical requirement when the final target is generating a computer-executable implementation), all the system blocks are modeled to be executed according to a system-wide synchronous discrete-time framework. Activation events occur instantanously and synchronously across the system. Computations and communications are performed in zero logical time.

In contrast, AUTOSAR is not based on a formal MoC. Completeness of behavior modeling is not mandatory since runnables are only required to be entry points to a sequential program. RTE events are local, and their scope (including periodic events) is at the component level. Therefore, the system-level behavior is defined as emerging from the cooperation of components. Several issues arise because of this choice.

 

•   Communication semantics is partly specified using port attributes at the VFB-functional level and partly specified using the RTE events that define the activation of runnables following communication-related events at the RTE level. This would require semantics rules and tool support for guaranteeing the consistency of the two definitions. Similarly, timed events add yet another superstructure of specifications, which must be kept in agreement with the others.

•   Activation and synchronization semantics among runnables is specified using RTE events that are local to each ECU. This makes the realization of a system-level semantics difficult. Consider, for example, the



​        ![Підпис:  11  12   13 ](file:///C:/Users/OLEKSA~1/AppData/Local/Temp/msohtmlclip1/01/clip_image001.png)     ![Підпис:  21](file:///C:/Users/OLEKSA~1/AppData/Local/Temp/msohtmlclip1/01/clip_image002.png)     ![Підпис:  22](file:///C:/Users/OLEKSA~1/AppData/Local/Temp/msohtmlclip1/01/clip_image003.png)Specification and Simulation of Automotive Functionality               **541**

 

synchronous model of Figure 21.10 (in the middle) in which a block b13, activated at 20 ms and part of a subsystem communicates with two other blocks on a different subsystem: b21, activated at 10 ms (oversampling the output stream of b13), and b22, activated at 20 ms and communicating with a unit delay. According to the synchronous semantics, the activation and communication pattern for the example is represented at the bottom of the figure. The corresponding AUTOSAR system is depicted at the

top of Figure 21.10. A component corresponds to each subsystem and a runnable to each block with matching index (ρ13 is the implementation of b13). The activation and communication events are represented in

the figure in a nonstandard notation (in practice, when using commercial tools, they would be part of an XML description). Also, the connections between runnables and ports and the state and communication variables are expressed in a nonstandard graphical description. Assume also that

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

​                                                           

​          20 ms     10 ms **e****1**          

​          **SW** **component** **1**     S1          

​          **SW** **component** **2**     S2     10 ms       20 ms     **e2**         **e3**          

​          p1   p2   p3          

​          **e4**       **e5**     p4   p5   p6          

​          c3          

​          **b****13**          

​          **b****22**           **b****21**          

​          **Synchronous behavior with     undersampling and delay**          

​          **b****13****b****21****b****22**          

​          **b****21**          

​          **b****13****b****21****b****22**          



**FIGURE 21.10** Semantics issues when mapping a typical synchronous behavior in AUTOSAR.





**542**                                       Real-Time Simulation Technologies

 

the components are implemented on different ECUs. The synchronous semantics illustrated in the bottom part of the figure cannot be easily defined using the available RTE events:

 

•   The activation events of the blocks are synchronized, whereas RTE periodic events are local to each ECU and, in principle, with an unspecified relative phase.

•   The causal dependency between the inputs and outputs of blocks b21 and b22 defines a partial order (a set of precedence constraints) in the execution of blocks. Expressing this partial order using the RTE timer

events or the events on data ports is not trivial. In our example, ρ21 must be activated after the production of data from ρ13 but only once every two activations of ρ13.

•   Finally, communication with a unit delay is difficult to express without

adding a dedicated runnable.

 

In reality, even if a translator from a Simulink to an AUTOSAR model would be highly appropriate for matching the needs of a model-based development flow, it is the inverse transformation that has received most of the attention and support from both sides (the AUTOSAR consortium and MathWorks®).

As part of the AUTOSAR specification, the document “Applying Simulink to AUTOSAR” [20] defines the rules to translate an AUTOSAR component (or a set of components) into a corresponding set of Simulink subsystems. Although one of the purposes of the document is to allow simulation of AUTOSAR components in a Simulink environment, a large part of the document is dedicated to the definition of translation methods that allow seamless integration of the code generated using the tools by MathWorks tools with the code generated by AUTOSAR tools for the RTE layer.

Also, the Real-Time Workshop® and Simulink Coder® [21] code generator products for the Simulink simulation environment today include a large section that is dedicated to the production of AUTOSAR components specifications and AUTOSAR-compatible code from sections of a Simulink model. However, a careful read of these user manuals reveals that in essence what is provided is not a general- purpose translator from Simulink to AUTOSAR, but a set of modeling guidelines and configurations of the code generators to produce an implementation of Simulink subsystems that is compliant with the AUTOSAR interfacing conventions and the RTE event semantics, including the automatic generation of AUTOSAR (XML) component specifications.

In essence, the model-to-model translation is straightforward (the code generation issues are more involved). AUTOSAR runnables are made to correspond to Simulink subsystems. When the AUTOSAR component has a single runnable, the subsystem models both the component and its runnable. When multiple runnables are part of the AUTOSAR component, each runnable corresponds to an atomic subsystem and the component to a wrapping (virtual) subsystem.

Sender/receiver ports map onto Simulink ports. A required port or R-Port is a Simulink input and a P-Port is a Simulink output port, with the corresponding



Specification and Simulation of Automotive Functionality               **543**

 

definition of interfaces mapped onto Simulink BusObjects. Some more complexities are necessary to represent the client/server (method-oriented) interfaces of AUTOSAR. The AUTOSAR standard declares the client/server communication among application components out of scope and limits itself to modeling the client ports of application components that are requesting (standardized) services from the BSW or the ECU abstraction. Also, in the case of ports modeling BSW services, the correspondence consists of a block (Stateflow® or S-function) obtaining as input the set of required arguments and calling internally the desired function with its standardized signature. Of course, capturing the semantics for the time at which the service is invoked is entirely another story, given that this semantics is not explicit in the AUTOSAR model.

With runnables, however, the situation is clear: runnables are executed in response to RTE events, which can be periodic (time driven) or generated by operations on ports. Correspondingly, in Ref. [20], a canonical pattern is defined where runnables are function-call subsystems in Simulink and for each SWC the corresponding Simulink subsystem defines an additional port, dedicated to the set of RTE events that trigger its runnables. The RTE events are collectively joined in a bus that is input to this special port. A bus selector is then used to route the appropriate events as triggers to the runnable subsystem. An example is shown in Figure 21.11 showing two cooperating components with their RTE event ports and the internals of the Component 1 subsystem in [Figure 21.12](#_bookmark129) showing the bus selector with the two outgoing function call signals for the runnables.

Inter-runnable communication is handled by inter-runnable ports, which correspond to additional input and output ports on the runnables subsystems. The implicit or explicit communication model affects the code generation mode but not the simulation model, where access to the ports always occurs implicitly according to the Simulink semantics.

When it comes to the composition of the AUTOSAR components and the system-level simulation, the recommended canonical pattern is the one represented in [Figure 21.13](#_bookmark129). In this pattern, the RTE events are generated by a single subsystem

​                  

​            1      R-Port1            

​            <RTE_TimingEvent1>      <RTE_TimingEvent2>      <RTE_TimingEvent3>      <RTE_TimingEvent4>            

​            1      P-Port1             2      P-Port2            

​            Component 2            

​            2      R-Port2            

​            RTEEevents P-Port1      R-Port1            

​            3      Rrt3            

​            R-Port2            

​            P-Port2            

​            Po            

​            3      P-Port3            

​            Component 1            

​            RTEEevents P-Port1             R-Port1      P-Port2            







**FIGURE 21.11** Simulink® model for forwarding runtime executable events to components and realizing data communication.



**544**                                       Real-Time Simulation Technologies

 

 

 

   1

RTEEevents

 

RTE_TimedEvent1()



2

R-Port1



In1 In2

 

RTE_TimedEvent2()





 

Runnable 1



Out1 Out2





1

P-Port 1



 

3

R-Port2



In1               Out1

 

In2               Out2

Runnable 2



2

P-Port 2



**FIGURE 21.12** Simulink® model for an AUTOSAR component with two runnables.

 

 

| RTEEvents              | R-Port1 | P-Port1 |
| ---------------------- | ------- | ------- |
| Function Call Creation | R-Port2 | P-Port2 |
|                        | R-Port3 | P-Port3 |

 

 

 

 

 

 

 

 

 

 

 

 

 

​            

​          Composition (AUTOSAR components)          

​          R-Port1          

​          P-Port1          

​          R-Port2          

​          P-Port2          

​          R-Port3          



Functional environment for simulation (device drivers and plant modeling)



**FIGURE 21.13** Canonical pattern for the Simulink® representation of an AUTOSAR composite.

 

labeled as *Function Call Creation*. The rationale for such a centralized generation is to collect in a single block the logic controlling the execution order of runnables. The internals of this subsystem are not specified in Ref. [20] as it states that “it is up to the user to implement this in an appropriate way.”

[21.3 <--- ](21_3.md) [   Зміст   ](README.md) [--> 21.5](21_5.md)