[18.2 <--- ](18_2.md) [   Зміст   ](README.md) [--> 18.4](18_4.md)

## 18.3. SIMULATOR FOR ROLLING MILL OPERATOR TRAINING

This section describes development work for the actual simulator in a time-ordered manner. First, the requirements are specified, then the design of the software components follows. Taking into consideration how to reduce the enormous complexity to a reasonable extent is important before selecting a tool and doing the coding work.



Simulation for Operator Training in Production Machinery              **447**

 

**18.1.1**             **r****eqUireMent** **a****nalysis oF the** **t****raining** **s****iMUlator**

From the basic considerations described in Section 18.2, some conclusions are drawn: The language for developing training simulators should be one of the typical industrial languages so that machine experts can understand and change the program code of the simulator. C++ or other object-oriented languages, which offer more freedom to the programmer, but may result in unreadable code, are not favored. A training session should not have a game character and no success indicators of a training session should be recorded, since this is demanded by the trade union. The behavior of some critical machine parts are typically not known in sufficient detail so as to initiate their modeling without further preliminary analysis. Consequently, the hardest-first approach to design is to be applied.

The application of a use-case analysis turned out to be a successful part in the phase of requirement specifications. A simplified use-case diagram is shown in Figure 18.3. The machine operator commands the automated roll exchange as well as the manual exchange. In case of problems, a second actor, the maintenance expert, works on the “manual roll exchange.” For training purposes, the simulator should substitute the physical machine for a use case “manual roll exchange.”

During the automated production, the roll exchange also runs autonomously, and the operator supervises the procedure. In the case of a failure in the system, the roll exchange must be done by the operator, thought not manually, on a low level of automation. Several hundred drives must be coordinated in about one hundred steps. After a repair, the machine must be brought into a condition where the automatic

​                                                                                           

​            Physical plant            

​            Training simulator            

​            Rolling mill            

​            Simulation            

​            Electronic control            

​            Electronic control            

​            HMI            

​            HMI            

​            Automatic roll exchange in production      Manual roll exchange                   Manual roll exchange after failure                              after failure            

​            Machine operator            

​            Maintenance person            







**FIGURE 18.3** Use cases of the roll exchange task.



**448**                                       Real-Time Simulation Technologies

 



   Hardware-in-the-loop simuation replaces the physical plant



Control system

identical to the physical plant



Operator/ Maintenance



 



 

Simulation



Actors



 

PC with WINMODTM

software



Sensors

 

Fieldbus communication





 

 

HMI



**FIGURE 18.4** Hardware configuration of the training simulator.

 

 

 

   Start

 



Signal sent by the mechanical interaction logic blocks

 

Damage



Manual control         Error condition

Automatic sequence

 

 is is to be trained



 

 

 

End without success

**FIGURE 18.5** State diagram of the training session.



Resume production





End of training (successful)



 

sequence may continue. Figure 18.4 shows the configuration of the actual system and the data flows among the components. The operator works with his HMI and a replica of the control system. Several hundred inputs and outputs must be communicated in real time between the control system and the simulator. To avoid the cost of copper wires, serial communication over an industrial fieldbus was the choice.

 

**18.1.2**             **s****ysteM** **d****esign oF the** **t****raining** **s****iMUlator**

As a first design step, based on the requirement analysis and on the introductory considerations, the course of the training session was defined. It can be documented as a state diagram (see Figure 18.5), according to UML notation [36]. Two exits are designed. One is the successful end, when the machine can resume its normal production again. When the trainee causes damage to the system after a mistake, the session is terminated (“game-over” situation).

An important aspect can be found in Figure 18.5: the automatic sequence (which is not a topic for the training) is a milestone for testing the system. All components of



Simulation for Operator Training in Production Machinery               **449**

 

the physical simulation are actuated by the control system and the system is running in a continuous mode.

The next design step is to find a structure for the simulation software. The simulator should replace the physical machine and provide its behavior to the replica of the electronic control system (see [Figure 18.4](#_bookmark97)). The artifacts of the simulation software are shown in Figure 18.6. Apart from the software component simulating the machine, there exists a visualization part. This is not for the trainee, who works with the HMI of the control system, but is required for administration and adjustments of the simulator. Since the operator of the physical machine cannot observe any process and must rely entirely on her/his operating panel, a three-dimensional visualization was not a requirement of the simulation system.

The exception generator is the component of the software in Figure 18.6 for defining and varying the training scenario. It means that the automatic cycle (see [Figure 18.5](#_bookmark97)) breaks and the actual training can start.

Another component of the system in Figure 18.6 is the input/output system. Via communication over a fieldbus, this part has to provide the state of about one thousand data points in real time.

The main component of the training simulator is the actual modeling software. A machine or plant consists of an incredible amount of things moving around, delivering signals or interacting with some other parts. To classify this, the machine

 

​                  

​            Training simulator            

​            I/O system            

​            Visualization            

​            Roll exchange system model            

​            To and from      the control system            

​            Generates failures to be mastered by the trainee            

​            Robot, mill stand,      spindle support, ...            

​            Exception generator            

​            Interacts mechanically            

​            0..M-1      0..M-1            

​            Subassembly            

​            0..*            

​            Logic      for mechanical interactions            

​            Sensor            

​            Interacts mechanically            

​            0..N-1      0..N-1            

​            1..*             Physical drive model            







**FIGURE 18.6** Objects of the training simulator.



**450**                                       Real-Time Simulation Technologies

 

was considered to consist of components called subassemblies in [Figure 18.6](#_bookmark98). A subassembly is a constructive mechanical part of the machine. It can be a single lever, a carriage for the rolls, or a complex handling system such as a robot. Artifacts called sensors are mounted on these subassemblies to provide information about positions, pressures, etc., while physics and kinematics of these assemblies are to be modeled. One assembly can carry drive units, which are hydraulic or pneumatic cylinders and motors, or electrical drives. Their task is to convert the output signals of the controller into a mechanical force and to apply this to the mechanic subassembly. The motion as a reaction can be found by solving the ODE. Since unrestricted motion is not possible for all components, additionally collisions must be detected. Such interactions can occur among subassemblies or among drives (in a few cases). An interaction can cause damage, which then is a severe mistake of the trainee. Interactions without damage are usually blocking situations, since the machine consists of rigid bodies. Those situations may be resolved by a reversal motion of the drives and are not an illegal condition of the system.

The states of a drive during its simulation lifecycle are shown in Figure 18.7. A normal, successful training end does not terminate the simulation, since the design of the deployed production plant also is made for perpetual operation.

Two points have important implications regarding the design personnel, which are documented in the data-flow diagram in [Figure 18.8](#_bookmark99). The simulator should model the behavior of the machine and its components; consequently, the designers are experts in the mechanical system. The input and output data of the simulation match exactly the sensors and actuators of the deployed system. But this exact mapping concept must be violated. Supplemental data flows must be added (see Figure 18.8):

 

​                  

​            Start of a new session            

​            Program start            

​            Successful training end            

​            Normal motion             (Severe      Reset to         mistake of the initial conditions           trainee)            

​            Collision            

​            Damage            

​            Irreversible damage, training ends without success            

​            Some collisions block the drives, but cause no damage; reversible            







 

**FIGURE 18.7** States that a drive runs through during simulation.



Simulation for Operator Training in Production Machinery               **451**

 

Fieldbus communication

   Simulator                                         Control system

Actor data

 



 

Simulation





 

 

Sim. output



Contr. output

 

 

Sensor data





Controller



 



Information for failure simulation

 

Force variables for restart after operator mistake



Controller state variables



 

 

**FIGURE 18.8** Data flow between simulator and controller.

\1.   The injection of a system fault that the trainee should master is not done by a trainer but automatically in a random manner. This makes it necessary to read the status data out of the control system to determine the instant when a component should fail.

\2.   If the trainee causes damage, the entire system must be restarted. It would be too time-consuming to restart the simulator and the control system again. Unfortunately, the machine components cannot fast rewind to their initial positions and states, since the control system does not accept this and would trigger an alarm condition. The solution is to overrule such error conditions by writing internal state variables of the controller.

 

Both tasks require knowledge of the controller internals. Consequently, it does not suffice to have experts for the physics modeling only, but also control experts who are familiar with the actual controller must be on the team throughout the project.

Furthermore, any intervention in the control system bears the danger that its behavior is changed for the subsequent training session. A mismatch with the physical system would be the consequence.

Now the basic design of the simulator is done. Before a decision for a certain software tool can be made, the complexity of the system should be investigated. Computing time limits the model number of mechanical components and the large number of possible interactions can increase the coding work excessively.

 

**18.1.3**             **r****edUction oF** **c****oMplexity**

The most important issue throughout the development process of a simulator is to reduce the complexity to a reasonable extent.



**452**                                       Real-Time Simulation Technologies

 

**18.1.3.1**     **Hardware** **Expense**

The simulator replaces the machine or plant and communicates with the clone of the control system. An obvious technique is to connect both systems with wires, as in the physical plant. The communication channel in [Figure 18.4 ](#_bookmark97)would consist of wires for every input and output. Looking at the cost, this is only affordable for small systems. Consequently, the usual way to establish this communication is to use a fieldbus system, which enables the transfer of thousands of data points with one single cable. As a further reasonable reduction step, some use a simulation inside the controller running in parallel. Since the exchange of data is done via variables, no additional

hardware is required. This minimal configuration is applied for two purposes:

 

\1.   To test some critical parts of the control software

\2.   To replace and simulate parts of the physical plant during service operations to establish a normal production cycle

 

Perhaps this can be called *embedded simulation*, *on-board simulation*, or *distributed simulation*. It should be mentioned that for safety-related systems, this configuration is not acceptable for FAT.

 

**18.1.3.2**     **Reduction of Possible Machine States**

The components of a typical production machine have interactions that are to be programmed for simulation. The amount of these artifacts should be estimated on the example of the actual project. In the actual project, we call these machine components subassemblies and drives (see [Figure 18.6](#_bookmark98)). If each unit can interact with every other, the maximum possible number is a combination by two:

 



*L*    = æ *N* ö + æ *M* ö





(18.1)



 

 

with



max    ç 2  ÷ø  ç 2  ÷ø



 

*N* Number of drive units

*M* Number of mechanical subassemblies

*L* Number of possble interactions

 

With the example of *N* = 40 and *M* = 8 for one part of the actual rolling mill model, the maximum number of possible interactions will be *L* = 808. It would not be affordable to program all these interactions. Fortunately, this is only the worst

case. The nature of heavy machinery yields a reduction of the number of possible interactions. Manipulators usually are designed to form a linear chain, where each drive can have an interaction with another at the end of its path. For example, a piece of load is handed over to the next at the end position of the first manipulator. Consequently, the amount of interactions is reduced to

 

*L* = (*N* 1) + (*M* 1) = *N* + *M* 2                  (18.2)



Simulation for Operator Training in Production Machinery               **453**



   Interactions to be modeled with logic blocks

Reversible collisions without damage



Interactions inhibited by PLC program



 

 

 

 

 

Severe damage

**FIGURE 18.9** Interactions of machine parts (collisions).





 

 

 

Unknown or ignored interactions



 

For the actual example, the number of interactions is reduced to *L* = 46, which is now realizable.

Additionally, many drives are clamping or locking devices. They have interactions that are possible only at one end of their stroke, which is a further reduction.

**18.1.3.3**     **Reduction** **of** **States** **by** **the** **Control** **Program**

The number of states that must be programmed for the simulation of the machine can be reduced further when we look at Figure 18.9.

Any control logic has programmed manifold *interlocks* that protect the plant from dangerous conditions and from the most probable operator mistakes. It is possible to exclude these situations to reduce the coding effort, since the PLC will not allow motions leading to them. This saves a lot of development time and also avoids overloading the computing capacity of the simulator. This technique will not be allowed if the purpose of the simulation is to test or commission the control software. But for operator training, this advantage can be taken.

Some collisions are reversible. They block the motion but do not lead to damage. The simulation must provide the opportunity for the operator to take back the move and to continue the training. It is remarkable that the programming of these collisions only requires influencing the motions of parts, but not changing the state of the system. No state logic is necessary to model this kind of interaction.

The number of collisions causing severe damage that must be simulated is now much lower than expected. They must be modeled with state logic that determines the course of the training session.

Furthermore, there always exist interactions with extremely improbable occurence. Provided that the system is not safety critical, we can trust the trainees not to act like monkeys on a typewriter [37] and do not model these situations.

Finally, in every automated system there are unknown states that may cause unexpected incidents even years after commission. But it is not the purpose of an OTS to find such failures.

**18.1.3.4**     **Depth of Simulation**

Dynamic systems in nature are preferably modeled with systems of ODEs, which can be solved numerically with solvers. Applying, for example, Newton’s law yields



**454**                                       Real-Time Simulation Technologies

 

a model for every mass in a mechanical system. If further we had ideal springs and viscous friction for the interaction among the masses, the resulting model would be a linear time invariant system, which is preferred for the analysis of dynamic systems [14]. This raises the hope to find a model for every thing in the mechanical system, since it consists of discrete, nearly ideal rigid bodies, but this expectation is misleading. Nonlinear springs, Coulomb friction, thermodynamical gas process, and complex kinematics lead to nonlinear equations of motion. Modern simulation environments can cover these effects, but at the expense of increased computing time. Another setback is the occurrence of time responses spread over several powers of ten, which leads to so-called stiff systems in a numerical sense. They are solvable with dedicated numerical solvers that require a higher sampling rate of data and even can cause instabilities in the result [38]. Hydraulic drives are an archetype of a stiff system [39]. Figure 18.10a shows an example from the actual project that is documented in this chapter. A mechanical load model on the right side of Figure 18.10a calculates speed and position from the force input with the help of Newton’s equation of motion. Force is coming from the cylinder model, accepting incoming oil flows to its chambers. The oil pressures are fed back to the proportional valve that determines the oil flow. Tubes are represented by a first-order capacity. To prevent negative cylinder pressures, a counterbalance valve throttles the outgoing oil stream. Finally, a load-sensing pump reduces the supply pressure to avoid loss of power, when high pressure is not required. On a standard PC, this system is not computable in real time. The computation of the load position in the system of Figure 18.10a motion needs ten times more than the counterpart in reality. Since simulation for operator training necessitates the real-time property, we cannot handle even one such drive. Thinking of the modeling discipline given in Section 18.1.3, the system must be simplified by omitting every detail not necessarily required, which is difficult, cumbersome, and

 

 

​            

​          pA     pB p control p supply     Loadsensing pump          

​          p0 pA     Signal     pB          

​          QA          

​          q1     qin          

​          p2A          

​          Mech. Load          

​          pout          

​          qoutA pinA          

​          QA pA           v Fout     QB pB     Cylinder          

​          1          

​          Position          

​          Tube1          

​          Load     p          

​          osition          

​          1     Control voltage          

​          pinB          

​          p0     p supply          

​          QB          

​          Force     Speed          

​          Proportional valve          

​          qin pout q1     Tube2          

​          qoutB          

​          p2B     Counterbalance valve          











 

 

1

Control





 

-K-



(a)

   1

S





 

1

Load



voltage       Gain        Integrator

with

limits



position



(b)

**FIGURE 18.10** Models of hydraulic cylinder drives. (a) Extended functionality, including load sensing pump, proportional valve, tube dynamics, counterbalance valves, cylinder, load;

(b)  ultimate simplification of a drive.



Simulation for Operator Training in Production Machinery              **455**

 

time consuming yet critical work during the requirement analysis. For many drives in the actual project, a minimal version of a simple integrator with upper and lower limits as shown in Figure 18.10b was sufficient.

Doing this reduction allowed hundreds of models to run on the computer in real time together with other tasks such as communication and visualization. In conclusion, a thorough simplification during the requirement analysis is recommended to obtain a well-performing simulator.

 

**18.1.4**             **s****iMUlation** **t****ool** **s****election and** **p****rograM** **c****oding**

The requirement analysis in the previous sections was a prerequisite for definitively choosing a simulation tool. The training sequence was defined, the model components were classified, and the basic behavior of moving machine parts was identified. All steps were carried out with the aim to minimize the development expense.

Most simulation problems in automation are designed as linear processes. For example, a flight landing simulation requires the operator to follow an exact sequence. Any deviation from the sequence causes the disruption of the training. Or, a chemical process has definite sequence steps that must be fulfilled; otherwise, the product would be lost.

Quite contrary to these, the maintenance operator in the rolling mill has many degrees of freedom without being punished for an unnecessary, incomplete, or even an incorrect action. In most cases, the person would waste time, but would not destroy machine components. Such a system has a huge amount of possible states, and the preferable modeling method to enable determining which state sequences are irrelevant is the discrete state space approach. This supports a state space search (such as effectively employed in, for example, computer chess) to whittle down all possible scenarios. As a result of the thorough analysis and design described in the previous sections, it turned out that all requirements can be fulfilled with a standard tool. Specific methods of artificial intelligence are not necessary.

 

**18.1.4.1**     **Simulation** **Tool**

As the result of the requirement analysis, it was possible to choose a simulation tool that is standard for modeling plant and machinery. The product of choice was Winmod [19].

 

*18.3.4.1.1*      *Discrete* *Time* *Simulation*

This simulation principle is the standard for modeling of physical or chemical processes. The actual simulator for the rolling mill is running in the loop with the logic control (HIL, [Figure 18.4](#_bookmark97)). The time increments have the same order of magnitude as the control program, which is about 0.05 s. Usually, a real-time operating system is required for such short cycle times. Winmod runs under Microsoft Windows with components embedded in some system routines with high priority. Of course, this cannot provide hard real-time behavior [17], but it is sufficient for simulation of systems of low dynamics. Since communication with the control device must fulfil the hard real-time condition, delegated fieldbus hardware (Profibus) in a slot of the simulation computer is used.



**456**                                       Real-Time Simulation Technologies

​                  

​            Init reset sequence            

​            Force robot to initial position      Start            

​            Stop Pause            

​            Exec            

​            Run            







 

**FIGURE 18.11** Block for generating signal patterns over time.

 

*18.3.4.1.2*      *Rudimentary Support of Events*

To describe dynamic systems that are driven by events, automation engineers use graphical tools based on the FSM formalism. Defined in the IEC 1131 standard, a language called sequential function chart allows programming of preferably linear chains of discrete steps. In addition to this, Winmod provides a tool to generate signal sequences over time (pattern generation, Figure 18.11). The sequence is defined with a simple text code and the graphical representation has an input to start the sequence. We used this feature to overrule the behavior of the machine model for initialization. This step beyond the physical reality is difficult, since the virtual machine is under the supervision of the actual controller, and error conditions must be avoided. The third possibility to handle events is a library of basic logic elements such as flip flops. All these state-oriented components run within the discrete time system and there is no separate discrete event control.

 

*18.3.4.1.3*      *Graphical Programming*

Since engineers prefer graphical descriptions, a representation similar to electric or electronic circuitry is provided. In UML 2.0, this corresponds to the communication diagram.

*18.3.4.1.4*      *Object* *Creation* *by* *Composition*

Object orientation is an essential concept for all kinds of software systems. Here it is preferred that new objects can be constructed only by combining objects, all derived from classes in a framework library. Some advanced concepts, such as multiple inheritance and object creation during runtime, are not allowed.

 

*18.3.4.1.5*      *Import of Variables*

The most powerful feature of a tool designated for machinery simulation is the capability to import variables, inputs, and outputs of the control system directly from its source code. This saves the work to define more than five hundred items for the actual project.

 

**18.1.4.2**     **Example** **Details**

The program code is a file of graphical drawings, consisting of blocks connected with signal lines (objects and message exchange in software terms). Here two important artifacts from [Figure 18.6 ](#_bookmark98)are explained.

 

*18.3.4.2.1*       *Integrator* *as* *Drive* *Design* *Pattern*

All drives and subassemblies are modeled with first-order behavior (see [Figure 18.12](#_bookmark100)). This makes the basic numerical integrator to a design pattern for these artifacts (left).



Simulation for Operator Training in Production Machinery               **457**

​                  

​            Manipulator shifting cylinder      X                               Y      Tn Xset set            

​            Mill stand clamps      open                      closed      close                  not closed      Tn                          open      set postion              not open      set                       position            







**FIGURE 18.12** Simple drive modeled with integrator (left side); a more complex drive (right).

 

 

More complex drives are composed of several blocks but always have a similar representation (see Figure 18.12, right).

*18.3.4.2.2*       *Exception* *Generator*

During a training session, the trainee should resolve exceptional situations. For this reason, faults should be generated, for example, by blocking a cylinder or stalling a signal due to a broken sensor. The trainer may enter a number to select a predefined fault situation. The fault is triggered when the controller (and together with it, the entire plant) is in a certain state (see [Figure 18.8](#_bookmark99)). If the trainee is working alone on the simulator without a trainer, one fault out of a predefined list may be triggered at random. Of course, training without exeption is also possible.

[18.2 <--- ](18_2.md) [   Зміст   ](README.md) [--> 18.4](18_4.md)