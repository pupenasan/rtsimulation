[8.3 <--- ](8_3.md) [   Зміст   ](README.md) [--> 8.5](8_5.md)

## 8.4. EMBEDDED SYSTEM VALIDATION AND VERIFICATION WITH THE VALIDATOR

This section describes two principal usage scenarios where the Validator excels compared to the state-of-the-art SIL and HIL simulations: advanced debugging of embedded systems and the incremental reengineering of existing embedded systems, including regression testing. Case studies illustrate each particular usage scenario of the Validator.

 

**8.1.1**            **s****imulaTion wiTh The** **v****alidaToR as The**

**B****asis FoR** **a****dvanced** **d****eBugging**

The key feature of the Validator that allows advanced debugging is that at every source code line in the controller tasks, the overall simulation, that is, of both the controller tasks and the plant, can be stopped. Then variables can be inspected and modified, external code can be executed, etc. Any C debugger can be attached to the Validator to perform the common debugging activities on the controller tasks. A state-of-the-art HIL simulation environment does not offer debugging capabilities. On the other hand, the impreciseness of the state-of-the-art SIL environments makes debugging unattractive or at least less helpful. The accuracy of a Validator simulation makes debugging a valuable means for the validation and verification of embedded systems. Figure 8.9 shows the schematic attachment of a debugger to the Validator. The jet fighter picture represents the plant model.

The screenshot in [Figure 8.10 ](#_bookmark51)shows a sample set of controller tasks in Eclipse with the gnu debugger (gdb) plugin. The screenshot is discussed in more detail below. We have used gdb as it also supports reverse (or historical) debugging. This allows the fol- lowing advanced debugging: Once you have turned on reverse debugging, the debugger records all state changes. So if the debugger stops execution at a breakpoint, you can- not only step forward as usual, but also step backward from that point in the code. For example, you want to find the cause of why an actuator value exceeds a certain limit. In this case you would set a conditional breakpoint where the actuator value is set. When the condition holds, the execution stops there and you can step back step by step.

​                                                                                           

​                                                             Validator simulation             Debugger such as      Visual Studio or      Eclipse+gdb as graphical front      end            







**FIGURE 8.9** Attaching a debugger to the Validator.



Validator Tool Suite                                         **209**

​     

**FIGURE 8.10** Start of a sample debugging session in Eclipse with the gnu debugger plugin.

 

 

​     
 Turn reverse debugging on/o 

**FIGURE 8.11** gnu debugger controls before activating reverse debugging.

 

The following sequence of screenshots illustrates reverse debugging from a developer’s point of view, with Eclipse and gdb as the graphical front end of the Validator.

In the state shown in Figure 8.10, we just entered the debugging mode by pressing the debug button (the bug in the menu bar on the top left side of the overall window). The execution stopped at an unconditional breakpoint in file dynamicsController.c. The statement at the breakpoint is an assignment statement in which the value of a variable called rtb_deg2rad2 is set. The line is highlighted in the tab labeled dynamicsController.c. According to the subwindow in the top right part of the window, the value of rtb_deg2rad2 is zero.

As a next step, we turn reverse debugging on by pressing the corresponding icon- button (see Figure 8.11). When stepping forward, the debug control panel changes to reflect the feature of reverse debugging, that is, being able to step forward and backward (see [Figure 8.12](#_bookmark52)).



**210**                                       Real-Time Simulation Technologies

​     

**FIGURE 8.12** gnu debugger controls for stepping forward *and* backward.

​     

**FIGURE** **8.13** A step forward.

​     

**FIGURE** **8.14** A step back.

 

Let us assume we just stepped forward one statement (see Figure 8.13). The assignment statement where we had originally stopped at the breakpoint has appar- ently changed the value of variable rtb_deg2rad2 from zero to approximately 1.807. We can now press the button to go back one step in the debugging process.

Figure 8.14 shows the result, that is, as expected, the value of variable rtb_deg2rad2 is



Validator Tool Suite                                         **211**

 

again zero. Note that the discrete event simulation of the Validator was implemented such that reverse debugging also functions across multiple tasks. For example, if you have turned on reverse debugging, step forward, and the task is interrupted by another task, that is, the simulation switches to another task, you can still step back up to the point where you started reverse debugging.

As a future extension to the Validator, we will add the feature to also be able to set breakpoints in the plant simulation that halt the overall simulation.

 

**8.1.2**            **s****imulaTion wiTh The** **v****alidaToR To** **R****eengineeR** **l****egacy** **s****ysTems**

The initial motivation for developing the Validator was to provide solid support for the incremental migration of the Engine Controller System (ECS) of a large automotive manufacturer to a version in which the timing behavior is explicitly modeled with the Timing Definition Language (TDL) [9,10]. For that purpose, the behavior of the legacy ECS and the TDL-based ECS should be compared in detail in a SIL simulation, that is, as close to the behavior on the actual platform as possible. Figure 8.15 shows the generic setup for this kind of regression testing by means of the ECS example. The Validator can simulate both versions in parallel.

Note that the ECS comprises millions of lines of code, mostly written in C, and runs on top of an OSEK operating system. This required an efficient implementation of the discrete event simulation of the Validator and an efficient co-simulation with

the automobile engine (=plant) model. The engine model is represented in MATLAB and Simulink. To accurately capture the times of the crank angle events, the engine

model is simulated with a variable step solver.

 

​                  

​            Original ECS            

​            Reengineered ECS            

​            +      –            

​            Validator simulation            







 

**FIGURE 8.15** Regression testing with the Validator.



**212**                                       Real-Time Simulation Technologies

 

Implementation of the TDL semantics in the reengineered ECS [9] required a dedicated TDL component called *TDL-Machine* to be executed every 0.5 ms from the task with highest priority in the system. The TDL-Machine used additional global variables to store and restore values of original global variables at certain points in time.

The highest priority task in the original ECS had a period of 1 ms. To avoid introduc- ing a new task, it was decided to change the original task to have a period of 0.5 ms, to call the TDL-Machine at every task invocation, and to execute the original task code every second invocation. Thus, the execution period of the original code was unaffected.

 

**8.4.2.1 Sample Analysis**

Let us take a look at one of the results of the regression tests: Figure 8.16 shows a selection of three signals monitored during a simulation of the two ECS versions with the Validator. Signals S1 and S2 are similar in the two versions. One can notice some delays introduced in the modified version by the execution times of the TDL-Machine. Signal S3 differs significantly towards the end of the simulated time frame.

The cause of the difference could be found by an investigation of task execution profiles. Task execution profile plots are shown in Figures 8.17a through c. In each plot, every task is assigned an identification number (ID). The execution state of a task

with ID *i* is represented by a signal with *y*-coordinates between *i* and *i* + 0.6. A level of *i* + 0.6 indicates the execution mode E, a level of *i* + 0.4 means preempted mode P, a level of *i* + 0.2 indicates the waiting mode W, and a level of *i* means the task is in the suspended mode S. The plot in Figure 8.17a is obtained from the simulation of

the original software, the plot in Figure 8.17b is obtained from the simulation of the software with the TDL-Machine and its execution time, and the plot in Figure 8.17c corresponds to the simulation of the software with the TDL-Machine but without its execution time. In case of Figure 8.17c, the TDL-Machine was executed in simula- tion, but its execution time was set to zero, for the purpose of debugging.

The ID of the highest priority task is 8. In the simulation represented by the plot in Figure 8.17a, the execution time of this task at time instant 5 is approximately 0.05 ms.

 

   5                                                                              Original

*S*1                                                                                 Modi ed

0 0                1                2                3                4                5                6

40

*S*2 20

​     

​                                            1                                                        2                  3                                     4                                                        5                                     6                                          0.2                                                   0.4                                0.6                                                   0.8        1                                1.2                                                   1.4                                1.6                                                   1.8                                2                            



00



10

*S*3 5

00

Time (ms)

 

**FIGURE 8.16** Comparison of three signals.



Validator Tool Suite                                         **213**



 

   16

14

​     ![Підпис: Task state](file:///C:/Users/OLEKSA~1/AppData/Local/Temp/msohtmlclip1/01/clip_image010.png)12

10

8

6

4

2

0

3.8 4.0 4.2 4.4 4.6 4.8 5.0 5.2 5.4 5.6 5.8 6.0





 

 

 

 

 

 

 

 

6.2 6.4 6.6 6.8





 

 

 

 

 

 

 

 

7.0





 

 

 

 

 

 

 

 

7.2





14

13

12

11

10

9

8

7

6

5

4

3

2

1

7.4 7.6 7.8 8.0     0



Time (s) (a)

16

14

12

​     ![Підпис: Task state](file:///C:/Users/OLEKSA~1/AppData/Local/Temp/msohtmlclip1/01/clip_image011.png)10

8

6

4

2

0



×10–3

 

   14

12

11

10

9

8

7

6

5

4

3

2

1



3.8 4.0 4.2 4.4 4.6 4.8 5.0 5.2 5.4 5.6 5.8 6.0

Time (s) (b)



6.2 6.4 6.6 6.8



7.0



7.2



7.4 7.6 7.8 8.0     0

×10–3



 



   16

14

​     ![Підпис: Task state](file:///C:/Users/OLEKSA~1/AppData/Local/Temp/msohtmlclip1/01/clip_image010.png)12

10

8

6

4

2

0

3.8 4.0 4.2 4.4 4.6 4.8 5.0 5.2 5.4 5.6 5.8 6.0





 

 

 

 

 

 

6.2 6.4 6.6 6.8





 

 

 

 

 

 

7.0





 

 

 

 

 

 

7.2



14

13

12

11

10

9

8

7

6

5

4

3

2

​     

​        0        



7.4 7.6 7.8 8.0     1





Time (s) (c)



×10–3



**FIGURE 8.17** (a) Original ECS. (b) ECS with additional functionality. (c) ECS with addi- tional functionality whose execution time is set to zero.

 

In the simulation of the plot in Figure 8.17b, the same execution requires about

0.20 ms. In Figure 8.17c, the same task execution takes about 0.17 ms. It follows that the main difference between the executions in Figures 8.17a and 8.17b is not given by the execution time of the TDL-Machine, but it is because the different state of the hardware platform resulted from the execution of the TDL function. Since the TDL-Machine performs many accesses to new memory locations, the main differ- ence occurs most probably in the cache state. If the delays in the signals in the new version are not acceptable, then one should focus on minimizing the effect of the TDL-Machine on the platform state rather than on minimizing the execution time of the function code. For example, the TDL-Machine could be changed to operate only on local variables, or additional variables used by this function could be stored in the processor’s internal memory space.

[8.3 <--- ](8_3.md) [   Зміст   ](README.md) [--> 8.5](8_5.md)