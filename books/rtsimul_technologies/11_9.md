[11.8 <--- ](11_8.md) [   Зміст   ](README.md) [--> 11.10](11_10.md)

## 11.9. SIMULATION ENGINE

This section describes the simulation engine used for simulation of the models constructed in the presented system-level performance estimation framework with the objective to obtain quantitative performance estimates.

У цьому розділі описано механізм моделювання, який використовується для моделювання моделей, побудованих у представленій структурі оцінки продуктивності на системному рівні з метою отримання кількісних оцінок продуктивності.

### 11.9.1 Discrete Event Simulation

To support multiple different models-of-computation, a discrete event simulation engine has been chosen for coordinating the execution of the individual service models and their internal processes. Discrete event modeling is used within a range of different application domains and described thoroughly in [14,15].

Для підтримки кількох різних моделей обчислень було обрано механізм симуляції дискретних подій для координації виконання окремих моделей послуг та їхніх внутрішніх процесів. Моделювання дискретних подій використовується в ряді різних областей застосування та детально описано в [14,15].

A custom simulation engine for prototype use supporting the modeling framework presented has been implemented during the course of this project. The reason for implementing a custom simulation was to obtain maximum control over the simulation kernel in order to be able to validate the ideas of the framework. The implemented discrete event simulation kernel keeps track of simulation time and schedules the execution of the individual processes of the service models according to their sensitivity to events.

У ході цього проекту було реалізовано спеціальний механізм моделювання для використання прототипу, що підтримує представлену структуру моделювання. Причиною впровадження спеціального моделювання було отримання максимального контролю над ядром моделювання, щоб мати можливість перевірити ідеї фреймворку. Впроваджене ядро моделювання дискретних подій відстежує час моделювання та планує виконання окремих процесів моделей сервісу відповідно до їх чутливості до подій.

As already described in Section 11.4, a number of events are associated with the lifetime of a service request, which by their occurrence can trigger processes sensitive to the event. The occurrence of a given event allows a waiting process to become activated at different phases of the simulation as described by the designer of the model and depending on the desired behavior.

Як уже було описано в Розділі 11.4, ряд подій пов’язано з часом існування запиту на службу, що своєю появою може ініціювати процеси, чутливі до події. Виникнення даної події дозволяє активувати процес очікування на різних фазах моделювання, як описано розробником моделі та залежно від бажаної поведінки.

The simulation engine provides basic semantics for expressing the behavior of a service model through a process-like behavior for modeling concurrency and a number of waitFor statements as listed in Table 11.1, which will cause the execution of the model to block.

Механізм моделювання забезпечує основну семантику для вираження поведінки моделі сервісу через поведінку, подібну до процесу, для моделювання паралелізму та низку операторів waitFor, перелічених у таблиці 11.1, які призведуть до блокування виконання моделі.

- **waitFor**(time) causes the process to block until the specified time has passed. The effect is that an event is being scheduled with a time tag of the current simulation time plus the specified time value. The simulation engine will fire the event when the specified simulation time has been reached and the process will resume its execution.
- **waitFor**(service request, event type) causes the process to block till the specified event type of the specific service request instance is being fired. When this occurs, the process will resume its execution and the time tag of the event will be decided by the simulation engine.

- **waitFor**(interface, service request type, event type) causes the process to block till the specified service request type and event type is being fired at the specified service model interface. In this case, the simulation time will also be annotated by the simulation engine when the event is fired.
- **waitFor**(event) causes the process to block till the specified event is fired. When the event is fired, the process will be notified and continue its execution.     

- **waitFor**(час) блокує процес, доки не мине вказаний час. Ефект полягає в тому, що подія планується з тегом часу поточного часу симуляції плюс вказане значення часу. Механізм моделювання запустить подію, коли буде досягнуто вказаний час моделювання, і процес відновить своє виконання.
- **waitFor**(сервісний запит, тип події) блокує процес, доки не буде запущено вказаний тип події конкретного екземпляра сервісного запиту. Коли це станеться, процес відновить своє виконання, а мітка часу події буде визначена системою моделювання.

- **waitFor**(інтерфейс, тип запиту на службу, тип події) блокує процес, доки вказаний тип запиту на службу та тип події не буде запущено в інтерфейсі вказаної моделі служби. У цьому випадку час моделювання також буде анотовано механізмом моделювання під час запуску події.
- **waitFor**(event) блокує процес, поки не буде запущено вказану подію. Коли подія запускається, процес буде повідомлено та продовжить своє виконання.

**TABLE** **11.1** **Process** **Wait** **Types**

**waitFor**(time)

**waitFor**(service request, event type) 

**waitFor**(interface, service request type, event type) 

**waitFor**(event)

### 11.9.2 Representation of Time

The simulation engine is implemented as a discrete event simulation engine using a delta-delay based representation of time [13]. The delta-delay based representation divides time into a two-level structure: regular time and delta-time. Between every regular time interval, there is a potentially infinite number of delta-time points *t* + δ*, t* + *2*δ, …. Each event is marked with a time tag that holds a simulation time value, indicating when the event is to occur. Every time an event is fired and new events are generated having the same regular time value as the current time value of the simulation (e.g., in case of a feedback loop), the new event will have a time stamp with the same regular time value but now with a delta value incremented by one. The use of delta-delays ensures that no computations can take place in zero-time, but will always experience at minimum a delta-delay. The delta-delay based representation is making simulations deterministic because the use of delta-time makes it possible to distinguish between two events generated at the same point in time, which is to be processed first by looking at their delta-value.

Механізм моделювання реалізовано як механізм моделювання дискретних подій із використанням представлення часу на основі дельта-затримки [13]. Представлення на основі дельта-затримки розділяє час на дворівневу структуру: звичайний час і дельта-час. Між кожним регулярним інтервалом часу існує потенційно нескінченна кількість точок дельта-часу *t* + δ*, t* + *2*δ, …. Кожна подія позначена тегом часу, який містить значення часу моделювання, що вказує, коли має відбутися подія. Кожного разу, коли запускається подія та генеруються нові події, що мають таке ж регулярне значення часу, як і поточне значення часу моделювання (наприклад, у випадку циклу зворотного зв’язку), нова подія матиме мітку часу з таким же регулярним значенням часу але тепер зі значенням дельта, збільшеним на одиницю. Використання дельта-затримок гарантує, що жодні обчислення не можуть відбуватися за нульовий час, але завжди будуть мати принаймні дельта-затримку. Представлення на основі дельта-затримки робить моделювання детермінованим, оскільки використання дельта-часу дає змогу розрізнити дві події, згенеровані в один і той самий момент часу, які спочатку потрібно обробити, дивлячись на їх дельта-значення.

Application models, on the one hand, have no notion of time. It is only when the application model is mapped onto a platform model that it becomes possible to annotate the execution time of the application model by relating the execution of its tasks and the generation of service requests to discrete time instances.

З одного боку, прикладні моделі не мають поняття часу. Лише тоді, коли модель додатка відображається на моделі платформи, стає можливим анотувати час виконання моделі додатка, пов’язуючи виконання його завдань і генерацію запитів на обслуговування до окремих екземплярів часу.

In the platform model, on the other hand, time is represented explicitly using the delta-based representation of time. Each model of the platform can be modeled with arbitrary delays or specify a clock frequency at which they want to be evaluated. In this way, it is possible to model synchronous components in the platform model, which are activated only at regular discrete time instances. Thus, the tasks of the application model are blocking while the service requests are being processed in the platform model, which enables associating an execution time metric with tasks. Similarly, it is possible to annotate tasks with other types of metrics such as power costs, etc.

З іншого боку, у моделі платформи час представлено явно за допомогою представлення часу на основі дельти. Кожну модель платформи можна моделювати з довільними затримками або вказати тактову частоту, на якій вони хочуть оцінюватися. Таким чином, можна змоделювати синхронні компоненти в моделі платформи, які активуються лише в регулярні дискретні моменти часу. Таким чином, завдання прикладної моделі блокуються під час обробки сервісних запитів у моделі платформи, що дозволяє зв’язати метрику часу виконання із завданнями. Подібним чином можна позначати завдання іншими типами показників, такими як вартість електроенергії тощо.

A special event *type* is used to represent hardware clocks used for example by models described using clocked synchronous models-of-computation. These models do not use time explicitly, instead they represent time as a cycle count. To use synchronous models of computation in the currently implemented simulation engine, these models must specify a clock frequency that determines how often they are to be evaluated. Regular events are removed from the event list, executed, and then disposed. Because events are bound to a unique time instance, they can thus occur only once. The special event type used to represent hardware clocks, however, is implemented as a reschedulable event in the simulation engine, which takes care of handling the uniqueness of each instance of this event type. Such a clock event is automatically rescheduled and reinserted into the event list. Each clock event object has a list of active processes that are to be evaluated when the clock ticks. This list is updated dynamically during simulation, and in case a clock has no active processes in the active list, the clock itself is removed from the pending list of events to increase simulation performance. When a clock event object is inserted into the event list, it will be sorted according to the simulation time of the next clock tick of the clock event object. It is also possible to have a clock object that contains no static period. In this case, the clock ticks can be specified as random time points or as a list of periods that can be used once or repeated.

Спеціальна подія *тип* використовується для представлення апаратних годинників, які використовуються, наприклад, моделями, описаними за допомогою тактованих синхронних моделей обчислень. Ці моделі не використовують час явно, натомість вони представляють час як кількість циклів. Щоб використовувати синхронні моделі обчислень у реалізованому механізмі моделювання, ці моделі повинні вказати тактову частоту, яка визначає, як часто їх потрібно оцінювати. Звичайні події видаляються зі списку подій, виконуються, а потім видаляються. Оскільки події прив’язані до унікального моменту часу, вони можуть відбутися лише один раз. Спеціальний тип події, який використовується для представлення апаратних годинників, однак, реалізований як перепланована подія в механізмі моделювання, який піклується про обробку унікальності кожного екземпляра цього типу події. Така подія годинника автоматично переплановується та знову вставляється до списку подій. Кожен об’єкт події годинника має список активних процесів, які мають бути оцінені, коли годинник цокає. Цей список динамічно оновлюється під час симуляції, і якщо годинник не має активних процесів у списку активних, сам годинник видаляється зі списку незавершених подій, щоб підвищити продуктивність моделювання. Коли об’єкт події годинника вставлено до списку подій, він буде відсортований відповідно до часу моделювання наступного такту об’єкта події годинника. Також можна мати об’єкт годинника, який не містить статичного періоду. У цьому випадку такти годинника можуть бути визначені як випадкові моменти часу або як список періодів, які можна використовувати один раз або повторювати.

Of course, the platform model can also contain service models that are activated on the arrival of service requests only triggered by the event associated with the request of the service. In these cases, the occurrence of such an event, at a specific simulation time, will activate the blocking process. This blocking allows modeling of, for example, propagation delays associated with combinational hardware blocks, etc. The modeling of such elements can also be handled in zero regular time by means of the delta-delay mechanism. 

Звичайно, модель платформи також може містити моделі послуг, які активуються при надходженні запитів на обслуговування, викликаних лише подією, пов’язаною із запитом на послугу. У цих випадках виникнення такої події в певний час моделювання активує процес блокування. Це блокування дозволяє моделювати, наприклад, затримки розповсюдження, пов’язані з комбінованими апаратними блоками тощо. Моделювання таких елементів також може виконуватися за нульовий регулярний час за допомогою механізму дельта-затримки.

### 11.9.3 Simulation

The simulation engine uses two event lists for controlling the simulation: one for delta events and one for regular events. The delta event list, on the one hand, contains only events with a time tag equal to the current simulation time plus one delta cycle. The regular event list, on the other hand, contains pending events with a time tag in which the regular time is greater than the current simulation time. The regular event list is sorted according to the time stamp of the events in increasing order. In this way, the head of the regular event list always points to the event with the lowest time tag. The simulation engine always checks the delta event list first. If the list is not empty, the delta cycle count is incremented and all events contained in the delta event list are fired one by one till the list is empty, implying that all events belonging to the same delta cycle have been fired.

Механізм симуляції використовує два списки подій для керування симуляцією: один для дельта-подій і один для регулярних подій. Список дельта-подій, з одного боку, містить лише події з тегом часу, що дорівнює поточному часу моделювання плюс один дельта-цикл. З іншого боку, список звичайних подій містить незавершені події з тегом часу, у якому звичайний час перевищує поточний час симуляції. Звичайний список подій сортується відповідно до міток часу подій у порядку зростання. Таким чином, початок звичайного списку подій завжди вказує на подію з найнижчою міткою часу. Механізм моделювання завжди спочатку перевіряє список дельта-подій. Якщо список не порожній, кількість циклів дельта збільшується, і всі події, які містяться в списку подій дельта, запускаються одна за одною, доки список не стане порожнім, маючи на увазі, що всі події, що належать до одного циклу дельта, запускаються.

If no delta events are pending (i.e., the delta event list is empty), the simulation engine removes the first event in the regular event list and advances the simulation time to the time specified by the time tag of the event. Also, the current delta count is cleared and the event is then fired.

Якщо жодна дельта-подія не очікує на розгляд (тобто список дельта-подій порожній), механізм симуляції видаляє першу подію зі звичайного списку подій і переносить час симуляції на час, визначений тегом часу події. Крім того, поточний дельта-лічильник очищається, а подія запускається.

Delta-delay based discrete simulation engines suffer the risk of entering infinite loops where regular time is not advanced and only the delta cycle is incremented. A naive approach to handle this is implemented, allowing the designer to specify a maximum number of delta cycles to be allowed before the simulation engine quits the simulation.

Механізми дискретного моделювання на основі дельта-затримки страждають від ризику входження в нескінченні цикли, де регулярний час не просувається вперед, а збільшується лише дельта-цикл. Реалізовано наївний підхід до вирішення цього, дозволяючи розробнику вказати максимальну кількість дельта-циклів, які будуть дозволені перед тим, як система моделювання вийде з моделювання.

The firing of an event can, of course, cause new events to be generated and scheduled in the simulation engine. If a new event is generated having its time tag set to the same regular time value as the current simulation time, it is added to the delta event list. Otherwise, it is scheduled according to its time tag and inserted into the regular event list according to the time tag specified. The delta event list contains only events with a time tag equal to the current simulation time plus one delta cycle. After an event has been fired, it is checked if the event type of the event is periodic. Events belonging to a periodic event type (e.g., the special clock event object described in Section 11.9.2) are then automatically rescheduled and inserted into the event list at the correct position.

Запуск події може, звичайно, спричинити генерацію та планування нових подій у механізмі моделювання. Якщо генерується нова подія, для тегу часу встановлено таке ж значення звичайного часу, як і поточний час моделювання, вона додається до списку дельта-подій. В іншому випадку воно планується відповідно до тегу часу та вставляється до списку звичайних подій відповідно до зазначеного тегу часу. Список дельта-подій містить лише події з тегом часу, що дорівнює поточному часу симуляції плюс один дельта-цикл. Після запуску події перевіряється, чи є тип події періодичним. Події, що належать до типу періодичної події (наприклад, спеціальний об’єкт події годинника, описаний у Розділі 11.9.2), потім автоматично переплановуються та вставляються у список подій у правильному місці.

### 11.9.4 Service-Based M odel-of-Computation for A rchitecture M odeling

One example of a custom model-of-computation for describing service models is the model-of-computation developed for modeling synchronous hardware components presented in [16,17], which is based on Hierarchical Colored Petri Nets (HCPNs) [18]. HCPNs have been selected because of the great modeling capabilities with respect to concurrency and resource access and the compositional properties that match the requirements of service models well. Traditional HCPNs, however, suffer from a number of inadequacies with respect to model complexity and especially the obtainable simulation speed. These issues are addressed by, for example, defining special execution semantics. Details of the construction, simulation, and workings of service models based on HCPNs can be found in [16,17].

Одним із прикладів спеціальної моделі обчислень для опису моделей послуг є модель обчислень, розроблена для моделювання синхронних апаратних компонентів, представлена в [16,17], яка базується на ієрархічних кольорових мережах Петрі (HCPN) [18]. HCPN було обрано через великі можливості моделювання щодо паралельності та доступу до ресурсів, а також композиційні властивості, які добре відповідають вимогам моделей обслуговування. Традиційні HCPN, однак, страждають від низки недоліків щодо складності моделі та особливо доступної швидкості моделювання. Ці проблеми вирішуються, наприклад, шляхом визначення спеціальної семантики виконання. Подробиці побудови, моделювання та роботи моделей обслуговування на основі HCPN можна знайти в [16,17].

[11.8 <--- ](11_8.md) [   Зміст   ](README.md) [--> 11.10](11_10.md)