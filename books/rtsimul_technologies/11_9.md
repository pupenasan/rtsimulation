[11.8 <--- ](11_8.md) [   Зміст   ](README.md) [--> 11.10](11_10.md)

## 11.9. SIMULATION ENGINE

This section describes the simulation engine used for simulation of the models constructed in the presented system-level performance estimation framework with the objective to obtain quantitative performance estimates.

 

**11.1.1**             **d****iScrete** **e****vent** **S****imuLation**

To support multiple different models-of-computation, a discrete event simulation engine has been chosen for coordinating the execution of the individual service models and their internal processes. Discrete event modeling is used within a range of different application domains and described thoroughly in [14,15].

A custom simulation engine for prototype use supporting the modeling framework presented has been implemented during the course of this project. The reason for implementing a custom simulation was to obtain maximum control over the simulation kernel in order to be able to validate the ideas of the framework. The implemented discrete event simulation kernel keeps track of simulation time and schedules the execution of the individual processes of the service models according to their sensitivity to events.

As already described in Section 11.4, a number of events are associated with the lifetime of a service request, which by their occurrence can trigger processes sensitive to the event. The occurrence of a given event allows a waiting process to become activated at different phases of the simulation as described by the designer of the model and depending on the desired behavior.

The simulation engine provides basic semantics for expressing the behavior of a service model through a process-like behavior for modeling concurrency and a number of waitFor statements as listed in Table 11.1, which will cause the execution of the model to block.

**waitFor**(time) causes the process to block until the specified time has passed. The effect is that an event is being scheduled with a time tag of the current simulation time plus the specified time value. The simulation engine will fire the event when the specified simulation time has been reached and the process will resume its execution.

​     

**TABLE** **11.1**

**Process** **Wait** **Types**

**waitFor**(time)

**waitFor**(service request, event type) **waitFor**(interface, service request type, event type) **waitFor**(event)

​     



Service-Based Simulation Framework                             **275**

 

**waitFor**(service request, event type) causes the process to block till the specified event type of the specific service request instance is being fired. When this occurs, the process will resume its execution and the time tag of the event will be decided by the simulation engine.

**waitFor**(interface, service request type, event type) causes the process to block till the specified service request type and event type is being fired at the specified service model interface. In this case, the simulation time will also be annotated by the simulation engine when the event is fired.

**waitFor**(event) causes the process to block till the specified event is fired. When the event is fired, the process will be notified and continue its execution.

 

**11.1.2**             **r****ePreSentation** **of** **t****ime**

The simulation engine is implemented as a discrete event simulation engine using a delta-delay based representation of time [13]. The delta-delay based representation divides time into a two-level structure: regular time and delta-time. Between every

regular time interval, there is a potentially infinite number of delta-time points *t* + δ*, t* + *2*δ, …. Each event is marked with a time tag that holds a simulation time value, indicating when the event is to occur. Every time an event is fired and new events

are generated having the same regular time value as the current time value of the simulation (e.g., in case of a feedback loop), the new event will have a time stamp with the same regular time value but now with a delta value incremented by one. The use of delta-delays ensures that no computations can take place in zero-time, but will always experience at minimum a delta-delay. The delta-delay based representation is making simulations deterministic because the use of delta-time makes it possible to distinguish between two events generated at the same point in time, which is to be processed first by looking at their delta-value.

Application models, on the one hand, have no notion of time. It is only when the application model is mapped onto a platform model that it becomes possible to annotate the execution time of the application model by relating the execution of its tasks and the generation of service requests to discrete time instances.

In the platform model, on the other hand, time is represented explicitly using the delta-based representation of time. Each model of the platform can be modeled with arbitrary delays or specify a clock frequency at which they want to be evaluated. In this way, it is possible to model synchronous components in the platform model, which are activated only at regular discrete time instances. Thus, the tasks of the application model are blocking while the service requests are being processed in the platform model, which enables associating an execution time metric with tasks. Similarly, it is possible to annotate tasks with other types of metrics such as power costs, etc.

A special event *type* is used to represent hardware clocks used for example by models described using clocked synchronous models-of-computation. These models do not use time explicitly, instead they represent time as a cycle count. To use synchronous models of computation in the currently implemented simulation engine, these models must specify a clock frequency that determines how often they are to be evaluated. Regular events are removed from the event list, executed, and then disposed. Because events are bound to a unique time instance, they can thus occur



**276**                                       Real-Time Simulation Technologies

 

only once. The special event type used to represent hardware clocks, however, is implemented as a reschedulable event in the simulation engine, which takes care of handling the uniqueness of each instance of this event type. Such a clock event is automatically rescheduled and reinserted into the event list. Each clock event object has a list of active processes that are to be evaluated when the clock ticks. This list is updated dynamically during simulation, and in case a clock has no active processes in the active list, the clock itself is removed from the pending list of events to increase simulation performance. When a clock event object is inserted into the event list, it will be sorted according to the simulation time of the next clock tick of the clock event object. It is also possible to have a clock object that contains no static period. In this case, the clock ticks can be specified as random time points or as a list of periods that can be used once or repeated.

Of course, the platform model can also contain service models that are activated on the arrival of service requests only triggered by the event associated with the request of the service. In these cases, the occurrence of such an event, at a specific simulation time, will activate the blocking process. This blocking allows modeling of, for example, propagation delays associated with combinational hardware blocks, etc. The modeling of such elements can also be handled in zero regular time by means of the delta-delay mechanism.

 

**11.1.3**             **S****imuLation**

The simulation engine uses two event lists for controlling the simulation: one for delta events and one for regular events. The delta event list, on the one hand, contains only events with a time tag equal to the current simulation time plus one delta cycle. The regular event list, on the other hand, contains pending events with a time tag in which the regular time is greater than the current simulation time. The regular event list is sorted according to the time stamp of the events in increasing order. In this way, the head of the regular event list always points to the event with the lowest time tag. The simulation engine always checks the delta event list first. If the list is not empty, the delta cycle count is incremented and all events contained in the delta event list are fired one by one till the list is empty, implying that all events belonging to the

same delta cycle have been fired.

If no delta events are pending (i.e., the delta event list is empty), the simulation engine removes the first event in the regular event list and advances the simulation time to the time specified by the time tag of the event. Also, the current delta count is cleared and the event is then fired.

Delta-delay based discrete simulation engines suffer the risk of entering infinite loops where regular time is not advanced and only the delta cycle is incremented. A naive approach to handle this is implemented, allowing the designer to specify a maximum number of delta cycles to be allowed before the simulation engine quits the simulation.

The firing of an event can, of course, cause new events to be generated and scheduled in the simulation engine. If a new event is generated having its time tag set to the same regular time value as the current simulation time, it is added to the delta event list. Otherwise, it is scheduled according to its time tag and inserted into the



Service-Based Simulation Framework                             **277**

 

regular event list according to the time tag specified. The delta event list contains only events with a time tag equal to the current simulation time plus one delta cycle. After an event has been fired, it is checked if the event type of the event is periodic. Events belonging to a periodic event type (e.g., the special clock event object described in Section 11.9.2) are then automatically rescheduled and inserted into the

event list at the correct position.

 

**11.1.4**            **S****ervice****-B****aSed** **m****odeL****-****of****-c****omPutation** **for** **a****rchitecture** **m****odeLing**

One example of a custom model-of-computation for describing service models is the model-of-computation developed for modeling synchronous hardware components presented in [16,17], which is based on Hierarchical Colored Petri Nets (HCPNs) [18]. HCPNs have been selected because of the great modeling capabilities with respect to concurrency and resource access and the compositional properties that match the requirements of service models well. Traditional HCPNs, however, suffer from a number of inadequacies with respect to model complexity and especially the obtainable simulation speed. These issues are addressed by, for example, defining special execution semantics. Details of the construction, simulation, and workings of service models based on HCPNs can be found in [16,17].

[11.8 <--- ](11_8.md) [   Зміст   ](README.md) [--> 11.10](11_10.md)