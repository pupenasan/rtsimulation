[2.3 <--- ](2_3.md) [   Зміст   ](README.md) [--> 2.5](2_5.md)

## 2.4. DEVS-БАЗОВАНІ ФОРМАЛЬНІ ПІДХОДИ ДЛЯ ПРОЕКТУВАННЯ РОЗПОДІЛЕНИХ ОБЧИСЛЮВАЛЬНИХ СИСТЕМ РЕАЛЬНОГО ЧАСУ 

У цьому розділі ми представимо, як DEVS і RT-DEVS використовуються для допомоги в проектуванні розподілених комп’ютерних систем реального часу. Задіяно декілька різних типів розподілених систем, і ми побачимо, що на підхід DEVS не впливають окремі типи систем. Таким чином, він має великий потенціал для застосування до будь-якої з сучасних розподілених систем реального часу, у той час як інші формальні підходи обмежені у своїй функціональності.

### 2.4.1 Допомога в розробці розподіленої VE реального часу

Використання VE є одним із провідних комп’ютерних методів, який має багато сфер застосування. Порівняно з іншими комп’ютерними техніками, він, по суті, може забезпечити дуже привабливу та зручну для користувача платформу взаємодії між людиною та комп’ютером, за допомогою якої кінцеві користувачі можуть грати з комп’ютерними системами «як у реальних». Дійсно, VE широко використовується в навчанні, іграх, електронному навчанні та багатьох інших суміжних сферах [31–33]. Варто зазначити, що сучасне проектування VE – це складний процес, який враховує багато різних компонентів та їх взаємодію в системі. Крім того, розробка сучасних систем VE включає в себе багато різних нових комп’ютерних методів, включаючи об’єктно-орієнтоване проектування, об’єктно-орієнтовані мови програмування, мови сценаріїв, веб-технології на основі HTML і XML і тривимірну (3D) візуалізацію графіки, просто щоб назвіть кілька. Зокрема, методи візуалізації 3D-графіки в реальному часі та розповсюдження компонентів VE у режимі реального часу відіграють важливу роль у сучасних застосуваннях VE. Таким чином, те, як ефективно застосувати 3D техніку в розподіленому обчислювальному середовищі реального часу, приносить багато проблем, які не зустрічаються в традиційних підходах VE.

Дійсно, розробка ефективного розподіленого VE в реальному часі є складною практикою, яка передбачає використання багатьох різних підходів до проектування системи. Порівняно зі звичайними компонентами програмного забезпечення, взаємопов’язані та взаємодіючі віртуальні об’єкти в системі VE мають бути точно означені з точки зору як візуальних ефектів, так і специфікацій поведінки. Продуктивність у режимі реального часу в розподіленому обчислювальному середовищі фактично збільшує складність специфікації та реалізації віртуального світу на основі візуальних об’єктів. Це особливо вірно для традиційних методів проектування для VE, оскільки вони не розділяють конструкцію візуальних об’єктів та їх поведінку, і, крім того, вони мало використовують формалізовані методи як інтегративні підходи до проектування. Проблеми, спричинені неформалізованим проектуванням VE, є значними та включають серед багатьох інших:

- неможливість повторного використання компонентів, 
- труднощі у перевірці поведінки та 
- трудомістке впровадження. 

Таким чином, неформалізоване проектування VE не підходить для проектування великомасштабної та/або складної системи VE, зокрема, коли вона розподілена і працюватиме в режимі реального часу. Замість цього необхідна інтегративна платформа проектування для забезпечення зручності використання, продуктивності, балансування навантаження тощо. Тим часом специфікації вимог також можуть бути проблемою в неформалізованому проектуванні VE. Зауважте, що хоча доступні значні дослідження щодо використання формалізованих методів проектування для проектування VE [34–36], ця робота головним чином зосереджена на проектуванні поведінки візуальних компонентів/об’єктів.

Традиційно проектування системи VE відокремлює дизайн візуальних об’єктів від реалізації їх поведінки. Дизайном візуальних об’єктів безпосередньо керують деякі інструменти візуального моделювання, такі як 3ds Max [37], AC3D [38] тощо. Однак розроблення поведінки та реалізація для візуального об’єкта є значно складнішою, ніж розроблення зовнішнього вигляду візуального об’єкта через складність поведінки візуальних об’єктів та їх взаємодії. Крім того, продуктивність візуальних об’єктів у розподіленому середовищі в реальному часі відносно важко передбачити на етапі проектування, що збільшує необхідність формалізованого підходу до проектування. Дійсно, дослідники досліджували багато формалізованих проектів для досягнення більш ефективного дизайну системи VE. Ці формалізовані підходи до проектування використовують мови специфікації системи, щоб полегшити проектування. Наприклад, для цієї мети використовувалися діаграми переходів станів [34], FlowNet [35], HyNet [36], Тафтса [39], мережі Петрі [29] і діаграми станів [30].

Недоліки цих формальних методів проектування складної системи VE були представлені в розділі 2.3.3 і поступово визнавалися в останні роки. Наприклад, FlowNet використовує графічну нотацію для вказівки поведінки компонентів, і коли зазначена система VE стає великою та складною, отриману «FlowNet» дуже важко зрозуміти та керувати нею. Крім того, не існує відображення специфікації, створеної цими формалізмами, на реалізовані візуальні об’єкти, що ускладнює валідацію та оптимізацію проекту. Як ми обговорювали раніше, основа M&S на основі DEVS є системним підходом на основі моделі, який здатний забезпечити інтегровану платформу для допомоги в проектуванні VE. У наступному параграфі ми обговорюємо практичний приклад використання DEVS як ефективного інструменту для допомоги в проектуванні веб-системи 3D VE. Ми побачимо, як модель проектування системи на основі DEVS може бути легко реалізована в середовищі програмного забезпечення моделювання, і як можна досягти перевірки та оптимізації дизайну шляхом моделювання моделі проектування DEVS.

У недавньому дослідженні [32,33] обговорювався підхід на основі моделі DEVS для допомоги в проектуванні 3D-системи VE, віртуальної лікарні. Ця «віртуальна лікарня» є веб-розподіленим електронним навчанням VE, що передбачає розробку та впровадження багатьох візуальних об’єктів (таких як «пацієнт», «рентгенівський сканер», «сенсорний датчик» тощо) і компонентів системи ( такі як веб-компоненти, база даних, інтерфейс користувача тощо). Візуальні об’єкти в системі визначаються та проектуються за допомогою інструменту X3D, тоді як взаємодія між цими візуальними об’єктами визначається та реалізується за допомогою мови сценаріїв. Перевірка поведінки візуальних об’єктів і оптимізація візуальних об’єктів є двома ключовими аспектами в розробці цієї розподіленої системи VE у реальному часі. Автори використовували DEVS як основний формалізований інструмент для моделювання ключових візуальних об’єктів та їх взаємодії, щоб перевірити специфікацію їх поведінки та знайти оптимальний дизайн. Фактично, перевірка поведінки була проведена шляхом запуску моделі DEVS під заданим EF. Таке використання DEVS дозволяє швидко перевірити поведінку візуальних компонентів на ранньому етапі проектування системи. Таким чином, наприклад, деякі зайві або неефективні візуальні компоненти можна видалити в остаточній реалізації системи без втрати будь-яких необхідних функцій системи.

Як показано на малюнку 2.4, ключові візуальні об’єкти реалізовані в інтегрованій програмній структурі DEVS, яка здатна показувати моделі та їх взаємодію за допомогою формалізму DEVS. Тут поведінка окремих візуальних об’єктів визначається за допомогою формалізму DEVS AM, тоді як взаємодія цих індивідуальних моделей візуальних об’єктів описується специфікаціями моделі, пов’язаної з DEVS, або, точніше, взаємодії моделюються шляхом побудови каналів обміну повідомленнями через індивідуальні вхідні та вихідні дані. порти моделі.

![image-20220819000900568](media/image-20220819000900568.png)

**РИСУНОК 2.4** Представлення DEVSJAVA віртуальної лікарні. (З Boukerche, A. et al., *Concurrency & Computation: Practice & Experience*, 21, 1422, 2009. З дозволу.)

Як зазначалося раніше, кожен компонент моделі DEVS має чітко визначені «стани», порти «подій» введення та виведення, а також те, як модель реагує на внутрішні та зовнішні події. Як приклад, візуальний об’єкт «Touch Sensor» описується як атомарний DEVS наступним чином [24]:

![image-20220819000934036](media/image-20220819000934036.png)

All other individual AMs are described similarly as the above “touch sensor” model. In terms of the behavior validation of each individual visual object, the representing DEVS model is tested under DEVSJAVA with different injected initial states. For instance, the “patient” visual object is modeled as an atomic DEVS “patient” model, and simulating this DEVS model can validate whether the behavior of the “patient” component defined in X3D is correct or not. Through testing and validating all these individual visual object DEVS models, any design error (in terms of visual objects’ behavior) can be discovered and eradicated easily. As a next step, the design inefficiency can also be identified by simulating a modeled subsystem of the virtual hospital. As an example, the authors examined the image animation of the “CT Scanner PC” component by simulating a corresponding DEVS design model (a coupled DEVS model in DEVS representation). 

Усі інші окремі модулі AM описані так само, як наведена вище модель «Touch Sensor». З точки зору перевірки поведінки кожного окремого візуального об’єкта, репрезентуюча модель DEVS тестується за допомогою DEVSJAVA з різними введеними початковими станами. Наприклад, візуальний об’єкт «пацієнт» моделюється як атомарна модель «пацієнта» DEVS, і симуляція цієї моделі DEVS може перевірити, чи є поведінка компонента «пацієнта», визначеного в X3D, правильною чи ні. Завдяки тестуванню та перевірці всіх цих окремих моделей DEVS візуальних об’єктів будь-яку помилку дизайну (щодо поведінки візуальних об’єктів) можна легко виявити та викорінити. Як наступний крок, неефективність проекту також можна виявити шляхом моделювання змодельованої підсистеми віртуальної лікарні. Як приклад, автори дослідили анімацію зображення компонента «CT Scanner PC» шляхом моделювання відповідної моделі проектування DEVS (з’єднана модель DEVS у представленні DEVS).

As shown in Figures 2.5 and 2.6, a sequential operation steps of system components and their driving scripts (X3D Script) were presented, in which “X3D Scripts” take the data from “Scalar Interpolator” to generate the image file used in “PC Screen” (a visual component in the VE system being designed). Through mapping such operations to the DEVS model and then simulating them, it is discovered that the two “X3D Script” can be replaced by a new one as a better design. This is achieved by simulating the representing DEVS models to find a more efficient design alternative. Here, we can see that DEVS works smoothly as a guiding tool for design optimization. It is worth mentioning that DEVS models are easy to build, and simulation of DEVS models can help predict the performance of the designed VE system. Therefore, DEVS can not only be used as a design validation tool but also as a guiding tool for design optimization.

Як показано на малюнках 2.5 і 2.6, були представлені послідовні кроки роботи компонентів системи та їх сценаріїв керування (X3D Script), у яких «X3D Scripts» беруть дані зі «Scalar Interpolator» для створення файлу зображення, що використовується в «PC Screen». ” (візуальний компонент у системі VE, що проектується). Завдяки зіставленню таких операцій із моделлю DEVS, а потім їх моделюванню, було виявлено, що два «X3D Script» можна замінити новим як кращий дизайн. Це досягається моделюванням представлених моделей DEVS для пошуку більш ефективної альтернативи дизайну. Тут ми бачимо, що DEVS безперебійно працює як керівний інструмент для оптимізації дизайну. Варто зазначити, що моделі DEVS легко побудувати, а симуляція моделей DEVS може допомогти передбачити продуктивність розробленої системи VE. Таким чином, DEVS можна використовувати не лише як інструмент перевірки дизайну, але й як керівний інструмент для оптимізації дизайну.

![image-20220819000955964](media/image-20220819000955964.png)

**FIGURE 2.5** Image animation of CT scanner PC in the original X3D design. (From Boukerche, A. et al., *Concurrency & Computation: Practice & Experience*, 21, 1422, 2009. With permission.)

![image-20220819001014735](media/image-20220819001014735.png)

**FIGURE 2.6** Image animation of CT scanner PC in the improved X3D design. (From Boukerche, A. et al., *Concurrency & Computation: Practice & Experience*, 21, 1422, 2009. With permission.) 

### 2.4.2 Допомога при проектуванні та верифікації для розподілених систем реального часу

Indeed, VE-based systems can benefit from DEVS in terms of design validation and optimization. Real-time distributed computer systems, including real-time distributed simulation systems and QoS-aware distributed real-time computing systems, can also take advantage of using DEVS as the fundamental system design aiding tool. Indeed, the capability of precisely defining system components and their interaction makes DEVS a unique approach for effectively designing real-time distributed computer systems.

Дійсно, системи на основі VE можуть отримати вигоду від DEVS з точки зору перевірки дизайну та оптимізації. Розподілені комп’ютерні системи реального часу, включаючи розподілені системи моделювання в реальному часі та розподілені обчислювальні системи реального часу з підтримкою QoS, також можуть скористатися перевагами використання DEVS як основного інструменту допомоги при проектуванні системи. Дійсно, можливість точного визначення компонентів системи та їх взаємодії робить DEVS унікальним підходом для ефективного проектування розподілених комп’ютерних систем реального часу.

Real-time-based formal system specification languages have been widely studied, including UML-RT [27], timed automata [28], and others. For instance, UML-RT is quite suitable for the high-level formal description of a system (software, hardware, and the embedded system level), whereas timed automata can be used to precisely model the components of a system. As an extension of standard DEVS, RT-DEVS opens a wide area of specifying real-time computer systems, including distributed real-time systems and QoS-aware distributed systems. Compared to UML-RT and timed automata, RT-DEVS inherits the basic DEVS methodology and can also provide specification of real-time parameters, which can greatly help the design of a real-time distributed system in a unified platform (for example, the DEVSJAVA software platform).

Мови специфікації формальних систем, що працюють у реальному часі, були широко вивчені, включаючи UML-RT [27], синхронізовані автомати [28] та інші. Наприклад, UML-RT цілком підходить для високорівневого формального опису системи (програмне забезпечення, апаратне забезпечення та рівень вбудованої системи), тоді як автомати з синхронізацією можна використовувати для точного моделювання компонентів системи. Як розширення стандартного DEVS, RT-DEVS відкриває широку область специфікації комп’ютерних систем реального часу, включаючи розподілені системи реального часу та розподілені системи з підтримкою QoS. У порівнянні з UML-RT і часовими автоматами, RT-DEVS успадковує базову методологію DEVS, а також може надавати специфікацію параметрів реального часу, що може значно допомогти в розробці розподіленої системи реального часу в уніфікованій платформі (наприклад, програмна платформа DEVSJAVA).

As a well-known distributed simulation standard, HLA [40] has been widely adopted in the simulation community. Real-time interface (RTI) is the core in a HLA-based distributed simulation system. Therefore, the study of HLA-RTI has been attracting many researchers for a better RTI design. As a matter of fact, a real-time RTI (RT-RTI) system generally requires the participating simulation components to be deterministic, which exactly suits the DEVS formalism-based approach because DEVS and RT-DEVS are ideal for expressing the deterministic model behaviors to satisfy the requirements of designing a RT-RTI system. There exists very limited research that uses DEVS to aid a novel HLA-RTI design. In the following example, we will show how RT-DEVS is used to predict the key system design factors that can affect the overall performance of a RT-RTI system.

Як добре відомий стандарт розподіленого моделювання, HLA [40] був широко прийнятий у спільноті моделювання. Інтерфейс реального часу (RTI) є ядром розподіленої системи моделювання на основі HLA. Таким чином, вивчення HLA-RTI приваблює багатьох дослідників для кращого дизайну RTI. Насправді система реального часу RTI (RT-RTI) зазвичай вимагає, щоб компоненти симуляції, які беруть участь, були детермінованими, що точно відповідає підходу, заснованому на формалізмі DEVS, оскільки DEVS і RT-DEVS ідеально підходять для вираження поведінки детермінованої моделі. щоб задовольнити вимоги проектування системи RT-RTI. Існують дуже обмежені дослідження, які використовують DEVS для розробки нового дизайну HLA-RTI. У наступному прикладі ми покажемо, як RT-DEVS використовується для прогнозування ключових факторів конструкції системи, які можуть вплинути на загальну продуктивність системи RT-RTI.

Other work [41] proposed a novel HLA-RTI design and used DEVS to validate their proposed real-time HLA/RTI [42] system design. RT-DEVS was used to specify the key RTI components, and the key performance parameters were captured by simulating the corresponding DEVS RTI models. As shown in Figure 2.7, the RTI design was realized as a DEVSJAVA simulation model, which represented the proposed new RTI design. The individual AMs were specified by RT-DEVS formalism. The overall real-time HLA/RTI system was modeled basically in three layers: task generation and task director (the “taskGen” and “director” models), HLA/RTI services (the six key HLA/RTI services are modeled as “DDM,” “DM,” “FM,” “OM,” “ObjM,” and “TM,” respectively), and the thread pools (five regular pools and one bigger pool). Thus, the dynamic behaviors of a designed HLA/RTI system can then be simulated by DEVSJAVA simulators.

Інша робота [41] запропонувала нову конструкцію HLA-RTI та використала DEVS для перевірки запропонованої ними конструкції системи HLA/RTI [42] в реальному часі. RT-DEVS використовувався для визначення ключових компонентів RTI, а ключові параметри продуктивності були отримані шляхом моделювання відповідних моделей DEVS RTI. Як показано на малюнку 2.7, проект RTI був реалізований як імітаційна модель DEVSJAVA, яка представляла запропонований новий дизайн RTI. Окремі AM були визначені формалізмом RT-DEVS. Загальна система HLA/RTI в реальному часі була змодельована в основному на трьох рівнях: генерація завдань і директор завдань (моделі «taskGen» і «director»), сервіси HLA/RTI (шість ключових сервісів HLA/RTI моделюються як «DDM»). ”, “DM”, “FM,” “OM,” “ObjM” і “TM” відповідно) і пули потоків (п’ять звичайних пулів і один більший пул). Таким чином, динамічна поведінка спроектованої системи HLA/RTI може бути змодельована симуляторами DEVSJAVA.

![image-20220819001118094](media/image-20220819001118094.png)

**FIGURE 2.7** Real-time interface (RTI) design models in DEVSJAVA. (From Boukerche, A. et al., *Simulation*, 84, 231, 2008. With permission.)

For instance, the “service queue” AM is described with RT-DEVS as [41]

Наприклад, «сервісна черга» AM описується за допомогою RT-DEVS як [41]

![image-20220819001201257](media/image-20220819001201257.png)

As shown in the above RT-DEVS formalism, each model component (AM) has strictly defined “states,” input and output “events,” as well as how the model responds to internal and external events (transition functions). Different from standard DEVS, the real-time activity of the model is also defined using an activity set and an activity mapping function. Therefore, the overall system behaviors can be modeled and simulated in an integrated framework. Given that the key aspect of RT-RTI is its real-time performance (or, say, “task satisfactory rate”), the performance of a proposed novel RT-RTI core system must be evaluated and validated. In this research, the authors effectively used RT-DEVS as the design validation tool.

Як показано у наведеному вище формалізмі RT-DEVS, кожен компонент моделі (AM) має строго визначені «стани», вхідні та вихідні «події», а також те, як модель реагує на внутрішні та зовнішні події (функції переходу). На відміну від стандартного DEVS, активність моделі в реальному часі також визначається за допомогою набору активності та функції відображення діяльності. Таким чином, загальну поведінку системи можна моделювати та імітувати в інтегрованій структурі. З огляду на те, що ключовим аспектом RT-RTI є його продуктивність у реальному часі (або, скажімо, «рівень задовільного виконання завдання»), продуктивність запропонованої нової основної системи RT-RTI повинна бути оцінена та підтверджена. У цьому дослідженні автори ефективно використовували RT-DEVS як інструмент перевірки дизайну.

Figure 2.8 shows simulation on the DEVSJAVA platform of both the RT-DEVS models of the original RT-RTI and proposed novel RT-RTI designs. Indeed, the DEVSJAVA models in Figure 2.7 captured the key RT-RTI components and their real-time interactions so that the key performance parameters can be obtained. Consequently, the simulation results can be compared to the experimental results obtained from the executions in a physical RT-RTI environment. In particular, the key concern here is how dynamic thread pool management in the new RT-RTI design can benefit the performance of the overall RT-RTI system in terms of the tasks that are served to meet their deadlines. The experimental results, obtained from both the real RT-RTI execution and the DEVS model simulation, validated that the proposed novel RT-RTI design outperformed the original RTI system in terms of providing a better task serving rate in a real-time distributed simulation scenario. The DEVS simulation result, shown in Figure 2.8, provides a solid and consistent result that supports the proposed new RT-RTI design. In this example, we saw that the DEVS component-based design approach is able to discover, predict, and validate the key design concerns for a real-time distributed simulation system.

На рисунку 2.8 показано моделювання на платформі DEVSJAVA як моделей RT-DEVS оригінального RT-RTI, так і запропонованих нових дизайнів RT-RTI. Дійсно, моделі DEVSJAVA на рисунку 2.7 зафіксували ключові компоненти RT-RTI та їх взаємодію в реальному часі, щоб можна було отримати ключові параметри продуктивності. Отже, результати моделювання можна порівняти з експериментальними результатами, отриманими від виконання у фізичному середовищі RT-RTI. Зокрема, ключове занепокоєння полягає в тому, як динамічне керування пулом потоків у новому дизайні RT-RTI може принести користь продуктивності всієї системи RT-RTI з точки зору завдань, які обслуговуються з дотриманням їх кінцевих термінів. Експериментальні результати, отримані в результаті реального виконання RT-RTI та симуляції моделі DEVS, підтвердили, що запропонована нова конструкція RT-RTI перевершує оригінальну систему RTI з точки зору забезпечення кращої швидкості обслуговування завдань у сценарії розподіленого моделювання в реальному часі. . Результат моделювання DEVS, показаний на малюнку 2.8, забезпечує надійний і послідовний результат, який підтримує запропонований новий дизайн RT-RTI. У цьому прикладі ми побачили, що підхід до проектування на основі компонентів DEVS здатний виявити, передбачити та підтвердити ключові проблеми дизайну розподіленої системи моделювання в реальному часі.

![image-20220819001222641](media/image-20220819001222641.png)

**FIGURE 2.8** Discrete Event System Specification (DEVS) simulation result for real-time interface (RTI) design. (From Boukerche, A. et al., *Simulation*, 84, 231, 2008. With permission.)

In other work [43], RT-DEVS has been used to validate a design of a QoS-aware distributed real-time system. The design of such systems is a new area to explore with DEVS and the research created and implemented DEVS design models for both a tree-based (hierarchical) and a flat service management systems. These DEVS design models were then simulated in a real-time fashion, and the DEVS simulation results conform very well with the experimental results obtained in an actual P2P-based distributed cluster environment. Meanwhile, the “states” and “state transitions” of each component in the designed system were also validated by using a DEVS-based unit test method. It is worth mentioning that a QoS-aware system has many time-sensitive real-time parameters that must be considered during the design process, but how these parameters affect the overall real-time performance of the final designed system is generally very difficult to evaluate or predict. DEVS and RT-DEVS indeed provide a powerful system tool to facilitate the evaluation of such complex design processes in a quick and accurate way.

В іншій роботі [43] RT-DEVS використовувався для перевірки дизайну розподіленої системи реального часу з підтримкою QoS. Проектування таких систем є новою сферою для дослідження з DEVS, а дослідження створили та впровадили моделі проектування DEVS як для деревоподібних (ієрархічних), так і для плоских систем керування послугами. Потім ці моделі проектування DEVS були змодельовані в режимі реального часу, і результати моделювання DEVS дуже добре узгоджуються з експериментальними результатами, отриманими в реальному середовищі розподіленого кластера на основі P2P. Водночас «стани» та «переходи між станами» кожного компонента розробленої системи також перевірялися за допомогою методу модульного тестування на основі DEVS. Варто зазначити, що система з підтримкою QoS має багато чутливих до часу параметрів реального часу, які необхідно враховувати під час процесу проектування, але як ці параметри впливають на загальну продуктивність остаточно розробленої системи в реальному часі, як правило, дуже важко оцінити або передбачити. DEVS і RT-DEVS справді забезпечують потужний системний інструмент для полегшення оцінки таких складних процесів проектування швидким і точним способом.

Another example demonstrates how RT-DEVS was used as a formalization technique toward aiding the algorithm design and validation of a P2P-based distributed system. In particular, a novel load-balancing algorithm in a P2P-based network was designed in which both dynamic QoS and service migration play key roles in terms of affecting the overall system performance [44]. The proposed load-balancing algorithm was based on a genetic algorithm [45], and the design of this algorithm was validated by a DEVS-based formal approach. The algorithm was modeled in a DEVSJAVA environment, which represents the key components and the behaviors of the algorithm in detail. Thus, the proposed algorithm can be simulated in terms of how it satisfies the user requirement in a dynamic distributed service-oriented system. The concept of DEVS “variable structure” was used to fulfill the requirement of modeling the variations of components in a dynamic system, which is actually one of the most important features for analyzing a service migration scheme in the proposed algorithm design.

Інший приклад демонструє, як RT-DEVS використовувався як метод формалізації для допомоги в розробці алгоритму та перевірці розподіленої системи на основі P2P. Зокрема, був розроблений новий алгоритм балансування навантаження в мережі на основі P2P, в якому і динамічний QoS, і міграція послуг відіграють ключові ролі з точки зору впливу на загальну продуктивність системи [44]. Запропонований алгоритм балансування навантаження базувався на генетичному алгоритмі [45], і дизайн цього алгоритму був підтверджений формальним підходом на основі DEVS. Алгоритм було змодельовано в середовищі DEVSJAVA, яке детально представляє ключові компоненти та поведінку алгоритму. Таким чином, запропонований алгоритм може бути змодельований з точки зору того, як він задовольняє вимоги користувача в динамічній розподіленій сервіс-орієнтованій системі. Концепція «змінної структури» DEVS була використана для виконання вимоги моделювання варіацій компонентів у динамічній системі, що фактично є однією з найважливіших характеристик для аналізу схеми міграції сервісу в запропонованому дизайні алгоритму.

The DEVSJAVA integrated environment provides the capability of visualizing the hierarchical system structure, which helps build the design models quickly. In terms of experimental evaluations, the proposed load-balancing algorithm (based on a genetic algorithm) was compared with two other systems: one only using task scheduling and one using no load-balancing algorithm. The proposed algorithm used a load-balancing manager that has dynamic QoS parameters implemented, and these parameters can be updated using a genetic algorithm. The three experimental distributed systems were also modeled in DEVSJAVA as shown in Figure 2.9, in which the computing services on hosted machines were modeled as “service nodes” and the multiple threads on one service were modeled as “node-i-thread-i” models. There is also a “task generation” model to generate tasks to the modeled system as well as a “MigrationManager” for task migrations. Two sets of experimental scenarios were created. In the first scenario, tasks were fed to the system using a fixed interval of 100 ms, whereas in the second scenario, the tasks were sent to the system using a different feeding rate so that the adaptability of the system could be evaluated. For both scenarios, experiments were conducted in both a practical P2P network and the DEVS model-based EF. As shown in Figures 2.10 and 2.11, the results obtained from DEVS models conforms well with the results captured in the practical P2P network. We can see that the DEVS simulations predicted higher task success rates when compared to the experiments in practice (conducted in real P2P-enabled computer networks) in both scenarios. This is because of the different experimental settings, and the key concern here is to validate the differences in the algorithms, not to exactly predict the performance of the algorithms in practice. Indeed, the experimental results imply that DEVS can provide accurate prediction of the performance of complex load-balancing algorithms for dynamic P2P-based distributed real-time systems. In the case where practical experiments are difficult to capture, DEVS and RT-DEVS can still provide effective prediction of the system performance using easy-to-build simulation-based models.

Інтегроване середовище DEVSJAVA забезпечує можливість візуалізації ієрархічної структури системи, що допомагає швидко будувати моделі проектування. З точки зору експериментальних оцінок, запропонований алгоритм балансування навантаження (на основі генетичного алгоритму) порівнювався з двома іншими системами: одна використовує лише планування завдань, а друга використовує алгоритм балансування навантаження. Запропонований алгоритм використовує диспетчер балансування навантаження, який має реалізовані динамічні параметри QoS, і ці параметри можна оновлювати за допомогою генетичного алгоритму. Три експериментальні розподілені системи також були змодельовані в DEVSJAVA, як показано на малюнку 2.9, в якому обчислювальні служби на розміщених машинах були змодельовані як «сервісні вузли», а численні потоки в одній службі були змодельовані як «вузол-i-потік-i» моделі. Існує також модель «генерування завдань» для створення завдань для змодельованої системи, а також «Менеджер міграції» для міграції завдань. Було створено два набори експериментальних сценаріїв. У першому сценарії завдання надсилалися в систему з використанням фіксованого інтервалу в 100 мс, тоді як у другому сценарії завдання надсилалися в систему з використанням іншої швидкості подачі, щоб можна було оцінити адаптивність системи. Для обох сценаріїв експерименти проводилися як у практичній мережі P2P, так і в EF на основі моделі DEVS. Як показано на малюнках 2.10 і 2.11, результати, отримані з моделей DEVS, добре узгоджуються з результатами, отриманими в практичній мережі P2P. Ми бачимо, що моделювання DEVS передбачало вищі показники успішності виконання завдань порівняно з експериментами на практиці (проведеними в реальних комп’ютерних мережах з підтримкою P2P) в обох сценаріях. Це пов’язано з різними експериментальними налаштуваннями, і ключовою проблемою тут є перевірка відмінностей в алгоритмах, а не точне прогнозування ефективності алгоритмів на практиці. Дійсно, експериментальні результати означають, що DEVS може забезпечити точне передбачення продуктивності складних алгоритмів балансування навантаження для динамічних розподілених систем реального часу на основі P2P. У випадку, коли практичні експерименти важко охопити, DEVS і RT-DEVS можуть забезпечити ефективне прогнозування продуктивності системи за допомогою простих у створенні моделей на основі моделювання.

![image-20220819001259981](media/image-20220819001259981.png)   

**FIGURE 2.9** System design view in DEVSJAVA. (From Xie, H. et al., *Concurrency & Computation: Practice & Experience*. Vol. 22, P1223–1239, 2010. With permission.)

![image-20220819001326488](media/image-20220819001326488.png)

**FIGURE** **2.10** Simulation result obtained for the first scenario (a) in a real-world experiment; (b) in a Discrete Event System Specification (DEVS) simulation. (From Xie, H. et al., *Concurrency* *& Computation: Practice & Experience*. Vol. 22, P1223–1239, 2010. With permission.)

 ![image-20220819001440020](media/image-20220819001440020.png)

**FIGURE** **2.11** Simulation result obtained for the second scenario (a) in a real-world experiment; (b) in a Discrete Event System Specification (DEVS) simulation. (From Xie, H. et al., *Concurrency* *& Computation: Practice & Experience*. Vol. 22, P1223–1239, 2010. With permission.)

### 2.4.3 Підхід DEVS до проектування розподілених кооперативних робототехнічних систем реального часу

In the previous discussion, we demonstrated some examples that use DEVS as a formal design validation tool to assist the design of complex real-time distributed systems. In this section, we will demonstrate how the DEVS formal approach can provide an integrative M&S environment to aid the design of distributed real-time cooperative robotic systems. In this subsection, we show how a physical robot can interact with a DEVS-based robot model in a simulation-based VE [46,47].

The DEVS approach presented in this section is based on an architecture proposed and implemented by one of the authors (Hu), which employs the following four steps for the design and testing of a cooperative robotic system [46]:

1.   Centralized simulation to analyze the system under test within a model of the environment linked by abstract sensor/actuator interfaces on a single computer.

2.    Distributed simulation, in which models are deployed to the real network that the system will be executed on and simulated by distributed real-time simulators.

3.    Hardware-in-the-loop simulation, in which the environment model is simulated by a DEVS real-time simulator on one computer, whereas the control model under test is executed by a DEVS real-time execution engine on the real hardware.

4.    Deployed execution, in which a real-time execution engine executes the control model that interacts with the physical environment through the earlier sensor/actuator interfaces that have been appropriately instantiated.

As the technology of robotic systems advances rapidly, systematic development methods and integrative development environments play increasingly important roles in handling the complexity of these systems. Compared to the conventional approach, the system architecture of Hu and Zeigler [46] supports robot-in-the-loop type of simulation, which can effectively overcome the difficulties of traditional approaches when the experimental environment confines the use of physical robots. One of the key ideas of this approach is to constitute an incremental study and measurement process for cooperative robotic systems combined with a simulation-based VE to support systematic analysis and measurement of large-scale cooperative robotic systems. Another highlight in this approach lies in the support of dynamic system reconfiguration in a real-time simulation of cooperative robotic systems. To enable this feature, “variable structure” DEVS [48] is used. This capability indeed makes dealing with the evolving cooperative robotic systems much easier. The concept of “experimental frame” is explored to form an integrative environment for studying the behaviors of large-scale cooperative robotic systems. In other words, the system architecture can be treated with a hybrid approach that allows real robots as well as virtual ones to be studied together in a simulation-based VE. This simulation-based VE was originally developed in the context of mobile robot applications; however, it can also be applied to other robotic applications such as object transportation and material handling. In the sequel, we demonstrate how physical robots can interact with the VE to form a cooperative real-time robotic system.

In general, robotic systems can be viewed as a particular form of real-time systems that monitor and respond to, or control, an external environment. This environment is connected to the computer system through sensors, actuators, and other input–output interfaces [6]. A robotic system from this point of view consists of sensors, actuators, and the decision-making unit. Thus, a cooperative robotic system is composed of a collection of robots that communicate with one another and interact with an environment. This view of robotic systems suggests a basic architecture for the simulation-based VE that we developed: an environment model and a collection of robot models, which include decision-making models, sensors, and actuators. The environment model represents the physical environment within which a robotic system will be operated. It forms a VE for the robots and may include virtual obstacles, virtual robots, or any other entities that are useful for simulation-based study. The robot model represents the control software that governs the decision making and communication of a robot. It also includes sensor and actuator interfaces to support interactions between the robot and its environment. In the approach by Hu, the “model continuity” methodology is used, which clearly separates the decisionmaking unit of a robot (which is modeled as a DEVS atomic or coupled model) from the sensors and actuators (which are modeled as DEVS abstractActivities). The decision-making model defines the control logic while the sensor/actuator abstractActivities represent the sensors or actuators, including their behaviors, interfaces, and properties of uncertainty and inaccuracy. DEVS-based model couplings are added between sensor/actuator abstractActivities and the environment model; therefore, messages can be passed between the decision-making model and the environment model through sensor/actuator abstractActivities. It is worth noting that such separation between the decision-making model of a robot and its sensor/actuator interfaces can bring several advantages: First, it separates the decision making of a robot from hardware interaction. This makes it easier for the designer to focus on the decision-making model, which is the main design interest. Second, the existence of a sensor/actuator interface layer makes it possible for the decision-making model to interact with different types of sensors/actuators as long as the interface functions between them remain the same. Thus depending on different experimental and study objectives, a decision-making model can be equipped with different types of sensors and actuators. As a matter of fact, in this cooperative robotic system, models of sensors/actuators (modeled as abstractActivities, also referred to as virtual sensors/actuators hereafter) are developed to simulate the behavior of physical sensors/actuators. Meanwhile, physical sensor/actuator interfaces (implemented as RTActivities) are developed to drive the physical sensor/ actuators of a robot. A virtual sensor/actuator and its corresponding physical sensor/actuator interface share the same interface functions with the decision-making model. During simulation, a decision-making model uses virtual sensors/actuators to interact with a VE; during operation, the same decision-making model, which resides on a real robot, uses physical sensor/actuator interfaces to interact with a physical environment.

![image-20220819001601161](media/image-20220819001601161.png)

**FIGURE 2.12** Robot-in-the-loop simulation. (From Hu, X., and Zeigler B. P., *Integrated Computer-Aided Engineering*, 12, 353, 2005. With permission.)

Figure 2.12 shows an example of the aforementioned cooperative robotic system, in which one physical mobile robot operates in a VE. In this example, the mobile robot uses its virtual sensors to get sensory input from the VE and uses its real motor interface to move the robot. As a result, the physical robot moves in a physical space based on the sensory input from a VE. Within this VE, the robot “sees” virtual obstacles that are simulated by computers and makes decisions based on those inputs. Meanwhile, virtual robots (robot models) can also be added into the environment so the physical robot can sense them and communicate/coordinate with them. This capability of robot-in-the-loop simulation brings simulation-based study one step closer to the physical world. Furthermore, for large-scale cooperative robotic systems that include hundreds of robots, it makes it possible to conduct system-wide tests and measurements without waiting for all physical robots to be available. In this latter case, the robots not yet physically available can be provided by the simulation- based VE.

[Figure 2.13](#_bookmark7) illustrates how EFs, models/systems, and simulation methods can play together to carry out simulation-based measurement. This process includes three lines of development and integration: the “models/system” that will be tested and measured, the “EFs” that specify the measurement, and the “methods” that are employed to carry out the measurement. The process starts from the system specification that is formulated as DEVS-expressible formalisms. The system specification is further divided into two specifications: the design specification that guides the development of models/system and the measurement specification that guides the development of EFs. Three methods, corresponding to three stages of study, are used to carry out the measurement incrementally. These methods are conventional simulation, VE-based simulation, and real-time execution. Similarly, three types of EFs exist: EF for model-world study, EF for virtual-world study, and EF for physical- world study. Techniques are under development to derive EF development from the measurement specification in automated or semiautomated ways.

As a summary, the simulation-based VE supports a powerful hybrid approach that allows physical robots as well as virtual ones to be studied together. As the technology of robotic systems advances rapidly, systematic development methods and integrative development environments play an increasingly important role in handling the complexity of these systems. We can clearly see that DEVS is key to making it possible to build such a hybrid simulation framework, which can then aid the design of cooperation robotic systems more easily and effectively.

![image-20220819001630585](media/image-20220819001630585.png)

**FIGURE 2.13** Experimental frames (EFs), models, and study methods. (From Hu, X., and Zeigler B. P., *Integrated Computer-Aided Engineering*, 12, 353, 2005. With permission.)

[2.3 <--- ](2_3.md) [   Зміст   ](README.md) [--> 2.5](2_5.md)