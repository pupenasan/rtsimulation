[16 <--- ](16.md) [   Зміст   ](README.md) [--> 16.2](16_2.md)

## 16.1. INTRODUCTION

The path to fast and accurate computer simulation depends on the objective one pursues. In the case of offline applications, the goal is typically to simulate a highly complex system to study its behavior in detail and to ascertain its performance. An example might involve the design of an expensive large-scale system to be built, in which case it is essential to use simulation for the purpose of exploring whether it meets performance specifications and cost constraints under alternative designs and control mechanisms. In such a realm, reasonably fast simulation time is desirable but not indispensable, and one may be more likely to trade off execution speed for higher fidelity. On the contrary, for online applications, we often refer to real-time simulation as a tool for generating efficient models providing predictive capability while an actual system is operating as well as the means to explore alternatives that may be implemented in real time. An example might arise when a system is about to operate in an environment it was never originally designed for; one is then interested in simulating how the system would behave in such an environment, possibly under various implementable alternatives (e.g., adding resources to it or modifying the parametric settings of a controller). On the basis of the results, one might proceed in the new setting, abort, or choose the best possible modification before proceeding. In such cases, obtaining information fast from simulation is not just desirable, but an absolute requirement.

Шлях до швидкого та точного комп’ютерного моделювання залежить від мети, яку переслідує. У випадку офлайн-додатків метою зазвичай є моделювання дуже складної системи, щоб детально вивчити її поведінку та визначити її продуктивність. Прикладом може бути розробка дорогої великомасштабної системи, яка має бути побудована, і в цьому випадку важливо використовувати моделювання з метою дослідження того, чи відповідає вона специфікаціям продуктивності та обмеженням вартості за альтернативних проектів і механізмів контролю. У такій сфері досить швидкий час моделювання є бажаним, але не обов’язковим, і, швидше за все, можна поміняти швидкість виконання на більшу точність. Навпаки, для онлайн-додатків ми часто називаємо симуляцію в реальному часі як інструмент для генерації ефективних моделей, які забезпечують можливість прогнозування під час роботи фактичної системи, а також засоби для дослідження альтернатив, які можуть бути реалізовані в режимі реального часу. Приклад може виникнути, коли система збирається працювати в середовищі, для якого вона спочатку не була розроблена; потім цікавиться моделюванням того, як система поводилася б у такому середовищі, можливо, за різних реалізованих альтернатив (наприклад, додавання до неї ресурсів або зміна параметричних налаштувань контролера). На основі результатів можна продовжити в новому налаштуванні, перервати або вибрати найкращу можливу модифікацію, перш ніж продовжити. У таких випадках швидке отримання інформації з моделювання є не просто бажаним, а абсолютною вимогою.

Speeding up the process of information extraction from simulation may be attained in various ways. First, one can use abstraction to replace a detailed model by a less detailed one that is still sufficiently accurate to provide useful information in a real-time frame for making decisions such as choosing between two or more alternatives to be implemented. Another approach is to use multiple processors operating in parallel. This is usually referred to as distributed simulation, where different parts of the entire simulation code are assigned to different processors. By operating in parallel, N such processors have the potential of reducing the time to complete a simulation run by a factor of N. However, this is rarely feasible since the execution must be synchronized. Thus, one slow processor may delay the rest either because its output is necessary for them to continue execution or because of inefficiencies in the way the code was distributed. Nonetheless, this approach enables interoperability as well as allowing for geographic distribution of processors and some degree of fault tolerance.1,2

Прискорення процесу вилучення інформації з моделювання може бути досягнуто різними способами. По-перше, можна використовувати абстракцію, щоб замінити детальну модель на менш детальну, яка все ще є достатньо точною, щоб надати корисну інформацію в режимі реального часу для прийняття рішень, таких як вибір між двома або більше альтернативами, які потрібно реалізувати. Інший підхід полягає у використанні кількох процесорів, що працюють паралельно. Це зазвичай називають розподіленим моделюванням, де різні частини всього коду моделювання призначаються різним процесорам. Завдяки паралельній роботі N таких процесорів можна скоротити час для завершення моделювання в N разів. Однак це рідко можливо, оскільки виконання має бути синхронізованим. Таким чином, один повільний процесор може затримати решту або через те, що його вихід необхідний для продовження виконання, або через неефективність у способі розповсюдження коду. Тим не менш, цей підхід забезпечує взаємодію, а також географічний розподіл процесорів і певний ступінь відмовостійкості.1,2

The goal of concurrent simulation is to provide, at the completion of a single run, information that would normally require M separate simulation runs and to do so with minimal overhead. Thus, suppose that the goal of a real-time simulation application is to determine how a given performance measure J(θ) varies as a function of some parameter θ in the absence of any analytical expression for J(θ). This requires the generation of a simulation run at least once for every value of θ of interest. It is easy to see how demanding this process becomes: if θ represents options from a discrete set {θ1, … , θM}, we need M simulation runs under each of θ1, … , θM. It is even more demanding when the system is stochastic, requiring a large number of simulation runs under a fixed θi to achieve desired levels of statistical accuracy. Concurrent simulation techniques are designed to accomplish the task of providing estimates of all J(θ1), … , J(θM) at the end of a single simulation run instead of M runs. Moreover, if a simulation run under some θi requires T time units, then instead of M · T total simulation time, a concurrent simulation algorithm is intended to deliver all M estimates in T + τM time units where often τM < T and certainly T + τM << M · T. In general, θ = [θ1, … , θN] is a vector of parameters, in which case concurrent simulation is applied to each element θi over all M i values of θi that are of interest. Thus, at the end of a single simulation run, we obtain estimates of J(qi ),… , J(qi i ) for all i = 1,… , N at the same time. To keep notation manageable, however, in most of the discussion that follows we consider a scalar θ.

Мета паралельного моделювання полягає в тому, щоб після завершення одного прогону надати інформацію, яка зазвичай вимагала б M окремих прогонів моделювання, і зробити це з мінімальними витратами. Таким чином, припустимо, що мета програми моделювання в реальному часі полягає в тому, щоб визначити, як певний показник продуктивності J(θ) змінюється як функція деякого параметра θ за відсутності будь-якого аналітичного виразу для J(θ). Це вимагає генерації запуску моделювання принаймні один раз для кожного значення θ, яке цікавить. Легко побачити, наскільки вимогливим стає цей процес: якщо θ представляє опції з дискретного набору {θ1, …, θM}, нам потрібно M прогонів моделювання під кожним із θ1, …, θM. Це ще більш вимогливо, коли система є стохастичною, вимагаючи великої кількості прогонів моделювання при фіксованому θi для досягнення бажаних рівнів статистичної точності. Методи паралельного моделювання призначені для виконання завдання надання оцінок усіх J(θ1), …, J(θM) наприкінці одного циклу моделювання замість M циклів. Крім того, якщо моделювання, яке виконується під деяким θi, вимагає T одиниць часу, тоді замість M · T загального часу моделювання, паралельний алгоритм моделювання призначений для надання всіх M оцінок у T + τM одиниць часу, де часто τM < T і, звичайно, T + τM << M · T. Загалом θ = [θ1, … , θN] є вектором параметрів, у цьому випадку одночасне моделювання застосовується до кожного елемента θi над усіма M i значеннями θi, які представляють інтерес. Таким чином, наприкінці одного циклу моделювання ми отримуємо оцінки J(qi ),… , J(qi i ) для всіх i = 1,… , N одночасно. Однак, щоб зберегти позначення керованими, у більшій частині наступного обговорення ми розглядаємо скаляр θ.

It is important to emphasize the difference between distributed and concurrent simulation. In distributed simulation, the code for a single simulation run is shared over M processors. Thus, at the end of the run, a single set of input–output data (equivalently, one estimate of the relationship J(θ)) is obtained. In concurrent simulation, a single processor simulates a system but also concurrently simulates it under M − 1 additional settings. Thus, at the end of the run, we obtain a total of M input–output data (equivalently, estimates of J(θ1), … , J(θM)). If, in addition, M processors are available for concurrent simulation, then the speedup resulting from the concurrent construction is further increased by naturally assigning a processor to each of the M threads estimating J(θi) for each i = 1, … , M. The speedup benefit in concurrent simulation comes not from the presence of extra processing capacity (which also implies a higher cost) but from the efficient sharing of input data over multiple simulations of the same system under different settings. Another way of interpreting it is as a method that addresses the question “What if a given system operating under a nominal value θ1 were to operate under θ2, … , θM with the same input conditions?” The answer to these M − 1 “what if” questions can be obtained without having to reproduce M − 1 distinct simulations by “brute force”; instead, it can be deduced by processing data from the nominal simulation so as to track the differences caused by replacing θ1 by θi, i = 2, … , M. In Monte Carlo simulation for instance, the computational cost of generating random variates from several distributions is much higher than the cost of performing this difference tracking and constructing state trajectories under multiple settings captured by θ1, … , θM.

Важливо підкреслити різницю між розподіленим і одночасним моделюванням. У розподіленому моделюванні код для одного запуску моделювання використовується M процесорами. Таким чином, наприкінці циклу виходить єдиний набір вхідних і вихідних даних (еквівалентно, одна оцінка відношення J(θ)). При одночасному моделюванні один процесор моделює систему, але також одночасно моделює її за M − 1 додаткових параметрів. Таким чином, наприкінці циклу ми отримуємо загальну кількість M вхідних–вихідних даних (еквівалентно, оцінки J(θ1), …, J(θM)). Якщо, крім того, M процесорів доступні для паралельного моделювання, тоді прискорення, що є результатом паралельної конструкції, додатково збільшується шляхом природного призначення процесора кожному з M потоків, оцінюючи J(θi) для кожного i = 1, …, M. Перевага прискорення в одночасному моделюванні походить не від наявності додаткової потужності обробки (що також передбачає вищу вартість), а від ефективного обміну вхідними даними під час кількох моделювань тієї самої системи за різних налаштувань. Інший спосіб його інтерпретації — як метод, який відповідає на питання «Що, якби дана система, що працює при номінальному значенні θ1, працювала б при θ2, …, θM з тими самими вхідними умовами?» Відповідь на ці M − 1 запитань «що, якби» можна отримати без необхідності відтворювати M − 1 різних симуляцій за допомогою «грубої сили»; замість цього його можна вивести шляхом обробки даних із номінального моделювання, щоб відстежити відмінності, спричинені заміною θ1 на θi, i = 2, …, M. Наприклад, у моделюванні Монте-Карло обчислювальна вартість генерування випадкових варіюється від кількох розподілів є набагато вищим, ніж вартість виконання цього відстеження різниці та побудови траєкторій станів за кількох налаштувань, які фіксуються θ1, …, θM.

In this chapter, we will first review the formalism and theoretical foundations of concurrent simulation as it applies to the class of discrete event systems (DES), also developed in the works by Cassandras and Lafortune3 and Cassandras and Panayiotou.4 The state space of a typical DES involves at least some discrete components, giving rise to piecewise constant state trajectories. This can be exploited to predict changes in an observed state trajectory under some setting θi when the system operates under θj ≠ θi. Formally, this is studied as a general sample path constructability problem. In particular, given a DES sample path under a parameter value θ, the problem is to construct multiple sample paths of the system under different values using only information available along the given sample path. A solution to this problem can be obtained when the system under consideration satisfies a constructability condition. Unfortunately, this condition is not easily satisfied. However, it is possible to enforce it at some expense. For a large class of DES modeled as Markov chains, there are two techniques known as the Standard Clock (SC) method and the Augmented System Analysis (ASA), which provide solutions to the constructability problem. In a more general setting (where one cannot impose any assumptions on the stochastic characteristics of the event processes), we will describe the process through which the problem is solved by coupling an observed sample path to multiple concurrently generated sample paths under different settings. This ultimately leads to a detailed procedure known as the Time Warping Algorithm (TWA). At this point, it is worth emphasizing that concurrent sample path constructability techniques can be used in two different modes. First, they can be used offline to obtain estimates of the system performance under different parameters θ1, … , θM from a single simulation run under θ0. A main objective in this case is to reduce the overall simulation time to achieve high speedup. This approach was investigated in the work by Cassandras and Panayiotou.4 The emphasis of this chapter is on the online use of sample path constructability techniques where the nominal sample path θ0 is simply the one observed during the operation of the actual system. In this case, based on the observed data, the goal is to estimate the system’s performance again under a set of hypothetical parameter values θ1, … , θM. In this case, a controller can monitor the performance of the system under the different parameters J(θ0), … , J(θM), and at the end of each epoch, it can switch to the parameter that achieves the best performance. In this setting, another important advantage of concurrent sample path constructability techniques is that they use common random numbers (CRN), and as a result, the probability of selecting the parameter that optimizes the performance J(θ) is increased. Another important advantage of the online use of concurrent sample path constructability techniques is that it does not require any prior knowledge of the underlying distributions of the various events since those are already embedded in the occurrence times of the observed events. This makes the approach applicable even when the distributions are time varying.

У цьому розділі ми спочатку розглянемо формалізм і теоретичні основи паралельного моделювання, які застосовуються до класу систем дискретних подій (DES), також розробленого в роботах Кассандраса і Лафортюна3 і Кассандраса і Панайоту.4 Простір станів типовий DES включає принаймні деякі дискретні компоненти, що породжує кусково-постійні траєкторії стану. Це можна використати для прогнозування змін у спостережуваній траєкторії стану за певного параметра θi, коли система працює за θj ≠ θi. Формально це вивчається як загальна проблема конструктивності шляху зразка. Зокрема, враховуючи шлях вибірки DES із значенням параметра θ, проблема полягає в тому, щоб побудувати кілька шляхів вибірки системи під різними значеннями, використовуючи лише інформацію, доступну вздовж даного шляху вибірки. Розв'язок цієї задачі можна отримати, коли система, що розглядається, задовольняє умову конструктивності. На жаль, ця умова нелегко задовольнити. Однак його можна забезпечити за певні витрати. Для великого класу DES, змодельованих як ланцюги Маркова, існують дві методики, відомі як метод стандартного годинника (SC) і розширеного системного аналізу (ASA), які забезпечують вирішення проблеми конструктивності. У більш загальних умовах (де неможливо накласти жодних припущень щодо стохастичних характеристик процесів подій) ми опишемо процес, за допомогою якого вирішується проблема шляхом поєднання спостережуваного шляху вибірки з декількома одночасно створеними шляхами вибірки за різних налаштувань. Зрештою це призводить до детальної процедури, відомої як алгоритм викривлення часу (TWA). На цьому етапі варто підкреслити, що паралельні методи конструювання шляху вибірки можна використовувати в двох різних режимах. По-перше, їх можна використовувати в автономному режимі для отримання оцінок продуктивності системи при різних параметрах θ1, …, θM з одного запуску моделювання під θ0. Основною метою в цьому випадку є скорочення загального часу моделювання для досягнення високого прискорення. Цей підхід було досліджено в роботі Кассандраса та Панайоту.4 Акцент у цій главі робиться на онлайн-використанні методів конструювання шляху вибірки, де номінальний шлях θ0 вибірки є просто тим, що спостерігається під час роботи фактичної системи. У цьому випадку, на основі спостережених даних, мета полягає в тому, щоб знову оцінити продуктивність системи за набором гіпотетичних значень параметрів θ1, …, θM. У цьому випадку контролер може контролювати продуктивність системи за різними параметрами J(θ0), …, J(θM), і в кінці кожної епохи він може перемикатися на параметр, який забезпечує найкращу продуктивність. У цьому налаштуванні ще одна важлива перевага методів конструювання шляху паралельних вибірок полягає в тому, що вони використовують загальні випадкові числа (CRN), і, як наслідок, підвищується ймовірність вибору параметра, який оптимізує продуктивність J(θ). Ще одна важлива перевага онлайн-використання методів конструювання паралельних шляхів вибірки полягає в тому, що воно не вимагає жодних попередніх знань про основні розподіли різних подій, оскільки вони вже вбудовані в часи появи спостережуваних подій. Це робить підхід застосовним навіть тоді, коли розподіли змінюються в часі.

We begin the chapter by reviewing the Stochastic Timed Automaton (STA) modeling framework for DES in Section 16.2. This is the framework used by most commercial discrete event simulators, thus facilitating the implementation of the concurrent simulation techniques to be described. In Section 16.3, we define the general sample path constructability problem. We also review the SC method and the ASA for DES with Markovian structure in their event processes. Then, in Section 16.4, we describe the procedure through which the general constructability problem is solved and derive the aforementioned TWA. In Section 16.5, we describe how the TWA can be used together with optimization schemes (e.g.,5–8 to solve dynamic resource allocation problems (see also works by Panayiotou and Cassandras9,10). The chapter ends with some final thoughts and conclusions.

Ми починаємо цю главу з огляду стохастичного часового автомата (STA) для моделювання DES у розділі 16.2. Це структура, яка використовується більшістю комерційних симуляторів дискретних подій, таким чином полегшуючи реалізацію методів одночасного моделювання, які будуть описані. У Розділі 16.3 ми визначаємо загальну проблему конструктивності шляху зразка. Ми також розглядаємо метод SC і ASA для DES з марковською структурою в їхніх подійних процесах. Потім у Розділі 16.4 ми описуємо процедуру, за допомогою якої розв’язується загальна проблема конструктивності та отримуємо вищезгадану TWA. У Розділі 16.5 ми описуємо, як TWA можна використовувати разом зі схемами оптимізації (наприклад, 5–8 для вирішення проблем динамічного розподілу ресурсів (див. також роботи Панайоту та Кассандраса9,10). Розділ закінчується деякими заключними думками та висновками.

[16 <--- ](16.md) [   Зміст   ](README.md) [--> 16.2](16_2.md)