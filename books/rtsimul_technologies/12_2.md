[12.1 <--- ](12_1.md) [   Зміст   ](README.md) [--> 12.3](12_3.md)

## 12.2. STATE OF THE ART IN CONSISTENCY AND SEMANTICS

In this section, we analyze the details of the UML consistency problem and its relation with the UML semantics. We discuss alternative solutions proposed in the research literature. The solutions presented address three specific problems related to UML consistency: (1) verifying the consistency of different views of the same system, (2) giving a complete and consistent semantics to UML diagrams, and (3) integrating models of different subsystems into a coherent, implementable model of the system.

У цьому розділі ми аналізуємо деталі проблеми узгодженості UML та її зв’язок із семантикою UML. Ми обговорюємо альтернативні рішення, запропоновані в науковій літературі. Представлені рішення вирішують три конкретні проблеми, пов’язані з узгодженістю UML: (1) перевірка узгодженості різних представлень однієї системи, (2) надання повної та узгодженої семантики діаграмам UML і (3) інтеграція моделей різних підсистем у узгоджена, реалізована модель системи.

In the following, we present a set of requirements we use to evaluate approaches to UML consistency. We identified these requirements by surveying the literature and analyzing strengths and weaknesses of each approach proposed. Although each requirement is fulfilled by at least a few approaches, none of the approaches we surveyed performs well in all the areas. Thus, we use these requirements as a tool for comparing the different approaches proposed by different researchers and to identify areas that can be improved. In Section 12.3, we propose an approach that can address all requirements by leveraging different ideas surveyed in our state of the art overview.

Далі ми представляємо набір вимог, які ми використовуємо для оцінки підходів до узгодженості UML. Ми визначили ці вимоги, дослідивши літературу та проаналізувавши сильні та слабкі сторони кожного запропонованого підходу. Хоча кожна вимога задовольняється принаймні кількома підходами, жоден із розглянутих підходів не працює добре в усіх сферах. Таким чином, ми використовуємо ці вимоги як інструмент для порівняння різних підходів, запропонованих різними дослідниками, і для визначення областей, які можна вдосконалити. У розділі 12.3 ми пропонуємо підхід, який може задовольнити всі вимоги, використовуючи різні ідеї, розглянуті в нашому огляді сучасного стану.

### 12.2.1 UML Model Consistency Requirements

We have identified 12 important requirements (collected in Table 12.1) by analyzing the requirements discussed in the literature for current approaches to model consistency. Requirements R1 to R3 in Table 12.1 originate from the observation that any strategy to manage model consistency should not limit the freedom of developers. This entails that developers should be allowed to modify models even if they introduce some inconsistencies. This idea is introduced in Finkelstein et al. [10], where the authors observe that inconsistency is necessary and often desirable in some phase of the development cycle. For example, in the inception phase of a large project with different stakeholders involved, each stakeholder pursues different goals and, during the collection of requirements, this can lead to inconsistent views that must be identified and reconciled in subsequent iterations. Other arguments in support of Requirements R1 to R3 have been documented elsewhere [11–13]. The common denominator of all arguments is that effective modeling techniques must support decomposing the problem into independent subproblems. This is the case when in order to solve complex problems, engineers decompose various aspects of the system and reason about each aspect in isolation. Alternatively, this occurs when in order to solve complex problems efficiently, different teams work in parallel on different aspects of the system.

Ми визначили 12 важливих вимог (зібраних у таблиці 12.1), проаналізувавши вимоги, які обговорюються в літературі для сучасних підходів до узгодженості моделі. Вимоги від R1 до R3 у таблиці 12.1 випливають зі спостереження, що будь-яка стратегія управління узгодженістю моделі не повинна обмежувати свободу розробників. Це означає, що розробникам слід дозволити змінювати моделі, навіть якщо вони вносять певні невідповідності. Ця ідея представлена у Finkelstein et al. [10], де автори зауважують, що непослідовність необхідна і часто бажана на певній фазі циклу розробки. Наприклад, на початковому етапі великого проекту із залученням різних зацікавлених сторін кожна зацікавлена сторона переслідує різні цілі, і під час збору вимог це може призвести до непослідовних поглядів, які необхідно визначити та узгодити на наступних ітераціях. Інші аргументи на підтримку вимог від R1 до R3 були задокументовані в інших місцях [11–13]. Спільним знаменником усіх аргументів є те, що ефективні методи моделювання повинні підтримувати розкладання проблеми на незалежні підпроблеми. Це той випадок, коли для вирішення складних проблем інженери декомпонують різні аспекти системи та розмірковують про кожен аспект окремо. Крім того, це відбувається, коли для ефективного вирішення складних проблем різні команди паралельно працюють над різними аспектами системи.

**TABLE** **12.1** **Requirements** **for** **UML** **Consistency** **Management**

**Requirement** **Description**

R1      *Inconsistent* models can be *introduced and kept in the system* specification for a certain amount of time

R2      *Inconsistencies* should be *discovered automatically and tracked* during the evolution of model

R3      Support should be provided to the developer to *resolve inconsistencies when convenient*

R4      Support *multiple* modeling *languages* (for example, different UML notations or even non-UML languages)

R5      Support *different levels* of abstraction

R6      Support the *extension or specialization* of languages R7      Support *horizontal* consistency

R8      Support *vertical* consistency

R9      Support *static* consistency R10       Support *dynamic* consistency

R11     *Tool* support (or translations to available tools) R12 *Scalability* to large models

A second observation is that each model caters to different needs that arise during the development process. For example, informal models are used to gather requirements and exchange ideas between stakeholders and developers during requirements gathering [14]. Later in the development process, more formal models are used to describe the structure or the behavior of certain parts of the system. In this phase, formal models are used to verify properties of a system or to generate part of the implementation code. This second observation is the source of the additional requirements R4 to R6 in [Table 12.1](#_bookmark70).

Друге зауваження полягає в тому, що кожна модель задовольняє різні потреби, які виникають у процесі розробки. Наприклад, неформальні моделі використовуються для збору вимог та обміну ідеями між зацікавленими сторонами та розробниками під час збору вимог [14]. Пізніше в процесі розробки використовуються більш формальні моделі для опису структури або поведінки певних частин системи. На цьому етапі формальні моделі використовуються для перевірки властивостей системи або для створення частини коду реалізації. Це друге спостереження є джерелом додаткових вимог від R4 до R6 у [таблиці 12.1] (#_bookmark70).

To evaluate consistency management techniques, the notion of consistency must be clearly defined. The scientific literature examines different notions of consistency. A distinction can be made between *horizontal* and *vertical* consistencies [15,16]. *Horizontal* consistency involves different perspectives on the same system model. For example, on the one hand, to describe the communication between a client and a server, it is possible to use a UML sequence diagram to capture the protocol and a state diagram to capture the server behavior. The two diagrams are different views on the same system and should be horizontally consistent. On the other hand, *vertical* consistency addresses views of the same aspect of one system, but at different levels of abstraction, often in relation to the evolution of one model during different phases of the development process. For example, an abstract model created during requirements gathering must agree with a more detailed model used for code generation in a later step of the development process. Another important distinction is between *static* and *dynamic* consistency [17]. *Static* consistency addresses syntactical and structural model dependencies, whereas *dynamic* consistency ensures the consistency of executable models. We introduce four requirements (R7 to R10 in Table 12.1) to capture these four notions of consistency.

Щоб оцінити методи управління узгодженістю, необхідно чітко визначити поняття узгодженості. У науковій літературі розглядаються різні поняття узгодженості. Можна розрізнити *горизонтальну* і *вертикальну* консистенції [15,16]. *Горизонтальна* узгодженість передбачає різні погляди на ту саму модель системи. Наприклад, з одного боку, щоб описати зв’язок між клієнтом і сервером, можна використовувати діаграму послідовності UML для запису протоколу та діаграму стану для запису поведінки сервера. Дві діаграми є різними видами однієї системи та повинні бути узгодженими по горизонталі. З іншого боку, *вертикальна* узгодженість стосується поглядів на той самий аспект однієї системи, але на різних рівнях абстракції, часто у зв’язку з еволюцією однієї моделі на різних етапах процесу розробки. Наприклад, абстрактна модель, створена під час збору вимог, повинна узгоджуватися з більш детальною моделлю, яка використовується для генерації коду на наступному етапі процесу розробки. Інша важлива відмінність між *статичною* та *динамічною* узгодженістю [17]. *Статична* узгодженість розглядає синтаксичні та структурні залежності моделі, тоді як *динамічна* узгодженість забезпечує узгодженість виконуваних моделей. Ми вводимо чотири вимоги (від R7 до R10 у таблиці 12.1), щоб охопити ці чотири поняття узгодженості.

The final two requirements address practical use of consistency management techniques. Requirement R11 recognizes that consistency checking must be supported by a tool chain. Requirement R12 recognizes that industrial systems are large scale and this implies they have large system models. Therefore, scalability of the chosen technique to large models is an important requirement.

Останні дві вимоги стосуються практичного використання методів управління узгодженістю. Вимога R11 визнає, що перевірка узгодженості повинна підтримуватися ланцюжком інструментів. Вимога R12 визнає, що промислові системи є великомасштабними, і це означає, що вони мають великі моделі систем. Тому важливою вимогою є масштабованість обраної техніки до великих моделей.

### 12.2.2 Consistency Checking

In the literature, a number of promising approaches for model consistency checking exist. The existing approaches can be divided into two categories: rule-based approaches and translation-based approaches. The first category uses rule-based systems to define consistency rules directly on the modeling language. In general, rule-based approaches scale well to large models but are limited to addressing only *static* consistency (failing requirement R10). On the other hand, translation-based approaches leverage a target language with a formal semantics and translate models into this language. Tools that support automated reasoning or formal verification in the target language can be used to reason about the consistency of the original models. Translation-based approaches can address both *static* and *dynamic* consistencies; however, they have very limited scalability and tend to be restricted to a subset of the UML languages (failing requirement R4).

У літературі існує ряд перспективних підходів для перевірки узгодженості моделі. Існуючі підходи можна розділити на дві категорії: підходи на основі правил і підходи на основі перекладу. Перша категорія використовує системи на основі правил для визначення правил узгодженості безпосередньо на мові моделювання. Загалом, підходи, засновані на правилах, добре масштабуються для великих моделей, але обмежуються вирішенням лише *статичної* узгодженості (відсутність вимоги R10). З іншого боку, підходи на основі перекладу використовують цільову мову з формальною семантикою та перекладають моделі на цю мову. Інструменти, які підтримують автоматичне обґрунтування або формальну перевірку цільовою мовою, можуть бути використані для обговорення узгодженості вихідних моделей. Підходи на основі перекладу можуть стосуватися як *статичних*, так і *динамічних* узгодженостей; однак, вони мають дуже обмежену масштабованість і, як правило, обмежені підмножиною мов UML (відсутня вимога R4).

Rule-based approaches translate a modeling language into a logic framework on which the system of rules is defined. The goal of the translation is to be able to apply rules defined on a logic framework. This translation does not aim at defining a formal semantics for the modeling language and does usually limit the expressiveness of consistency rules to structural elements of the language. On the other hand, translation-based approaches leverage languages with formal semantics and the translation process implies the definition of a formal semantics for the UML. These approaches enable reasoning about consistency of behavioral models but tend to work only on subsets of UML and impose the resolution of variation points. Because translation-based approaches are closely related to the problem of defining a formal semantics for UML, we discuss them further in the Subsection 12.2.3.

Підходи, засновані на правилах, перетворюють мову моделювання в логічну структуру, на якій визначається система правил. Метою перекладу є можливість застосовувати правила, визначені в логічній структурі. Цей переклад не має на меті визначення формальної семантики для мови моделювання і зазвичай обмежує виразність правил узгодженості структурними елементами мови. З іншого боку, підходи, засновані на перекладі, використовують мови з формальною семантикою, а процес перекладу передбачає визначення формальної семантики для UML. Ці підходи дозволяють міркувати про узгодженість поведінкових моделей, але, як правило, працюють лише на підмножинах UML і накладають дозвіл на точки варіації. Оскільки підходи на основі перекладу тісно пов’язані з проблемою визначення формальної семантики для UML, ми обговорюємо їх далі в підрозділі 12.2.3.

[Table 12.2 ](#_bookmark71)summarizes the approaches to consistency that we discuss in this section. Each requirement we identified in the previous section is a column of the table, whereas each of the approaches we discuss here is represented as a row. This section and Table 12.2 cover consistency management approaches that use rule-based systems; a second table in the next section covers approaches that use translation to formal languages. These approaches are important to know, especially if you want to understand the fundamental issues with consistency arising from the flexible, but complex, UML metamodel. Additional consistency problems, such as timing consistency, arise when using profiles for real-time systems, such as MARTE. These problems are not directly addressed by any of the methodologies surveyed.

[Таблиця 12.2 ](#_bookmark71) узагальнює підходи до узгодженості, які ми обговорюємо в цьому розділі. Кожна вимога, яку ми визначили в попередньому розділі, є стовпцем таблиці, тоді як кожен із підходів, які ми тут обговорюємо, представлений у вигляді рядка. Цей розділ і таблиця 12.2 охоплюють підходи до управління узгодженістю, які використовують системи на основі правил; друга таблиця в наступному розділі охоплює підходи, які використовують переклад на офіційні мови. Ці підходи важливо знати, особливо якщо ви хочете зрозуміти фундаментальні питання узгодженості, що виникають у зв’язку з гнучкою, але складною метамоделлю UML. Додаткові проблеми узгодженості, такі як узгодженість синхронізації, виникають під час використання профілів для систем реального часу, таких як MARTE. Жодна з розглянутих методологій безпосередньо не вирішує ці проблеми.

A logic framework for capturing models and rules has been proposed by Van Der Straeten et al. [18]. In this work, the authors propose the use of description logic (DL), which is less powerful than first-order logic, but is decidable. The approach, which targets a subset of the UML language, proposes to encode UML models and metamodels as well as consistency rules in DL. The focus of this appproach is on both software evolution (vertical consistency) and consistency between different views of the same specification (horizontal consistency). To this end, the UML metamodel is enhanced with classes capturing horizontal and vertical relations. This approach is used, for example, to support model refactoring in [19], which documents how the RACER tool is used to enable inference from the DL knowledge bases. The translation between UML and DL is performed by the RACOoN tool, which enables refactoring and is integrated into the Poseidon UML modeling tool.

Логічна структура для захоплення моделей і правил була запропонована Van Der Straeten та ін. [18]. У цій роботі автори пропонують використовувати логіку опису (DL), яка є менш потужною, ніж логіка першого порядку, але є вирішальною. Цей підхід, спрямований на підмножину мови UML, передбачає кодування моделей і метамоделей UML, а також правил узгодженості в DL. Цей підхід зосереджений як на еволюції програмного забезпечення (вертикальна узгодженість), так і на узгодженості між різними видами однієї специфікації (горизонтальна узгодженість). З цією метою метамодель UML розширена класами, що фіксують горизонтальні та вертикальні відносини. Цей підхід використовується, наприклад, для підтримки рефакторингу моделі в [19], де документовано, як інструмент RACER використовується для забезпечення висновку з баз знань DL. Переклад між UML і DL виконується інструментом RACOoN, який уможливлює рефакторинг і інтегрований в інструмент моделювання Poseidon UML.

Sabetzadeh and Easterbrook [20] present a requirements merging approach based on category theory. The approach aims at merging inconsistent and incomplete views. Views are expressed as graphs, and relations between views are expressed by an interconnection diagram that relates common elements of different views. A colimit operation on the views combined with the interconnection diagram return the integrated view. To address inconsistencies, the methodology supports annotating elements of the graphs to identify where inconsistencies stem from. Annotations are captured via a knowledge lattice that identifies proposed, repudiated, affirmed, and disputed elements. The article, however, does not discuss how this technique can be applied to address the consistency of views expressed in different languages.

Сабетзаде та Істербрук [20] представляють підхід до об’єднання вимог на основі теорії категорій. Цей підхід спрямований на об’єднання неузгоджених і неповних поглядів. Погляди представлені у вигляді графіків, а зв’язки між поданнями виражені діаграмою взаємозв’язків, яка пов’язує загальні елементи різних поданнях. Операція colimit над представленнями в поєднанні з схемою взаємозв’язку повертає інтегроване подання. Щоб усунути невідповідності, методологія підтримує анотування елементів графіків, щоб визначити, звідки походять невідповідності. Анотації фіксуються через решітку знань, яка визначає запропоновані, спростовані, підтверджені та спірні елементи. У статті, однак, не обговорюється, як цю техніку можна застосувати для вирішення узгодженості поглядів, висловлених різними мовами.

**TABLE** **12.2**  **Evaluation** **of** **Consistency** **Checking** **Approaches** **Based** **on** **Rule** **Systems**

|                                                              | **Rules Specification Language**                             | **R1** | **R2** | **R3** | **R4** | **R5** | **R6** | **R7** | **R8** | **R9** | **R10** | **R11** | **R12** |
| ------------------------------------------------------------ | ------------------------------------------------------------ | ------ | ------ | ------ | ------ | ------ | ------ | ------ | ------ | ------ | ------- | ------- | ------- |
| Van Der Straeten et al. [18],  Van Der Straeten and D’Hondt [19] | Description logic                                            | ⨯      | ⨯      | ⨯      | ✓      | ⨯      | ⨯      | ✓      | ✓      | ✓      | ⨯       | ✓       | ?       |
| Sabetzadeh and Easterbrook [20]                              | Interconnection diagram describes relations between  views, a knowledge lattice captures additional information on each element | ✓      | ⨯      | ⨯      | ⨯      | ⨯      | ✓      | ✓      | ✓      | ✓      | ?       | ✓       | ?       |
| Nentwich et  al. [21]                                        | Rules  expressed in a reduced first-order logic, XPATH expressions identify where to apply them | ✓      | ⨯      | ⨯      | ✓      | ✓      | ⨯      | ✓      | ⨯      | ✓      | ⨯       | ✓       | ⨯       |
| Engels et al.  [22]                                          | Dynamic metamodeling (rules  defined on the UML metamodel)   | ✓      | ⨯      | ⨯      | ✓      | ✓      | ⨯      | ✓      | ⨯      | ✓      | ✓       | ✓       | ⨯       |
| Egyed [23,24]                                                | Rules are  stateless and deterministic                       | ✓      | ✓      | ✓      | ✓      | ✓      | ✓      | ✓      | ⨯      | ✓      | ⨯       | ✓       | ✓       |
| *Note:* The symbol ✓ indicates  that the requirement is met, the symbol ⨯ indicates that the requirement is not  met, and the symbol ? indicates that it is not clear from the literature if and to which degree the  requirement is met. |                                                              |        |        |        |        |        |        |        |        |        |         |         |         |

Other approaches proposed in the literature define consistency rules on models represented by XML documents. These approaches can be adapted to work on XML representations of UML models serialized in the XML Metadata Interchange (XMI®) [25] interchange format. For example, a general XML-based consistency checking tool called xlinkit has been used to verify structural consistency; Nentwich et al. [21] present the tool, an incremental algorithm for checking, and a case study. To make rules decidable, they are based on a restricted version of first-order logic. The tool can check XML documents or other types of models by using a “fetcher” that reads the code and creates an in-memory Document Object Model (DOM) from it. Then, xlinkit uses XPATH (a query language for DOM) to specify the parts of the memory model where the rules must be applied. As a result of the rules evaluation, a set of links between conflicting elements is created. This enables the user to navigate the model and resolve inconsistencies without forcing the immediate resolution of every inconsistency. To improve scalability, an incremental algorithm is used to detect which rules have to be rechecked after a change. However, once the tool decides that a rule must be reevaluated, it is reevaluated on the entire model. As a result, when complex rules (such as the language constraints defined by the UML standard) have to be reevaluated, the benefits of this incremental algorithm are limited. The authors claim that the cause of this drawback is the complexity of the XMI representation. The benefits of this technique are the independence from a specific modeling tool (XMI is an interchange standard supported by many tools) and the possibility of distributing the documents over the Internet. Major limitations are the fact that only structural consistency is addressed and that different rule evaluation orders can lead to different results. Moreover, XMI is not interpreted consistently by different tools. Therefore, it is not functioning as an interchange language in practice and consistency checking results could also be influenced by the tool chosen for creating the XMI file.

Інші підходи, запропоновані в літературі, визначають правила узгодженості для моделей, представлених документами XML. Ці підходи можна адаптувати для роботи з XML-представленнями моделей UML, серіалізованих у форматі обміну метаданими XML (XMI®) [25]. Наприклад, загальний інструмент перевірки узгодженості на основі XML під назвою xlinkit використовувався для перевірки структурної узгодженості; Nentwich та ін. [21] представляють інструмент, поетапний алгоритм для перевірки та приклад. Щоб зробити правила доступними, вони базуються на обмеженій версії логіки першого порядку. Інструмент може перевіряти XML-документи або інші типи моделей за допомогою «збірника», який зчитує код і створює з нього об’єктну модель документа (DOM) у пам’яті. Потім xlinkit використовує XPATH (мову запитів для DOM), щоб вказати частини моделі пам’яті, до яких мають застосовуватися правила. В результаті оцінки правил створюється набір зв'язків між конфліктуючими елементами. Це дає змогу користувачеві орієнтуватися в моделі та вирішувати невідповідності, не змушуючи негайно вирішувати кожну невідповідність. Щоб покращити масштабованість, використовується інкрементний алгоритм для виявлення того, які правила потрібно перевірити повторно після зміни. Однак, як тільки інструмент вирішує, що правило потрібно повторно оцінити, воно повторно оцінюється для всієї моделі. У результаті, коли складні правила (такі як мовні обмеження, визначені стандартом UML) повинні бути переоцінені, переваги цього інкрементального алгоритму обмежені. Автори стверджують, що причиною цього недоліку є складність представлення XMI. Перевагами цієї методики є незалежність від конкретного інструменту моделювання (XMI — це стандарт обміну, який підтримується багатьма інструментами) і можливість розповсюдження документів через Інтернет. Основними обмеженнями є той факт, що розглядається лише структурна узгодженість і що різні порядки оцінки правил можуть призвести до різних результатів. Крім того, XMI не інтерпретується послідовно різними інструментами. Тому на практиці він не функціонує як мова обміну, і на результати перевірки узгодженості також може вплинути інструмент, вибраний для створення файлу XMI.

Other approaches define rules at the UML metamodel level instead of choosing a specific UML representation, such as the XML-based approaches of the previous paragraph. For example, Engels et al. [22] present an approach based on dynamic metamodeling (DMM). Rules are defined on the graphical representation of the UML metamodel using an extended class diagram notation. The extensions include the ability to annotate elements of the metamodel with *new* and *delete* keywords. These keywords specify that the corresponding elements are respectively created or removed when the configuration captured by the metamodel is instantiated. The verification of consistency is then performed by testing. Overlapping models are verified in pairs where one is executed according to the DMM semantics, whereas the other is checked to identify violations. This approach has the great benefit of using a graphical model with which UML users are familiar. Drawbacks are that many rules must be defined for UML and that testing is not complete. In particular, the paper does not discuss any form of coverage metric to assess the confidence in the verification process.

Інші підходи визначають правила на рівні метамоделі UML замість вибору конкретного представлення UML, як-от підходи на основі XML, описані в попередньому абзаці. Наприклад, Engels et al. [22] представили підхід, заснований на динамічному метамоделюванні (DMM). Правила визначаються на графічному представленні метамоделі UML з використанням нотації розширеної діаграми класів. Розширення включають можливість анотувати елементи метамоделі за допомогою ключових слів *new* і *delete*. Ці ключові слова вказують, що відповідні елементи відповідно створюються або видаляються, коли створюється екземпляр конфігурації, отриманої метамоделлю. Перевірка узгодженості потім виконується тестуванням. Моделі, що перекриваються, перевіряються в парах, де одна виконується відповідно до семантики DMM, тоді як інша перевіряється для виявлення порушень. Цей підхід має велику перевагу використання графічної моделі, з якою знайомі користувачі UML. Недоліки полягають у тому, що для UML необхідно визначити багато правил і що тестування не є повним. Зокрема, у документі не обговорюється жодна форма метрики охоплення для оцінки довіри до процесу перевірки.

Other approaches extend modeling tools. For example, Egyed [23,24] presents an extension to the Rational Rose tool. This extension, which is based on an algorithm presented in Ref. [26] by the same author, supports incremental consistency checking by using stateless deterministic rules. The incremental rule checking algorithm can analyze which part of the model is accessed during the evaluation of a rule and use the information to reevaluate rules only on the relevant portion of the model when changes happen. For each inconsistency identified, the tool creates an inconsistency annotation in a report. This tool is highly scalable and has been used on actual large models in industrial case studies. 

Інші підходи розширюють інструменти моделювання. Наприклад, Egyed [23,24] представляє розширення інструменту Rational Rose. Це розширення, яке базується на алгоритмі, представленому в Ref. [26] того ж автора, підтримує інкрементну перевірку узгодженості за допомогою детермінованих правил без стану. Алгоритм інкрементної перевірки правил може аналізувати, до якої частини моделі здійснюється доступ під час оцінки правила, і використовувати інформацію для повторної оцінки правил лише для відповідної частини моделі, коли відбуваються зміни. Для кожної виявленої невідповідності інструмент створює анотацію невідповідності у звіті. Цей інструмент дуже масштабований і використовувався на реальних великих моделях у промислових прикладах.

### 12.2.3 Semantics

The second type of consistency checking approaches is closely related to the problem of defining a formal semantics for UML languages. The research community has been very active in defining semantics for UML [27–31]. Broy et al. [29–31] give a formal model for UML based on stream semantics [32]. This approach bases the semantics on the elements of the UML metamodel and maps the UML to a formal model that closely matches each element of the metamodel itself. This results in a very complete semantic framework that formally captures every detail of the language, enabling the reasoning about every feature of the UML. However, for the goal of checking dynamic consistency of models, this framework is difficult to use. In fact, model checking tools are used to verify dynamic consistency. Because the translation to the formal model suggested by Broy et al. [29–31] contains all details of the UML, the state space of the models tends to be very large and properties are difficult to verify. Other work by Krüger and Menarini [28] proposes to map each diagram element to a very simple domain model specifically developed for the application domain the model is describing. This simplifies the automatic reasoning about the model properties but loses details about the language. In general, to use the UML and provide a formal semantics, the variation points are resolved and a profile is created to match the modeling needs.

Другий тип підходів до перевірки узгодженості тісно пов'язаний із проблемою визначення формальної семантики для мов UML. Дослідницьке співтовариство було дуже активним у визначенні семантики для UML [27–31]. Брой та ін. [29–31] надають формальну модель для UML на основі семантики потоку [32]. Цей підхід базує семантику на елементах метамоделі UML і відображає UML на формальну модель, яка точно відповідає кожному елементу самої метамоделі. Це призводить до дуже повної семантичної структури, яка формально охоплює кожну деталь мови, дозволяючи міркувати про кожну функцію UML. Однак для перевірки динамічної узгодженості моделей цей фреймворк важко використовувати. Фактично інструменти перевірки моделі використовуються для перевірки динамічної узгодженості. Оскільки переклад на формальну модель, запропоновану Broy et al. [29–31] містить усі деталі UML, простір станів моделей, як правило, дуже великий, а властивості важко перевірити. Інша робота Крюгера та Менаріні [28] пропонує зіставити кожен елемент діаграми з дуже простою моделлю предметної області, спеціально розробленою для області застосування, яку описує модель. Це спрощує автоматичне обґрунтування властивостей моделі, але втрачає деталі мови. Загалом, для використання UML і надання формальної семантики, точки варіації вирішуються і створюється профіль відповідно до потреб моделювання.

Translation-based approaches for consistency management have been pursued by various authors. Instead of defining consistency rules based on the source models, they translate models into various formal languages and logics. The consistency is then implied by contradiction in the semantics of the target language. One of the main benefits of such approaches is that the translation to the target formal language defines the semantics of behavioral models. Therefore, on the one hand, all approaches following this avenue support reasoning about dynamic consistency. On the other hand, because in the translation the mapping to the original model can be lost, such approaches have greater difficulty in dealing with syntactic and structural rules required by static consistency.

Підходи, засновані на перекладі, для управління узгодженістю використовувалися різними авторами. Замість того, щоб визначати правила узгодженості на основі вихідних моделей, вони перекладають моделі на різні формальні мови та логіку. Послідовність тоді мається на увазі через протиріччя в семантиці цільової мови. Однією з головних переваг таких підходів є те, що переклад на цільову формальну мову визначає семантику поведінкових моделей. Тому, з одного боку, усі підходи, що йдуть за цим напрямом, підтримують міркування про динамічну узгодженість. З іншого боку, оскільки під час перекладу відображення оригінальної моделі може бути втрачено, такі підходи мають більше труднощів у роботі з синтаксичними та структурними правилами, яких вимагає статична узгодженість.

[Table 12.3](#_bookmark72) summarizes the consistency approaches discussed in this section. These approaches are all based on giving a formal semantics to UML by providing a translation to some formal language.

[Таблиця 12.3](#_bookmark72) узагальнює підходи узгодженості, які обговорюються в цьому розділі. Усі ці підходи базуються на наданні формальної семантики UML шляхом надання перекладу на деяку формальну мову.

An example of an approach that involves translation is presented by Easterbrook and Chechik [33]. They use the Xbel framework to reason about state machines encoding inconsistent multiview requirements. The approach proceeds as follows. First, multiple state-machine views are merged into a single state machine. Because views can be inconsistent, the system is based on a multivalued logic called quasiBoolean logic. Next, a multivalued model checker (called Xchek) is used to verify temporal properties expressed in XCTL (an extension of computation tree logic [38]). Translating state machines into their multivalued logic counterparts enables the merger of inconsistent and incomplete models. The Xchek model checker enables the analysis of how inconsistencies affect the execution behavior of the state machines and helps in resolving them.

Приклад підходу, який передбачає переклад, представлений Істербруком і Чечіком [33]. Вони використовують фреймворк Xbel, щоб міркувати про те, що кінцеві автомати кодують суперечливі вимоги до мультиракурсу. Підхід відбувається наступним чином. По-перше, декілька режимів кінцевого автомата об’єднуються в один кінцевий автомат. Оскільки погляди можуть бути непослідовними, система базується на багатозначній логіці, яка називається квазібулевою логікою. Далі для перевірки часових властивостей, виражених у XCTL (розширення логіки дерева обчислень [38]), використовується засіб перевірки багатозначної моделі (званий Xchek). Трансляція кінцевих автоматів у їхні аналоги багатозначної логіки дає змогу об’єднати суперечливі та неповні моделі. Засіб перевірки моделі Xchek дозволяє аналізувати, як невідповідності впливають на поведінку виконання кінцевих автоматів, і допомагає їх вирішувати.

**TABLE** **12.3**  **Evaluation** **of** **Consistency** **Checking** **Approaches** **Based** **on** **Translation** **to** **a** **Different** **Semantics**

|                               | **Translation** **Target** **Language**                      | **R1** | **R2** | **R3** | **R4** | **R5** | **R6** | **R7** | **R8** | **R9** | **R10** | **R11** | **R12** |
| ----------------------------- | ------------------------------------------------------------ | ------ | ------ | ------ | ------ | ------ | ------ | ------ | ------ | ------ | ------- | ------- | ------- |
| Easterbrook and Chechik  [33] | State machines in multivalued quasi-Boolean logic            | ✓      | ✓      | ⨯      | ⨯      | ⨯      | ⨯      | ✓      | ⨯      | ✓      | ✓       | ✓       | ⨯       |
| Inverardi et al. [34]         | State machines encoded in Promela, sequence diagrams encoded in linear temporal logic | ⨯      | ⨯      | ⨯      | ⨯      | ⨯      | ⨯      | ✓      | ⨯      | ⨯      | ✓       | ✓       | ⨯       |
| Ossami et al.  [35]           | Translate UML to B                                           | ⨯      | ⨯      | ⨯      | ⨯      | ⨯      | ⨯      | ✓      | ?      | ?      | ✓       | ✓       | ⨯       |
| Engels et al.  [36]           | Communicating  Sequential Processes                          | ⨯      | ⨯      | ⨯      | ⨯      | ⨯      | ⨯      | ✓      | ✓      | ✓      | ✓       | ?       | ⨯       |
| Paige et al. [37]             | Prototype Verification System or Eiffel                      | ⨯      | ⨯      | ⨯      | ⨯      | ⨯      | ⨯      | ✓      | ✓      | ✓      | ✓       | ?       | ⨯       |

*Note:* The symbol ✓ indicates  that the requirement is met, the symbol ⨯ indicates that the requirement is not  met, and the symbol ? indicates that it is not clear from the literature if and to which degree the  requirement is met.

*Примітка:* Символ ✓ означає, що вимога виконана, символ ⨯ означає, що вимога не виконана, а символ ? вказує на те, що з літератури незрозуміло, чи і в якій мірі ця вимога виконана.

Inverardi et al. [34] use the SPIN [39] model checker to verify consistency of the behavior expressed by overlapping state machines and sequence diagrams. The approach uses Milner’s [40] Calculus of Communicating Systems notation to describe state machines and a stereotype of the UML for sequence diagrams. The paper proposes to translate state machines into Promela (the input language of the SPIN model checker) and to translate sequence diagrams into linear temporal logic (LTL) formulae. SPIN is used to verify consistency by checking that the Promela model satisfies the properties expressed by the LTL formulae. A tool called Charmy supports the creation of sequence diagrams and state machines while it also generates the Promela code and the LTL formulae for verification.

Інверарді та ін. [34] використовують засіб перевірки моделі SPIN [39] для перевірки узгодженості поведінки, вираженої автоматами стану, що перекриваються, і діаграмами послідовності. Цей підхід використовує нотацію Мілнера [40] Calculus of Communicating Systems для опису кінцевих автоматів і стереотип UML для діаграм послідовності. У статті пропонується перевести кінцеві автомати на Promela (мову введення засобу перевірки моделі SPIN) і перевести діаграми послідовностей у формули лінійної часової логіки (LTL). SPIN використовується для перевірки узгодженості шляхом перевірки того, що модель Promela задовольняє властивості, виражені формулами LTL. Інструмент під назвою Charmy підтримує створення діаграм послідовності та кінцевих автоматів, а також генерує код Promela та формули LTL для перевірки.

A different solution to consistency checking is proposed by Ossami et al. [35]. The semantics of the UML is formalized by using the B [41] language. This enables developers to verify properties of their systems by using the verification tools supporting B. However, often a developer must modify the B specification to complete the proof. In this case, the two views of the system (UML and B) can become inconsistent. The solution proposed by the authors is to create development operators that map each requested transformation in one domain to equivalent transformations in the other. Therefore, once the correctness of the development operator is proven, it can be applied many times without introducing any inconsistency. This constructive approach has the benefit of reducing the amount of verification to perform. On the other hand, the developer is limited by the existing operators in how to modify the model because the solution does not allow consistency to be broken at any time. The approach of creating development operators is useful in the specific application domain; however, it is not applicable in development processes where inconsistencies are tolerated.

Інше рішення для перевірки узгодженості запропоновано Ossami та ін. [35]. Семантика UML формалізована за допомогою мови B [41]. Це дозволяє розробникам перевіряти властивості своїх систем за допомогою інструментів перевірки, що підтримують B. Однак часто розробник повинен змінити специфікацію B, щоб завершити доказ. У цьому випадку два погляди на систему (UML і B) можуть стати несумісними. Рішення, запропоноване авторами, полягає у створенні операторів розробки, які відображають кожне запитане перетворення в одному домені на еквівалентні перетворення в іншому. Тому, як тільки коректність оператора розробки доведено, його можна застосовувати багато разів без внесення будь-яких неузгодженостей. Перевага такого конструктивного підходу полягає в зменшенні обсягу верифікації. З іншого боку, розробник обмежений наявними операторами в тому, як модифікувати модель, оскільки рішення не дозволяє будь-коли порушити узгодженість. Підхід створення операторів розробки корисний у певній області застосування; однак він не застосовується в процесах розробки, де допускаються невідповідності.

Engels et al. [36] present a translational approach to reasoning about the consistency of UML behavioral models. The approach is used for UML protocol statecharts. In particular, the approach is demonstrated in presence of the inheritance of classes whose protocol behavior is defined by statecharts. Inheritance imposes a refinement relation between statecharts. The paper focuses on vertical consistency, but the same technique addresses horizontal consistency as well. The target language for the translation is Communicating Sequential Processes (CSP) [42]. Rules are defined on the UML metamodel, which defines the UML graphical syntax used to translate the graphical models into the CSP textual notation. Then a tool called FDR (for FailuresDivergence Refinement) is used to verify the refinement relation in CSP.

Енгельс та ін. [36] представляють трансляційний підхід до міркування про узгодженість поведінкових моделей UML. Цей підхід використовується для діаграм станів протоколу UML. Зокрема, підхід продемонстровано при наявності успадкування класів, поведінка протоколу яких визначається діаграмами станів. Спадкування накладає відношення уточнення між діаграмами станів. Стаття зосереджена на вертикальній узгодженості, але той самий прийом стосується і горизонтальної узгодженості. Цільовою мовою для перекладу є комунікація послідовних процесів (CSP) [42]. Правила визначені в метамоделі UML, яка визначає графічний синтаксис UML, що використовується для перекладу графічних моделей у текстову нотацію CSP. Потім інструмент під назвою FDR (для FailuresDivergence Refinement) використовується для перевірки відношення уточнення в CSP.

Two other methodologies making use of translational approaches are presented by Paige et al. [37]. They share the same idea of translating the metamodel of the modeling language into a formal language supported by verification tools. Then each model—instead of being expressed in the original modeling language—is translated into the target language. The modeling language used is Business Oriented Notation (BON); however, UML could be supported as well. In fact, the semantics of the modeling language are completely defined by the metamodel expressed in the new formalism. The two approaches in Ref. [37] differ in the target language. The first approach translates models and metamodels into Prototype Verification System (PVS), a theorem prover language that supports semiautomatic proofs. The second uses Eiffel as a target language. Eiffel is object oriented and supports annotations to define method preconditions, postconditions, and class invariants. On the other hand, translation into PVS is the more flexible of the two approaches as it can encode all details of the metamodels and the verifications are complete. The limitation of PVS is the complexity of the translated models and the fact that it requires manual intervention in the verification process. On the other hand, Eiffel is a programming language and the “verifications” are performed by testing, which can be automated but the results are not complete. The general benefit of this type of approaches is that, because both syntax and semantics are captured by the translated metamodel, it is possible to check all consistency properties of the models. On the other hand, especially if applied to the large UML metamodel, scalability is a serious issue. Moreover, to perform a complete consistency check, developers are forced to use the PVS translation. This creates tremendous issues for the maintainability of large models, especially because the PVS translations cannot be kept from the developer as it is necessary to manually intervene in the verification effort.

Дві інші методології, що використовують трансляційні підходи, представлені Paige et al. [37]. Вони поділяють ту саму ідею перекладу метамоделі мови моделювання на формальну мову, що підтримується інструментами перевірки. Потім кожна модель — замість того, щоб виражатися оригінальною мовою моделювання — перекладається на цільову мову. Мова моделювання, що використовується, це бізнес-орієнтована нотація (BON); однак UML також може підтримуватися. Насправді семантика мови моделювання повністю визначається метамоделлю, вираженою в новому формалізмі. Два підходи в Ref. [37] відрізняються цільовою мовою. Перший підхід перетворює моделі та метамоделі в систему перевірки прототипів (PVS), мову перевірки теорем, яка підтримує напівавтоматичні докази. Другий використовує Eiffel як мову перекладу. Eiffel є об’єктно-орієнтованим і підтримує анотації для визначення попередніх умов методу, постумов та інваріантів класу. З іншого боку, переклад у PVS є більш гнучким із двох підходів, оскільки він може кодувати всі деталі метамоделей і перевірки є повними. Обмеженням PVS є складність переведених моделей і той факт, що він вимагає ручного втручання в процес перевірки. З іншого боку, Eiffel є мовою програмування, і «перевірки» виконуються шляхом тестування, яке можна автоматизувати, але результати не є повними. Загальна перевага цього типу підходів полягає в тому, що, оскільки і синтаксис, і семантика фіксуються метамоделлю, що перекладається, можна перевірити всі властивості узгодженості моделей. З іншого боку, особливо у застосуванні до великої метамоделі UML, масштабованість є серйозною проблемою. Крім того, щоб виконати повну перевірку узгодженості, розробники змушені використовувати переклад PVS. Це створює величезні проблеми для ремонтопридатності великих моделей, особливо через те, що переклади PVS неможливо приховати від розробника, оскільки необхідно вручну втручатися в роботу перевірки.

From this comparison we see that addressing consistency for a large standard such as the UML is very difficult—even more so when fundamental modeling concepts such as time are not inherent language concepts but are bolted on using profiles and stereotypes. In the following section, we will present an alternative solution to the consistency management of the UML.

З цього порівняння ми бачимо, що вирішення узгодженості для великого стандарту, такого як UML, є дуже складним — навіть більше, коли фундаментальні концепції моделювання, такі як час, не є властивими концепціям мови, а кріпляться за допомогою профілів і стереотипів. У наступному розділі ми представимо альтернативне рішення для управління узгодженістю UML.

[12.1 <--- ](12_1.md) [   Зміст   ](README.md) [--> 12.3](12_3.md)