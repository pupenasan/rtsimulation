[12.1 <--- ](12_1.md) [   Зміст   ](README.md) [--> 12.3](12_3.md)

## 12.2. STATE OF THE ART IN CONSISTENCY AND SEMANTICS

In this section, we analyze the details of the UML consistency problem and its relation with the UML semantics. We discuss alternative solutions proposed in the research literature. The solutions presented address three specific problems related to UML consistency: (1) verifying the consistency of different views of the same system, (2) giving a complete and consistent semantics to UML diagrams, and (3) integrating models of different subsystems into a coherent, implementable model of the system.

In the following, we present a set of requirements we use to evaluate approaches to UML consistency. We identified these requirements by surveying the literature



**296**                                       Real-Time Simulation Technologies

 

and analyzing strengths and weaknesses of each approach proposed. Although each requirement is fulfilled by at least a few approaches, none of the approaches we sur- veyed performs well in all the areas. Thus, we use these requirements as a tool for comparing the different approaches proposed by different researchers and to iden- tify areas that can be improved. In Section 12.3, we propose an approach that can address all requirements by leveraging different ideas surveyed in our state of the art overview.

 

**12.1.1**           **uMl M****odel** **C****onsistenCy** **R****equiReMents**

We have identified 12 important requirements (collected in Table 12.1) by analyzing the requirements discussed in the literature for current approaches to model consis- tency. Requirements R1 to R3 in Table 12.1 originate from the observation that any strategy to manage model consistency should not limit the freedom of developers. This entails that developers should be allowed to modify models even if they intro- duce some inconsistencies. This idea is introduced in Finkelstein et al. [10], where the authors observe that inconsistency is necessary and often desirable in some phase of the development cycle. For example, in the inception phase of a large project with different stakeholders involved, each stakeholder pursues different goals and, during the collection of requirements, this can lead to inconsistent views that must be identified and reconciled in subsequent iterations. Other arguments in support of Requirements R1 to R3 have been documented elsewhere [11–13]. The common denominator of all arguments is that effective modeling techniques must support decomposing the problem into independent subproblems. This is the case when in

 

​     

**TABLE** **12.1**

**Requirements** **for** **UML** **Consistency** **Management**

**Requirement** **Description**

R1      *Inconsistent* models can be *introduced and kept in the system* specification for a certain amount of time

R2      *Inconsistencies* should be *discovered automatically and tracked* during the evolution of model

R3      Support should be provided to the developer to *resolve inconsistencies when convenient*

R4      Support *multiple* modeling *languages* (for example, different UML notations or even non-UML languages)

R5      Support *different levels* of abstraction

R6      Support the *extension or specialization* of languages R7      Support *horizontal* consistency

R8      Support *vertical* consistency

R9      Support *static* consistency R10       Support *dynamic* consistency

R11     *Tool* support (or translations to available tools) R12 *Scalability* to large models

​        



Consistency Management of UML Models                          **297**

 

order to solve complex problems, engineers decompose various aspects of the system and reason about each aspect in isolation. Alternatively, this occurs when in order to solve complex problems efficiently, different teams work in parallel on different aspects of the system.

A second observation is that each model caters to different needs that arise during the development process. For example, informal models are used to gather require- ments and exchange ideas between stakeholders and developers during requirements gathering [14]. Later in the development process, more formal models are used to describe the structure or the behavior of certain parts of the system. In this phase, formal models are used to verify properties of a system or to generate part of the implementation code. This second observation is the source of the additional require- ments R4 to R6 in [Table 12.1](#_bookmark70).

To evaluate consistency management techniques, the notion of consistency must be clearly defined. The scientific literature examines different notions of consistency. A distinction can be made between *horizontal* and *vertical* consistencies [15,16]. *Horizontal* consistency involves different perspectives on the same system model. For example, on the one hand, to describe the communication between a client and a server, it is possible to use a UML sequence diagram to capture the protocol and a state diagram to capture the server behavior. The two diagrams are different views on the same system and should be horizontally consistent. On the other hand, *verti- cal* consistency addresses views of the same aspect of one system, but at different levels of abstraction, often in relation to the evolution of one model during different phases of the development process. For example, an abstract model created during requirements gathering must agree with a more detailed model used for code gen- eration in a later step of the development process. Another important distinction is between *static* and *dynamic* consistency [17]. *Static* consistency addresses syntacti- cal and structural model dependencies, whereas *dynamic* consistency ensures the consistency of executable models. We introduce four requirements (R7 to R10 in Table 12.1) to capture these four notions of consistency.

The final two requirements address practical use of consistency management techniques. Requirement R11 recognizes that consistency checking must be sup- ported by a tool chain. Requirement R12 recognizes that industrial systems are large scale and this implies they have large system models. Therefore, scalability of the chosen technique to large models is an important requirement.

 

**12.1.2**           **C****onsistenCy** **C****heCking**

In the literature, a number of promising approaches for model consistency check- ing exist. The existing approaches can be divided into two categories: rule-based approaches and translation-based approaches. The first category uses rule-based systems to define consistency rules directly on the modeling language. In general, rule-based approaches scale well to large models but are limited to addressing only *static* consistency (failing requirement R10). On the other hand, translation-based approaches leverage a target language with a formal semantics and translate models into this language. Tools that support automated reasoning or formal verification in the target language can be used to reason about the consistency of the original



**298**                                       Real-Time Simulation Technologies

 

models. Translation-based approaches can address both *static* and *dynamic* consis- tencies; however, they have very limited scalability and tend to be restricted to a subset of the UML languages (failing requirement R4).

Rule-based approaches translate a modeling language into a logic framework on which the system of rules is defined. The goal of the translation is to be able to apply rules defined on a logic framework. This translation does not aim at defining a formal semantics for the modeling language and does usually limit the expressive- ness of consistency rules to structural elements of the language. On the other hand, translation-based approaches leverage languages with formal semantics and the translation process implies the definition of a formal semantics for the UML. These approaches enable reasoning about consistency of behavioral models but tend to work only on subsets of UML and impose the resolution of variation points. Because translation-based approaches are closely related to the problem of defining a formal semantics for UML, we discuss them further in the Subsection 12.2.3.

[Table 12.2 ](#_bookmark71)summarizes the approaches to consistency that we discuss in this sec- tion. Each requirement we identified in the previous section is a column of the table, whereas each of the approaches we discuss here is represented as a row. This sec- tion and Table 12.2 cover consistency management approaches that use rule-based systems; a second table in the next section covers approaches that use translation to formal languages. These approaches are important to know, especially if you want to understand the fundamental issues with consistency arising from the flexible, but complex, UML metamodel. Additional consistency problems, such as timing con- sistency, arise when using profiles for real-time systems, such as MARTE. These problems are not directly addressed by any of the methodologies surveyed.

A logic framework for capturing models and rules has been proposed by Van Der Straeten et al. [18]. In this work, the authors propose the use of description logic (DL), which is less powerful than first-order logic, but is decidable. The approach, which targets a subset of the UML language, proposes to encode UML models and metamodels as well as consistency rules in DL. The focus of this appproach is on both software evolution (vertical consistency) and consistency between different views of the same specification (horizontal consistency). To this end, the UML metamodel is enhanced with classes capturing horizontal and vertical relations. This approach is used, for example, to support model refactoring in [19], which documents how the RACER tool is used to enable inference from the DL knowledge bases. The transla- tion between UML and DL is performed by the RACOoN tool, which enables refac- toring and is integrated into the Poseidon UML modeling tool.

Sabetzadeh and Easterbrook [20] present a requirements merging approach based on category theory. The approach aims at merging inconsistent and incomplete views. Views are expressed as graphs, and relations between views are expressed by an interconnection diagram that relates common elements of different views. A colimit operation on the views combined with the interconnection diagram return the integrated view. To address inconsistencies, the methodology supports annotat- ing elements of the graphs to identify where inconsistencies stem from. Annotations are captured via a knowledge lattice that identifies proposed, repudiated, affirmed, and disputed elements. The article, however, does not discuss how this technique can be applied to address the consistency of views expressed in different languages.



​            

|      |                                                              |
| ---- | ------------------------------------------------------------ |
|      | ![Підпис: Consistency Management of UML Models](file:///C:/Users/OLEKSA~1/AppData/Local/Temp/msohtmlclip1/01/clip_image001.png) |
|      |                                                              |
|      | ![Підпис: 299](file:///C:/Users/OLEKSA~1/AppData/Local/Temp/msohtmlclip1/01/clip_image002.png) |

 



 

 

 

 

 



| **TABLE** **12.2**  **Evaluation** **of** **Consistency** **Checking** **Approaches** **Based** **on** **Rule** **Systems** |                                                              |        |        |        |        |        |        |        |        |        |         |         |         |
| ------------------------------------------------------------ | ------------------------------------------------------------ | ------ | ------ | ------ | ------ | ------ | ------ | ------ | ------ | ------ | ------- | ------- | ------- |
|                                                              | **Rules Specification Language**                             | **R1** | **R2** | **R3** | **R4** | **R5** | **R6** | **R7** | **R8** | **R9** | **R10** | **R11** | **R12** |
| Van Der Straeten et al. [18],  Van Der Straeten and D’Hondt [19] | Description logic                                            | ⨯      | ⨯      | ⨯      | ✓      | ⨯      | ⨯      | ✓      | ✓      | ✓      | ⨯       | ✓       | ?       |
| Sabetzadeh and Easterbrook [20]                              | Interconnection diagram describes relations between  views, a knowledge lattice captures additional information on each element | ✓      | ⨯      | ⨯      | ⨯      | ⨯      | ✓      | ✓      | ✓      | ✓      | ?       | ✓       | ?       |
| Nentwich et  al. [21]                                        | Rules  expressed in a reduced first-order logic, XPATH expressions identify where to apply them | ✓      | ⨯      | ⨯      | ✓      | ✓      | ⨯      | ✓      | ⨯      | ✓      | ⨯       | ✓       | ⨯       |
| Engels et al.  [22]                                          | Dynamic metamodeling (rules  defined on the UML metamodel)   | ✓      | ⨯      | ⨯      | ✓      | ✓      | ⨯      | ✓      | ⨯      | ✓      | ✓       | ✓       | ⨯       |
| Egyed [23,24]                                                | Rules are  stateless and deterministic                       | ✓      | ✓      | ✓      | ✓      | ✓      | ✓      | ✓      | ⨯      | ✓      | ⨯       | ✓       | ✓       |
| *Note:* The symbol ✓ indicates  that the requirement is met, the symbol ⨯ indicates that the requirement is not  met, and the symbol ? indicates that it is not clear from the literature if and to which degree the  requirement is met. |                                                              |        |        |        |        |        |        |        |        |        |         |         |         |



**300**                                       Real-Time Simulation Technologies

 

Other approaches proposed in the literature define consistency rules on mod- els represented by XML documents. These approaches can be adapted to work on XML representations of UML models serialized in the XML Metadata Interchange (XMI®) [25] interchange format. For example, a general XML-based consistency checking tool called xlinkit has been used to verify structural consistency; Nentwich et al. [21] present the tool, an incremental algorithm for checking, and a case study. To make rules decidable, they are based on a restricted version of first-order logic. The tool can check XML documents or other types of models by using a “fetcher” that reads the code and creates an in-memory Document Object Model (DOM) from it. Then, xlinkit uses XPATH (a query language for DOM) to specify the parts of the memory model where the rules must be applied. As a result of the rules evalu- ation, a set of links between conflicting elements is created. This enables the user to navigate the model and resolve inconsistencies without forcing the immediate resolution of every inconsistency. To improve scalability, an incremental algorithm is used to detect which rules have to be rechecked after a change. However, once the tool decides that a rule must be reevaluated, it is reevaluated on the entire model. As a result, when complex rules (such as the language constraints defined by the UML standard) have to be reevaluated, the benefits of this incremental algorithm are lim- ited. The authors claim that the cause of this drawback is the complexity of the XMI representation. The benefits of this technique are the independence from a specific modeling tool (XMI is an interchange standard supported by many tools) and the possibility of distributing the documents over the Internet. Major limitations are the fact that only structural consistency is addressed and that different rule evaluation orders can lead to different results. Moreover, XMI is not interpreted consistently by different tools. Therefore, it is not functioning as an interchange language in practice and consistency checking results could also be influenced by the tool chosen for creating the XMI file.

Other approaches define rules at the UML metamodel level instead of choosing a specific UML representation, such as the XML-based approaches of the previous paragraph. For example, Engels et al. [22] present an approach based on dynamic metamodeling (DMM). Rules are defined on the graphical representation of the UML metamodel using an extended class diagram notation. The extensions include the abil- ity to annotate elements of the metamodel with *new* and *delete* keywords. These key- words specify that the corresponding elements are respectively created or removed when the configuration captured by the metamodel is instantiated. The verification of consistency is then performed by testing. Overlapping models are verified in pairs where one is executed according to the DMM semantics, whereas the other is checked to identify violations. This approach has the great benefit of using a graphical model with which UML users are familiar. Drawbacks are that many rules must be defined for UML and that testing is not complete. In particular, the paper does not discuss any form of coverage metric to assess the confidence in the verification process.

Other approaches extend modeling tools. For example, Egyed [23,24] presents an extension to the Rational Rose tool. This extension, which is based on an algorithm presented in Ref. [26] by the same author, supports incremental consistency check- ing by using stateless deterministic rules. The incremental rule checking algorithm can analyze which part of the model is accessed during the evaluation of a rule and



Consistency Management of UML Models                         **301**

 

use the information to reevaluate rules only on the relevant portion of the model when changes happen. For each inconsistency identified, the tool creates an inconsis- tency annotation in a report. This tool is highly scalable and has been used on actual large models in industrial case studies.

 

**12.1.3**           **s****eMantiCs**

The second type of consistency checking approaches is closely related to the prob- lem of defining a formal semantics for UML languages. The research community has been very active in defining semantics for UML [27–31]. Broy et al. [29–31] give a formal model for UML based on stream semantics [32]. This approach bases the semantics on the elements of the UML metamodel and maps the UML to a formal model that closely matches each element of the metamodel itself. This results in a very complete semantic framework that formally captures every detail of the lan- guage, enabling the reasoning about every feature of the UML. However, for the goal of checking dynamic consistency of models, this framework is difficult to use. In fact, model checking tools are used to verify dynamic consistency. Because the translation to the formal model suggested by Broy et al. [29–31] contains all details of the UML, the state space of the models tends to be very large and properties are difficult to verify. Other work by Krüger and Menarini [28] proposes to map each diagram element to a very simple domain model specifically developed for the appli- cation domain the model is describing. This simplifies the automatic reasoning about the model properties but loses details about the language. In general, to use the UML and provide a formal semantics, the variation points are resolved and a profile is cre- ated to match the modeling needs.

Translation-based approaches for consistency management have been pursued by various authors. Instead of defining consistency rules based on the source models, they translate models into various formal languages and logics. The consistency is then implied by contradiction in the semantics of the target language. One of the main benefits of such approaches is that the translation to the target formal lan- guage defines the semantics of behavioral models. Therefore, on the one hand, all approaches following this avenue support reasoning about dynamic consistency. On the other hand, because in the translation the mapping to the original model can be lost, such approaches have greater difficulty in dealing with syntactic and structural rules required by static consistency.

[Table 12.3](#_bookmark72) summarizes the consistency approaches discussed in this section. These approaches are all based on giving a formal semantics to UML by providing a translation to some formal language.

An example of an approach that involves translation is presented by Easterbrook and Chechik [33]. They use the Xbel framework to reason about state machines encoding inconsistent multiview requirements. The approach proceeds as follows. First, multiple state-machine views are merged into a single state machine. Because views can be inconsistent, the system is based on a multivalued logic called quasi- Boolean logic. Next, a multivalued model checker (called Xchek) is used to verify temporal properties expressed in XCTL (an extension of computation tree logic [38]). Translating state machines into their multivalued logic counterparts enables the



​         

|      |                                                              |
| ---- | ------------------------------------------------------------ |
|      | ![Підпис: 302](file:///C:/Users/OLEKSA~1/AppData/Local/Temp/msohtmlclip1/01/clip_image003.png) |
|      |                                                              |
|      | ![Підпис: Real-Time Simulation Technologies](file:///C:/Users/OLEKSA~1/AppData/Local/Temp/msohtmlclip1/01/clip_image004.png) |

 



 

 

 

 

 

 



| **TABLE** **12.3**  **Evaluation** **of** **Consistency** **Checking** **Approaches** **Based** **on** **Translation** **to** **a** **Different** **Semantics** |                                                              |        |        |        |        |        |        |        |        |        |         |         |         |
| ------------------------------------------------------------ | ------------------------------------------------------------ | ------ | ------ | ------ | ------ | ------ | ------ | ------ | ------ | ------ | ------- | ------- | ------- |
|                                                              | **Translation** **Target** **Language**                      | **R1** | **R2** | **R3** | **R4** | **R5** | **R6** | **R7** | **R8** | **R9** | **R10** | **R11** | **R12** |
| Easterbrook and Chechik  [33]                                | State machines in multivalued quasi-Boolean logic            | ✓      | ✓      | ⨯      | ⨯      | ⨯      | ⨯      | ✓      | ⨯      | ✓      | ✓       | ✓       | ⨯       |
| Inverardi et al. [34]                                        | State machines encoded in Promela, sequence diagrams encoded in linear temporal logic | ⨯      | ⨯      | ⨯      | ⨯      | ⨯      | ⨯      | ✓      | ⨯      | ⨯      | ✓       | ✓       | ⨯       |
| Ossami et al.  [35]                                          | Translate UML to B                                           | ⨯      | ⨯      | ⨯      | ⨯      | ⨯      | ⨯      | ✓      | ?      | ?      | ✓       | ✓       | ⨯       |
| Engels et al.  [36]                                          | Communicating  Sequential Processes                          | ⨯      | ⨯      | ⨯      | ⨯      | ⨯      | ⨯      | ✓      | ✓      | ✓      | ✓       | ?       | ⨯       |
| Paige et al. [37]                                            | Prototype Verification System or Eiffel                      | ⨯      | ⨯      | ⨯      | ⨯      | ⨯      | ⨯      | ✓      | ✓      | ✓      | ✓       | ?       | ⨯       |
| *Note:* The symbol ✓ indicates  that the requirement is met, the symbol ⨯ indicates that the requirement is not  met, and the symbol ? indicates that it is not clear from the literature if and to which degree the  requirement is met. |                                                              |        |        |        |        |        |        |        |        |        |         |         |         |



Consistency Management of UML Models                         **303**

 

merger of inconsistent and incomplete models. The Xchek model checker enables the analysis of how inconsistencies affect the execution behavior of the state machines and helps in resolving them.

Inverardi et al. [34] use the SPIN [39] model checker to verify consistency of the behavior expressed by overlapping state machines and sequence diagrams. The approach uses Milner’s [40] Calculus of Communicating Systems notation to describe state machines and a stereotype of the UML for sequence diagrams. The paper proposes to translate state machines into Promela (the input language of the SPIN model checker) and to translate sequence diagrams into linear temporal logic (LTL) formulae. SPIN is used to verify consistency by checking that the Promela model satisfies the properties expressed by the LTL formulae. A tool called Charmy supports the creation of sequence diagrams and state machines while it also gener- ates the Promela code and the LTL formulae for verification.

A different solution to consistency checking is proposed by Ossami et al. [35]. The semantics of the UML is formalized by using the B [41] language. This enables developers to verify properties of their systems by using the verification tools sup- porting B. However, often a developer must modify the B specification to complete the proof. In this case, the two views of the system (UML and B) can become incon- sistent. The solution proposed by the authors is to create development operators that map each requested transformation in one domain to equivalent transformations in the other. Therefore, once the correctness of the development operator is proven, it can be applied many times without introducing any inconsistency. This construc- tive approach has the benefit of reducing the amount of verification to perform. On the other hand, the developer is limited by the existing operators in how to modify the model because the solution does not allow consistency to be broken at any time. The approach of creating development operators is useful in the specific application domain; however, it is not applicable in development processes where inconsisten- cies are tolerated.

Engels et al. [36] present a translational approach to reasoning about the consistency of UML behavioral models. The approach is used for UML protocol statecharts. In particular, the approach is demonstrated in presence of the inheritance of classes whose protocol behavior is defined by statecharts. Inheritance imposes a refinement relation between statecharts. The paper focuses on vertical consistency, but the same technique addresses horizontal consistency as well. The target language for the trans- lation is Communicating Sequential Processes (CSP) [42]. Rules are defined on the UML metamodel, which defines the UML graphical syntax used to translate the graphical models into the CSP textual notation. Then a tool called FDR (for Failures- Divergence Refinement) is used to verify the refinement relation in CSP.

Two other methodologies making use of translational approaches are presented by Paige et al. [37]. They share the same idea of translating the metamodel of the modeling language into a formal language supported by verification tools. Then each model—instead of being expressed in the original modeling language—is translated into the target language. The modeling language used is Business Oriented Notation (BON); however, UML could be supported as well. In fact, the semantics of the modeling language are completely defined by the metamodel expressed in the new formalism. The two approaches in Ref. [37] differ in the target language. The first



**304**                                       Real-Time Simulation Technologies

 

approach translates models and metamodels into Prototype Verification System (PVS), a theorem prover language that supports semiautomatic proofs. The second uses Eiffel as a target language. Eiffel is object oriented and supports annotations to define method preconditions, postconditions, and class invariants. On the other hand, translation into PVS is the more flexible of the two approaches as it can encode all details of the metamodels and the verifications are complete. The limitation of PVS is the complexity of the translated models and the fact that it requires manual intervention in the verification process. On the other hand, Eiffel is a programming language and the “verifications” are performed by testing, which can be automated but the results are not complete. The general benefit of this type of approaches is that, because both syntax and semantics are captured by the translated metamodel, it is possible to check all consistency properties of the models. On the other hand, especially if applied to the large UML metamodel, scalability is a serious issue. Moreover, to perform a complete consistency check, developers are forced to use the PVS translation. This creates tremendous issues for the maintainability of large models, especially because the PVS translations cannot be kept from the developer as it is necessary to manually intervene in the verification effort.

From this comparison we see that addressing consistency for a large standard such as the UML is very difficult—even more so when fundamental modeling con- cepts such as time are not inherent language concepts but are bolted on using profiles and stereotypes. In the following section, we will present an alternative solution to the consistency management of the UML.

[12.1 <--- ](12_1.md) [   Зміст   ](README.md) [--> 12.3](12_3.md)