[3.3 <--- ](3_3.md) [   Зміст   ](README.md) [--> 3.5](3_5.md)

## 3.4. ПРИКЛАД ДОСЛІДЖЕННЯ: КОНТРОЛЕР ДЛЯ РОБОТИЗОВАНОГО ЗАСТОСУНКУ E-PUCK

In this section, we present a case study where we use DEVS to build a model of a controller for an E-puck robot and later the same model is used as an actual controller. The E-puck (shown in [Figure 3.10](#_bookmark18)) is a desktop-size mobile robot with a wide range of possibilities (signal processing, autonomous control, embedded programming, etc.). The E-puck contains various sensors covering different modalities: (i) eight infrared (IR) proximity sensors placed around the body measure the closeness of obstacles, (ii) a 3D accelerometer provides the acceleration vector of the E-puck, (iii)  three microphones to capture sound, and (iv) a color CMOS (Complementary Metal Oxide Semiconductor) camera with a resolution of 640 × 480 pixels. It also includes the following actuators: (i) two stepper motors, making it capable of moving forward and backward, and spinning in both directions; (ii) a speaker, connected to an audio codec; (iii) eight red light-emitting diodes (LED) placed all around the top; and (iv) a red front LED placed beside the camera.

У цьому розділі ми представляємо практичний приклад, у якому ми використовуємо DEVS для побудови моделі контролера для робота E-puck, а пізніше ця модель використовується як фактичний контролер. E-puck (показано на Рис. 3.10) — це настільний мобільний робот із широким спектром можливостей (обробка сигналів, автономне керування, вбудоване програмування тощо). E-puck містить різні датчики, що охоплюють різні модальності: (i) вісім інфрачервоних (ІЧ) датчиків наближення, розміщених навколо тіла, вимірюють близькість до перешкод, (ii) 3D-акселерометр забезпечує вектор прискорення E-puck, (iii) три мікрофони для захоплення звуку та (iv) кольорова CMOS (комплементарна металево-оксидна напівпровідникова камера) з роздільною здатністю 640 × 480 пікселів. Він також включає в себе такі приводи: (i) два крокові двигуни, завдяки яким він може рухатися вперед і назад і обертатися в обох напрямках; (ii) динамік, підключений до аудіокодека; (iii) вісім червоних світлодіодів (LED), розташованих навколо верху; та (iv) червоний передній світлодіод, розміщений поруч із камерою.

 ![image-20220819234303612](media/image-20220819234303612.png)

**FIGURE** **3.10** E-puck robot. **МАЛЮНОК** **3.10** Робот E-puck.

In the following sections, we introduce a DEVS model for a simple controller for the E-puck, the corresponding implementation in CD++, and the formal verification of different properties of the model through the transformation introduced in Section 3.4 combined with the use of the UPPAL model checker.

У наступних розділах ми представляємо модель DEVS для простого контролера для E-puck, відповідну реалізацію в CD++ і формальну перевірку різних властивостей моделі через перетворення, представлене в Розділі 3.4, у поєднанні з використанням UPPAL перевірка моделі.

### 3.4.1 Специфікація моделі DEVS

The controller is designed to steer the robot in a field while avoiding obstacles. We have defined a DEVS model with an atomic component (*epuck0*) that imitates the behavior of the controller, shown in [Figure 3.11](#_bookmark19). There are eight input ports (*InIR0*, … *InIR7*), each of them modeling the connection to one proximity sensor. The input ports periodically receive the distances to the obstacles from the sensors. There are also two output ports: *OutMotor*, which transfers the output commands to the motors, and *OutLED*, to turn on/off the LEDs.

Контролер призначений для керування роботом у полі, уникаючи перешкод. Ми визначили модель DEVS з атомарним компонентом (*epuck0*), який імітує поведінку контролера, показану на Рис. 3.11. Існує вісім вхідних портів (*InIR0*, … *InIR7*), кожен з яких моделює підключення до одного датчика наближення. Вхідні порти періодично отримують від датчиків відстань до перешкод. Також є два вихідних порти: *OutMotor*, який передає вихідні команди на двигуни, і *OutLED*, щоб увімкнути/вимкнути світлодіоди.

The controller can command the following actions based on the inputs received from the sensors: *move forward*, *turn 45 degrees left*, *turn 45 degrees right*, *turn 90 degrees left*, *turn 90 degrees right*, *turn 180 degrees*, and *stop*. Initially, the robot starts moving forward while receiving the periodic inputs from proximity sensors and analyzing them. As soon as it detects an obstacle, it performs one of the turning actions based on the position of the obstacle. The robot continues turning until it finds an empty space ahead. The controller also uses LEDs to signal the action that is being performed. For example, if the robot is moving forward, the front LED (*led0*) turns on and if it is turning 45 degrees to the left, *led7* turns on. [Figure 3.12 ](#_bookmark19)illustrates two sample imaginary scenarios in which obstacles block the robot’s path.

Контролер може керувати наступними діями на основі вхідних даних, отриманих від датчиків: *рух вперед*, *поворот на 45 градусів ліворуч*, *поворот на 45 градусів праворуч*, *поворот на 90 градусів ліворуч*, *поворот на 90 градусів праворуч*, *поверніться на 180 градусів* і *зупиніться*. Спочатку робот починає рухатися вперед, отримуючи періодичні вхідні дані від датчиків наближення та аналізуючи їх. Як тільки він виявляє перешкоду, він виконує одну з дій повороту на основі положення перешкоди. Робот продовжує обертатися, поки не знайде порожній простір попереду. Контролер також використовує світлодіоди для сигналізації про дію, яка виконується. Наприклад, якщо робот рухається вперед, вмикається передній світлодіод (*led0*), а якщо він повертається на 45 градусів ліворуч, вмикається *led7*. Малюнок 3.12 ілюструє два приклади уявних сценаріїв, у яких перешкоди блокують шлях робота.

![image-20220819234423986](media/image-20220819234423986.png)

**FIGURE 3.11** E-puck controller DEVS model hierarchy. **МАЛЮНОК 3.11** Ієрархія моделі DEVS контролера E-puck.

 ![image-20220819234451729](media/image-20220819234451729.png)  

**FIGURE 3.12** (a) Scenario 1: front-left blocked. (b) Scenario 2: front completely blocked. **МАЛЮНОК 3.12** (a) Сценарій 1: передня ліва сторона заблокована. (b) Сценарій 2: фронт повністю заблокований.

The DEVS formal specification of the epuck0 atomic component is as follows:

Формальна специфікація DEVS атомарного компонента epuck0 така:

![image-20220819234530470](media/image-20220819234530470.png)

 ![image-20220819234546586](media/image-20220819234546586.png) 

Table 3.5 summarizes the integer outputs of the DEVS model and their associated actions to be performed in the robot hardware. The driver interface programmed by the user transforms the numeric values to actions in the robot.

Таблиця 3.5 підсумовує цілочисельні виходи моделі DEVS та пов’язані з ними дії, які мають бути виконані в апаратному забезпеченні робота. Запрограмований користувачем інтерфейс драйвера перетворює числові значення на дії в роботі.

Figure 3.13 illustrates an abstract state diagram of the *epuck0* atomic component. The DEVS graph state diagram summarizes the behavior of a DEVS atomic component by representing the states, transitions, inputs, outputs, and state durations graphically. As we can see, initially, the robot moves forward and if no obstacle is detected from *IR0*, *IR1*, *IR6*, and *IR7* (the four sensors scanning the front direction, as seen in Figure 3.12, it continues moving forward. As soon as an obstacle is detected, the value of the sensor *IR6* is examined. If this sensor shows no obstacle, the left corner of the robot is open resulting in a 45° turn toward the left. Otherwise, it checks *IR1*, and if there is space, the robot turns 45° to the right. If both *IR1* and *IR6* are blocked, the controller examines *IR2*; if there is space, the robot performs a 90° turn to the left. The same occurs with *IR2*. If all sensors are blocked, the robot tries turning to the opposite direction (180°).

Рисунок 3.13 ілюструє абстрактну діаграму стану атомного компонента *epuck0*. Діаграма стану графа DEVS узагальнює поведінку атомарного компонента DEVS, представляючи стани, переходи, входи, виходи та тривалість станів у графічному вигляді. Як ми бачимо, спочатку робот рухається вперед, і якщо з *IR0*, *IR1*, *IR6* і *IR7* (чотири датчики, які сканують спереду, як показано на малюнку 3.12), він не виявляє перешкоди. продовжує рух вперед. Щойно перешкода виявлена, перевіряється значення датчика *IR6*. Якщо цей датчик не показує перешкоди, лівий кут робота відкритий, що призводить до повороту на 45° ліворуч. В іншому випадку, він перевіряє *IR1*, і якщо є вільне місце, робот повертається на 45° вправо. Якщо *IR1* і *IR6* заблоковані, контролер перевіряє *IR2*; якщо є вільне місце, робот виконує 90 ° поворот ліворуч Те ж саме відбувається з *IR2* Якщо всі датчики заблоковані, робот намагається повернутись у протилежний бік (180°).

![image-20220819234647715](media/image-20220819234647715.png)  

**FIGURE 3.13** epuck0 atomic component state diagram. **МАЛЮНОК 3.13** Діаграма стану атомного компонента epuck0.

![image-20220819234707753](media/image-20220819234707753.png)

### 3.4.2 Реалізація на ECD++ Toolkit

To program a DEVS model on ECD++ [28,10], three main components are necessary.

1.   A model file in which the model hierarchy, model components, input and output ports of each component and input/output couplings are declared. The model file is passed to the ECD++ executable file as a runtime argument, and the latter instantiates the model components based on the declarations in the model file.

2.   Source files of the model components. For each atomic component, a C++ class is defined, and the external and internal transitions and the output function are programmed as methods of this class.

3.   A driver interface. A driver function is overridden by the user for each input or output port at the top level of the model hierarchy that is connected to a hardware counterpart. 

Для програмування моделі DEVS на ECD++ [28,10] необхідні три основні компоненти.

1. Файл моделі, в якому оголошено ієрархію моделі, компоненти моделі, вхідні та вихідні порти кожного компонента та зв’язки введення/виведення. Файл моделі передається у виконуваний файл ECD++ як аргумент часу виконання, а останній створює екземпляри компонентів моделі на основі оголошень у файлі моделі.

2. Вихідні файли компонентів моделі. Для кожного атомарного компонента визначається клас C++, а зовнішні та внутрішні переходи та функція виводу програмуються як методи цього класу.

3. Інтерфейс драйвера. Функція драйвера скасовується користувачем для кожного вхідного або вихідного порту на верхньому рівні ієрархії моделі, підключеного до апаратного аналога.

The ECD++ model file also contains information about the period of the input drivers and the duration of the states for each atomic component. In this example, we have tuned the input period of the IR sensors to 50 milliseconds. Therefore, for every 50 milliseconds, the external transition of the *epuck0* atomic component is invoked, and based on the updated values, the next action is decided. The following is the ECD++ model file of the e-puck robot controller model.

Файл моделі ECD++ також містить інформацію про період вхідних драйверів і тривалість станів для кожного атомарного компонента. У цьому прикладі ми налаштували вхідний період ІЧ-датчиків на 50 мілісекунд. Таким чином, кожні 50 мілісекунд викликається зовнішній перехід атомарного компонента *epuck0*, і на основі оновлених значень приймається рішення про наступну дію. Нижче наведено файл моделі ECD++ моделі контролера робота e-puck.

```
1 [top]
2 components : epuck0@epuck
3 out : outmotor outled
4 in : inir0 inir1 inir2 inir3 inir4 inir5 inir6 inir7
5 link : inir0 ir0@epuck0
6 link : inir1 ir1@epuck0
7 link : inir2 ir2@epuck0
8 link : inir3 ir3@epuck0
9 link : inir4 ir4@epuck0
10 link : inir5 ir5@epuck0
11 link : inir6 ir6@epuck0
12 link : inir7 ir7@epuck0
13 link : motor@epuck0 outmotor
14 link : led@epuck0 outled
15 inir0 : 00:00:00:100
16 inir1 : 00:00:00:100
17 inir2 : 00:00:00:100
18 inir3 : 00:00:00:100
19 inir4 : 00:00:00:100
20 inir5 : 00:00:00:100
21 inir6 : 00:00:00:100
22 inir7 : 00:00:00:100
23
24 [epuck0]
25 preparationTime : 00:00:00:000
26 turn45Time : 00:00:00:100
27 turn90Time : 00:00:00:700
28 turn180Time : 00:00:02:000
```

Line 1 defines the *top* coupled component and line 2 declares its components. Lines 3 and 4 declare the output and input ports within the *top* coupled component, respectively. Lines 6–14 define the internal couplings. Lines 15–22 declare the periods of each input port. Lines 24–27 declare the duration of states within the *epuck0* component.

Рядок 1 визначає пов’язаний компонент *top*, а рядок 2 оголошує його компоненти. Рядки 3 і 4 оголошують вихідний і вхідний порти в *верхньому* зв'язаному компоненті відповідно. Рядки 6–14 визначають внутрішні з’єднання. Рядки 15–22 оголошують періоди кожного вхідного порту. Рядки 24–27 оголошують тривалість станів у компоненті *epuck0*.

The external function performs the state transitions based on the DEVS graph diagram presented in Section 3.4.1. The following is the source code of the external transition function of *epuck0* atomic component.

Зовнішня функція виконує переходи між станами на основі графової діаграми DEVS, представленої в розділі 3.4.1. Нижче наведено вихідний код функції зовнішнього переходу атомарного компонента *epuck0*.

```c
1 if(state!=Mov_Fwd && IR0>0.04 && IR7>0.04 && IR1>0.02 && IR6>0.02){
2 } else if((state==Mov_Fwd)&&(IR0<0.05 || IR1< 0.02) && IR6>0.04){
3 	state = Pre_Trn_45_Lft;
4 	holdIn( Atomic::active, preparationTime );
5 }	else if((state==Trn_45_Lft)&&(IR0<0.05 || IR1<0.02) && IR6>0.04){
6 	state = Trn_45_Lft;
7 	holdIn( Atomic::active, turn45Time);
8 }	else if((state == Mov_Fwd)&& (IR6< 0.02 || IR7< 0.05) && IR1> 0.04){
9 	state = Pre_Trn_45_Rgt;
10 	holdIn( Atomic::active, preparationTime);
11 } else if((state==Trn_45_Rgt)&& (IR6< 0.02 || IR7< 0.05) && IR1> 0.04){
12 	state = Trn_45_Rgt;
13 	holdIn( Atomic::active, turn45Time);
14 } else if(state == Mov_Fwd && IR[0]< 0.05 && IR[7]< 0.05 && IR[2]> 0.04){
15 	state = Pre_Trn_90_Lft;
16 	holdIn( Atomic::active, preparationTime);
17 } else if(state == Mov_Fwd && IR[0]< 0.05 && IR[7]< 0.05 && IR[5]> 0.04){
18 	state = Pre_Trn_90_Rgt;
19 	holdIn(Atomic::active, preparationTime);
20 } else if(state!=Trn_180&&IR[0]<0.05&&IR[7]<0.05 && IR[2]<0.05 && IR[5]<0.05){
21 	state = Pre_Trn_180;
22 	holdIn( Atomic::active, preparationTime);
23 }
```

Line 1 shows the case when *moving forward* is the current state and there is no obstacle ahead. Line 2 manages the case when *IR0* or *IR1* (right side of the robot) is obstructed. In that case, the state of the robot is changed to *prepare turn 45° left* (line 3), and in line 4, the time duration of this state is set. The other cases and the state changes are also indicated in the above-mentioned code snippet. The internal transition function and the output function are similar. For instance, the following code snippet shows a part of the internal transition function:

Рядок 1 показує випадок, коли поточним станом є *рух вперед* і попереду немає перешкод. Рядок 2 керує випадком, коли *IR0* або *IR1* (правий бік робота) перешкоджає. У цьому випадку стан робота змінюється на *готуйте поворот на 45° ліворуч* (рядок 3), а в рядку 4 встановлюється тривалість цього стану. Інші випадки та зміни стану також вказано у згаданому вище фрагменті коду. Функція внутрішнього переходу та функція виведення подібні. Наприклад, наведений нижче фрагмент коду показує частину внутрішньої функції переходу:

```c
1 Model &epuck::internalFunction( const InternalMessage & )
2 {
3 	switch (state){
4 		case Pre_Mov_Fwd:
5 		case Trn_45_Lft:
6 		case Trn_45_Rgt:
7 		case Trn_90_Lft:
8 		case Trn_90_Rgt:
9 		case Trn_180:
10 			state = Mov_Fwd ;
11 			passivate();
12 			break;
13
14 		case Pre_Trn_45_Lft:
15 			state = Trn_45_Lft ;
16 			holdIn( Atomic::active, turn45Time );
17 			break;
18 …
```

Lines 4–9 show a part of the internal transition for the states *prepare move forward*, *turn 45° left*, *turn 45° right*, *turn 90° left*, *turn 90° right*, and *turn 180°*, after which the model continues to *move forward* (line 10). Line 14 shows the case for *prepare turn 45° left* state, after which the component transfers to *turn 45° left* state.

Рядки 4–9 показують частину внутрішнього переходу для станів *підготовка до руху вперед*, *поворот на 45° вліво*, *поворот на 45° вправо*, *поворот на 90° вліво*, *поворот на 90° вправо* та * поворот на 180°*, після чого модель продовжує *рух вперед* (рядок 10). Рядок 14 показує випадок для стану *підготовка до повороту на 45° ліворуч*, після чого компонент переходить у стан *поворот на 45° ліворуч*.

The following code snippet shows a part of the ECD++ output function (λ) implementation:

У наступному фрагменті коду показано частину реалізації функції виведення ECD++ (λ):

```
1 Model &epuck::outputFunction( const InternalMessage &msg )
2 {
3 switch (state){
4 case Pre_Mov_Fwd:
5 sendOutput( msg.time(), led, 100) ;//Turn all
Leds off
6 sendOutput( msg.time(), motor, 1) ;//Moving
Forward
7 sendOutput( msg.time(), led, 1) ;//Turn Led 0 on
8 break;
9
10 case Trn_45_Lft:
11 sendOutput( msg.time(), led, 70) ;//Turn Led 7
off
12 sendOutput( msg.time(), motor, 1) ;//Moving
Forward
13 sendOutput( msg.time(), led, 1) ;//Turn Led 0 on
14 break;
15 …
```

In this case, line 4 handles the outputs of state *prepare move forward* in which three different outputs are generated. Line 5 is the output command to turn off all LEDs. Line 6 shows the moving forward command sent to the *motor* port and line 7 is the command to turn *led0* on. These outputs are then decoded and converted by the corresponding drivers. Lines 9–13 show the outputs for the *turn 45° left* state where the *led7* is turned off first, then the motors are instructed to move forward and *led0* is turned on afterwards.

У цьому випадку рядок 4 обробляє виходи стану *prepare move forward*, у якому генеруються три різні виходи. Рядок 5 - це вихідна команда для вимкнення всіх світлодіодів. Рядок 6 показує команду руху вперед, надіслану до порту *motor*, а рядок 7 — це команда ввімкнути *led0*. Потім ці виходи декодуються та перетворюються відповідними драйверами. Рядки 9–13 показують вихідні дані для стану *повороту на 45° ліворуч*, де спочатку вимикається *led7*, потім двигуни отримують інструкцію рухатися вперед і після цього вмикається *led0*.

The following code snippet shows the driver interface function for the *OutMotor* output port of the *top* coupled component. The outputs generated in the output function for the *motor* port of the *epuck0* atomic component are inputted to this function as an integer argument and the respective hardware command is spawned here.

У наступному фрагменті коду показано функцію інтерфейсу драйвера для вихідного порту *OutMotor* верхнього* підключеного компонента. Виходи, згенеровані функцією виводу для порту *motor* атомарного компонента *epuck0*, вводяться в цю функцію як цілочисельний аргумент, і тут створюється відповідна апаратна команда.

```c
1 bool OutMotor::pDriver(Value &value)
2 {
3 switch((int)value){
4 case 0: //Stop
5 playerc_position2d_set_cmd_vel(position2d, 0, 0,
0, 1);
6 break;
7 case 1: //Moving Forward
8 playerc_position2d_set_cmd_vel(position2d, 1, 0,
0, 1);
9 break;
10 case 3: //Turn 45 deg. Right
11 case 4: //Turn 90 deg. Right
12 playerc_position2d_set_cmd_vel(position2d,
0,0,-10,1);
13 break;
14 case 2: //Turn 45 deg. Left
15 case 5: //Turn 90 deg. Left
16 case 6: //Turn 180 deg. (turn from left)
17 playerc_position2d_set_cmd_vel(position2d, 0, 0,
10,1);
18 break;
19 };
20 }
```

Lines 4–6 show the case of the stop command, which is encoded with value 0. Line 5 is the command to stop the robot. Lines 7–9 handle the moving forward output command and lines 10–13 manage the right turning commands. For both 45° and 90° turn actions, the robot starts spinning to the right, while the calibrated duration of the respective state accomplishes the desired degree of spinning. A more accurate approach to perform the turning actions would measure the spinning angle constantly and stop when the desired angle is reached.

Рядки 4–6 показують випадок команди зупинки, яка кодується значенням 0. Рядок 5 — команда зупинити робота. Рядки 7–9 керують командою виведення руху вперед, а рядки 10–13 керують командами повороту праворуч. Для повороту як на 45°, так і на 90° робот починає обертатися вправо, тоді як відкалібрована тривалість відповідного стану забезпечує бажаний ступінь обертання. Більш точний підхід до виконання дій повороту буде постійно вимірювати кут обертання та зупинятися, коли бажаний кут буде досягнутий.

### 3.4.3 Виконання моделей

The e-puck model was first tested using virtual-time simulation mode. We designed a virtual space with obstacles and ran the simulation with inputs supplied from an event file, in which two series of inputs to the sensors are defined. Figure 3.14

Модель електронної шайби вперше була протестована з використанням режиму симуляції віртуального часу. Ми розробили віртуальний простір із перешкодами та запустили моделювання з вхідними даними, отриманими з файлу подій, у якому визначено дві серії вхідних даних для датчиків. Малюнок 3.14

Turn all LEDS OFF Move forward shows the contents of the event file and output file of the ECD++ and the action associated with the outputs of the controller model. The event file is structured in the format of “time, input port and value” and in this example it consists of two series of events representing the two scenarios shown in [Figure 3.12](#_bookmark19). The first three lines of the output file are the initial outputs of the model that move the robot forward. After 4 seconds of simulation, the first series of inputs is injected into the model, which results in the second series of outputs. The latter spins the robot 45° to the right and performs the appropriate LED commands and after 100 milliseconds moves the robot forward again with the appropriate LED commands. A similar scenario happens for the second series of inputs at time 8 of simulation in which the robot turns 180°.

Вимкніть усі світлодіоди. Рух вперед показує вміст файлу подій і вихідного файлу ECD++ і дії, пов’язані з виходами моделі контролера. Файл подій структурований у форматі «час, вхідний порт і значення», і в цьому прикладі він складається з двох серій подій, що представляють два сценарії, показані на [Рис. 3.12] (#_bookmark19). Перші три рядки вихідного файлу є початковими виходами моделі, які рухають робота вперед. Після 4 секунд симуляції перша серія вхідних даних вводиться в модель, що призводить до другої серії виходів. Останній повертає робота на 45° праворуч і виконує відповідні світлодіодні команди, а через 100 мілісекунд знову переміщує робота вперед за допомогою відповідних світлодіодних команд. Подібний сценарій відбувається для другої серії вхідних даних під час 8 моделювання, під час якого робот повертається на 180°.

![image-20220819235251881](media/image-20220819235251881.png)

**FIGURE 3.14** Event file and output file of ECD++.

![image-20220819235327265](media/image-20220819235327265.png)

**FIGURE 3.15** Robot controller timed automata model. **МАЛЮНОК 3.15** Модель автомата з контролером робота.

After verifying the behavior of the model in various scenarios, we tested the model using the actual e-puck robot. The model was executed in RT mode in which the model interacts with the target platform (in this case, the robot hardware). The same behavior was observed and the robot found its way through the obstacles. The results can be seen at [http://youtube.com/arslab.](http://youtube.com/arslab)

Перевіривши поведінку моделі в різних сценаріях, ми перевірили модель за допомогою реального робота e-puck. Модель була виконана в режимі RT, в якому модель взаємодіє з цільовою платформою (в даному випадку апаратним забезпеченням робота). Така ж поведінка спостерігалася, і робот знайшов шлях через перешкоди. Результати можна переглянути на [http://youtube.com/arslab.](http://youtube.com/arslab)

https://www.youtube.com/watch?v=VoHP2kVH0Gg&list=PLFE5896224DACE52B

### 3.4.4 Верифікація моделі

To obtain a TA model that is behaviorally equivalent to the DEVS model shown in [Figure 3.13](#_bookmark20), we followed the procedure discussed in Sections 3.3 and 3.4. The equivalent TA is shown in Figure 3.15. In this model, the Boolean conditions of the DEVS state model were defined in functions in the TA model as shown in the following code snippet.

Щоб отримати модель TA, поведінково еквівалентну моделі DEVS, показаній на Рис. 3.13, ми дотримувалися процедури, описаної в Розділах 3.3 і 3.4. Еквівалент TA показаний на малюнку 3.15. У цій моделі булеві умови моделі стану DEVS були визначені у функціях моделі TA, як показано в наступному фрагменті коду.

```c
1 bool forward_clear(){return ir0>4 && ir7 >4 && ir1>2 && ir6>2;}
2 bool left_45_clear(){return (ir0<5 || ir1<2) && ir6>4;}
3 bool right_45_clear(){return (ir6>2 || ir7 <5) && ir1>4;}
4 bool backward_clear(){return ir0<5 && ir7 <5 && ir2<5 && ir5<5;}
5 bool right_90_clear(){return ir0<5 && ir7 <5 && ir5>4;}
6 bool left_90_clear(){return ir0<5 && ir7 <5 && ir2>4;}
```

In this TA model, Boolean functions constitute guards on the transitions that evaluate to true whenever the sensor values satisfy the condition given in the DEVS model. While the DEVS model of the robot-controller was tested and simulated with the real robot moving in a specific environment, to verify the robot-controller model, we built a closed system where this model interacts with other models representing the motor and the environment in which the robot travels.

У цій моделі TA булеві функції є захисними для переходів, які оцінюються як істинні щоразу, коли значення датчика задовольняють умови, задані в моделі DEVS. У той час як DEVS-модель робота-контролера була протестована та змодельована за допомогою реального робота, що рухається в певному середовищі, щоб перевірити модель робота-контролера, ми створили закриту систему, де ця модель взаємодіє з іншими моделями, що представляють двигун і середовище в яким рухається робот.

Figure 3.16 shows the TA model of the motor. This model represents the motor states, starting in *Preparing_To_Move_Forward.* It then synchronizes the motor model with the controller model through the *move_motor* channel. The motor model shows six states that the motor can visit depending on the value of the shared variable *motor*, which is updated by the Robot Controller model.

На малюнку 3.16 показана ТА модель двигуна. Ця модель представляє стани двигуна, починаючи з *Preparing_To_Move_Forward.* Потім вона синхронізує модель двигуна з моделлю контролера через канал *move_motor*. Модель двигуна показує шість станів, які може відвідувати двигун залежно від значення спільної змінної *motor*, яке оновлюється моделлю контролера робота.

In [Figure 3.17](#_bookmark22), a simple model of the environment in which the robot may travel is shown. This model represents an environment that looks like a contoured closed layout. This layout was modeled in TA by the values assigned to different sensors on the robot *ir0*, *ir1*, *…* , *ir7*. These values are also shown in the event file used to test the robot DEVS model.

На Рис. 3.17 показана проста модель середовища, в якому може подорожувати робот. Ця модель представляє середовище, яке виглядає як контурний замкнутий макет. Цей макет був змодельований у TA за допомогою значень, призначених різним датчикам на роботі *ir0*, *ir1*, *…* , *ir7*. Ці значення також відображаються у файлі подій, який використовується для тестування моделі DEVS робота.

![image-20220819235513560](media/image-20220819235513560.png) 

**FIGURE 3.16** Motor timed automata model. **МАЛЮНОК 3.16** Модель автомата з двигуном.

![image-20220819235540492](media/image-20220819235540492.png)

**FIGURE 3.17** Environment timed automata model. **МАЛЮНОК 3.17** Автоматична модель середовища.

![image-20220819235602830](media/image-20220819235602830.png)     

**FIGURE** **3.18** UPPAAL verification for deadlocks. **МАЛЮНОК** **3.18** Перевірка UPPAAL для взаємоблокувань.

The verification of the system composed of Robot-Controller, Motor, and Environment in the UPPAAL tool revealed that it is free of deadlocks as shown in Figure 3.18. This ensures the controller is always able to successfully guide the robot through the given layout.

Перевірка системи, що складається з контролера робота, двигуна та середовища в інструменті UPPAAL, показала, що в ній немає взаємоблокувань, як показано на малюнку 3.18. Це гарантує, що контролер завжди зможе успішно керувати роботом заданим макетом.

More complex layouts can also be modeled in TA to verify the system for more complicated behavior. For example, the TA environment model could be constructed to randomly assign values in reasonable range to the sensors. This would model generating arbitrary shaped obstacles around the robot. The verification for deadlock would then be executed to reveal if a deadlock is possible at any particular shape facing the robot. This would reveal either a fault in the robot-controller or the controller being too simple to handle irregular shapes facing the robot.

Більш складні макети також можна моделювати в TA, щоб перевірити систему на більш складну поведінку. Наприклад, модель середовища TA може бути побудована для випадкового призначення датчикам значень у прийнятному діапазоні. Це моделювало б створення перешкод довільної форми навколо робота. Потім буде виконано перевірку на тупикову блокування, щоб виявити, чи можлива тупикова блокування на будь-якій конкретній формі, яка стоїть перед роботом. Це виявить або несправність у контролері робота, або контролер занадто простий для керування неправильними формами, зверненими до робота.

![image-20220819235632561](media/image-20220819235632561.png) 

**FIGURE 3.19** Environment model with random sensor inputs. **МАЛЮНОК 3.19** Модель середовища з випадковими вхідними даними датчиків.

Another example of verification that we can explore with verification includes different kinds of environments for the robot controller. In this example, we would attempt to check if the controller may enter into a deadlock and stop progress. To do so, we modify the environment model to randomly generate different sensor readings that simulate the robot approach to the situation where there is variety in the environment. This modified environment model is shown in Figure 3.19. In this model, sensor *ir0* obtains a value in the range of [1,5], *ir1* a value in [1,10].

Ще один приклад верифікації, який ми можемо дослідити за допомогою верифікації, включає різні види середовища для контролера робота. У цьому прикладі ми спробуємо перевірити, чи може контролер увійти в тупик і зупинити прогрес. Для цього ми модифікуємо модель середовища для випадкового генерування різних показань датчиків, які імітують підхід робота до ситуації, коли середовище різноманітне. Ця модифікована модель середовища показана на малюнку 3.19. У цій моделі датчик *ir0* отримує значення в діапазоні [1,5], *ir1* значення в [1,10].

By checking the model for deadlock again, the UPPAAL tool would verify this property and give a trace if this property is violated. The trace comprises values shown in the following lines.

Знову перевіряючи модель на тупикову блокування, інструмент UPPAAL перевірить цю властивість і відстежить, якщо ця властивість порушена. Трасування містить значення, показані в наступних рядках.

```c
1 motor = 1
2 ir0 = 5
3 ir1 = 1
4 ir2 = 1
5 ir3 = 10
6 ir4 = 10
7 ir5 = 1
8 ir6 = 1
9 ir7 = 1
```

This shows that the current design for the robot controller would not handle this combination of sensor values. In this case, either the designer reevaluates the design to address the shortcoming or it may be stated as an assumption on the simple robot controller that this shortcoming is acceptable.

Це показує, що поточна конструкція контролера робота не впорається з такою комбінацією значень датчиків. У цьому випадку або розробник переоцінює конструкцію, щоб усунути недолік, або може бути заявлено як припущення на простому контролері робота, що цей недолік є прийнятним.

[3.3 <--- ](3_3.md) [   Зміст   ](README.md) [--> 3.5](3_5.md)

