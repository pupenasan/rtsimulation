[5.3 <--- ](5_3.md) [   Зміст   ](README.md) [--> 5.5](5_5.md)

## 5.4. UML EXTENSIONS FOR REAL TIME

In this section, we discuss various extensions of UML and then show details from the recent profile for MARTE. The extension mechanism in UML (see Section 5.3.3) allows the definition of families of languages targeted to specific domains and levels of abstractions.

У цьому розділі ми обговорюємо різні розширення UML, а потім показуємо деталі нещодавнього профілю MARTE. Механізм розширення в UML (див. Розділ 5.3.3) дозволяє визначати сімейства мов, націлені на певні домени та рівні абстракцій.

### 5.4.1 Overview of UML Profiles

The profile mechanism has been specifically defined for providing a lightweight extension mechanism to the UML standard via stereotypes, tagged values, and constraints as described in Section 5.3.3. For example, other work [34] presents a UML profile for a platform-based approach to embedded software development using stereotypes to represent platform services and resources that can be assembled together. There is an increasing number of profiles defined in various domains, resulting from either OMG standardization efforts or research outcomes. Different profiles may be overlapping and also inconsistent as each profile tailors the UML for a particular domain or platform. Some of the profiles emerged in previous versions of UML and then new profiles were defined to keep up with the latest changes in UML and to fill in the gaps identified in practice. In the following, we discuss some of the most commonly used profiles for real-time systems, with the historical background and the relationships between them.

Механізм профілю був спеціально визначений для забезпечення полегшеного механізму розширення стандарту UML за допомогою стереотипів, позначених значень і обмежень, як описано в розділі 5.3.3. Наприклад, інша робота [34] представляє UML-профіль для платформеного підходу до розробки вбудованого програмного забезпечення з використанням стереотипів для представлення послуг платформи та ресурсів, які можуть бути зібрані разом. Зростає кількість профілів, визначених у різних областях, що є наслідком зусиль зі стандартизації OMG або результатів досліджень. Різні профілі можуть накладатися, а також не узгоджуватися, оскільки кожен профіль адаптує UML для певного домену чи платформи. Деякі з профілів з’явилися в попередніх версіях UML, а потім були визначені нові профілі, щоб не відставати від останніх змін в UML і заповнити прогалини, виявлені на практиці. Нижче ми обговорюємо деякі з найбільш часто використовуваних профілів для систем реального часу з історичним фоном і зв’язками між ними.

The profile mechanism has been significantly refined starting with UML 2.0. Initially, UML 1.0/1.1 provided stereotypes and tagged values, but did not define the concept of a profile. Subsequent revisions of UML introduced the concept of a profile to provide structure to the extension elements. Moreover, to complete the previous versions of UML, the UML 2.0 Infrastructure and Superstructure specifications have defined the profile mechanism as a specific metamodeling technique. In addition, profile diagrams have been introduced in UML 2.0.

Механізм профілю був значно вдосконалений, починаючи з UML 2.0. Спочатку UML 1.0/1.1 передбачав стереотипи та позначені значення, але не визначав поняття профілю. Подальші редакції UML представили концепцію профілю для надання структури до елементів розширення. Крім того, щоб завершити попередні версії UML, специфікації UML 2.0 Infrastructure and Superstructure визначили механізм профілю як спеціальну техніку метамоделювання. Крім того, в UML 2.0 були представлені діаграми профілів.

UML/Realtime (UML-RT) [35,36] extended UML 1.1–1.4 to support Real-Time Object-Oriented Modeling [37] concepts. It was also the UML dialect of the CASE tool Rational Rose®/RT. The extension used the standard UML mechanisms of stereotypes, tagged values, and constraints. Thus, UML-RT is a profile, although it was not called a profile initially because there was no profile concept in UML 1.1. For modeling architectural concepts, UML-RT introduced capsules (to model components), ports (to model the interaction of a capsule with its environment), connectors (communication channels between ports), and protocols (to model the behavior that can occur over a connector). A protocol comprises a set of participants (protocol roles), each specified by a set of signals received/sent by it. The corresponding communication sequence can be specified by a state machine and sequence diagrams. While UML-RT was a substantial improvement over the first generation of UML to model real-time systems, it still did not support all notations needed in modeling real-time systems. For example, Krüger et al. [38] presents an extension to UML-RT to support broadcasting. Because UML-RT was not based on an extensible framework such as the one supported by UML 2.0, extending it was an ad hoc process. UML-RT concepts were finally included in UML 2.0, which grants not only the ability to use its constructs in standard UML, but also the ability to systematically extend such constructs. For example, Krüger et al. [39] presents an approach to introducing broadcasting using UML 2.0 facilities similar to the UML-RT approach we mentioned earlier [38].

UML/Realtime (UML-RT) [35,36] розширив UML 1.1–1.4 для підтримки концепцій об’єктно-орієнтованого моделювання в реальному часі [37]. Це також був діалект UML інструменту CASE Rational Rose®/RT. Розширення використовувало стандартні механізми UML стереотипів, тегованих значень і обмежень. Таким чином, UML-RT є профілем, хоча він спочатку не називався профілем, оскільки в UML 1.1 не було концепції профілю. Для моделювання архітектурних концепцій UML-RT представив капсули (для моделювання компонентів), порти (для моделювання взаємодії капсули з її середовищем), з’єднувачі (канали зв’язку між портами) і протоколи (для моделювання поведінки, яка може відбуватися протягом роз'єм). Протокол містить набір учасників (протокольних ролей), кожен з яких визначається набором сигналів, отриманих/надісланих ним. Відповідна послідовність зв'язку може бути задана кінцевим автоматом і діаграмами послідовності. Хоча UML-RT був суттєвим удосконаленням у порівнянні з першим поколінням UML для моделювання систем реального часу, він все ще не підтримував усі нотації, необхідні для моделювання систем реального часу. Наприклад, Krüger et al. [38] представляє розширення UML-RT для підтримки трансляції. Оскільки UML-RT не базувався на розширюваній структурі, такій як та, що підтримується UML 2.0, її розширення було спеціальним процесом. Концепції UML-RT були нарешті включені в UML 2.0, що надає не тільки можливість використовувати його конструкції в стандартному UML, але також можливість систематично розширювати такі конструкції. Наприклад, Krüger et al. [39] представляє підхід до введення трансляції з використанням засобів UML 2.0, подібних до підходу UML-RT, який ми згадували раніше [38].

The UML profiles standardized by OMG include the UML Profile for Schedulability, Performance, and Time (SPT) [40], the UML profile for MARTE [18], and the UML profile for QoS and Fault Tolerance (QoS & FT) [41]. UML-RT focused on component-oriented development of communicating systems but left other aspects of embedded systems unaddressed. The SPT profile [40] was developed to define a resource model, time, and concurrency aspects in UML. MARTE is a new UML profile that updates the previous profile SPT for UML 2.x. MARTE is presented in more detail in Section 5.4.2. The QoS & FT profile [41] defines resource properties such as memory capacity and power consumption. The QoS & FT profile allows users to customize service characteristics (i.e., define new characteristics through specialization) and use tools to perform analyses such as performance and dependability. The QoS & FT profile allows defining a wide variety of QoS properties as compared to the SPT profile, which focused on schedulability and performance. In comparison, MARTE reuses concepts defined in both the SPT and the QoS & FT profile. Moreover, MARTE has the advantage that it allows modelers to attach directly to the design model additional information necessary for various analyses, rather than creating dedicated models for analysis.

Профілі UML, стандартизовані OMG, включають профіль UML для планування, продуктивності та часу (SPT) [40], профіль UML для MARTE [18] і профіль UML для QoS і відмовостійкості (QoS & FT) [41] . UML-RT зосереджувався на компонентно-орієнтованій розробці комунікаційних систем, але залишав поза увагою інші аспекти вбудованих систем. Профіль SPT [40] був розроблений для визначення моделі ресурсів, часу та аспектів паралельності в UML. MARTE — це новий профіль UML, який оновлює попередній профіль SPT для UML 2.x. Більш детально MARTE представлено в розділі 5.4.2. Профіль QoS & FT [41] визначає властивості ресурсу, такі як об’єм пам’яті та енергоспоживання. Профіль QoS & FT дозволяє користувачам налаштовувати характеристики сервісу (тобто визначати нові характеристики через спеціалізацію) і використовувати інструменти для проведення аналізу, наприклад продуктивності та надійності. Профіль QoS & FT дозволяє визначати широкий спектр властивостей QoS порівняно з профілем SPT, який зосереджений на плануванні та продуктивності. Для порівняння MARTE повторно використовує концепції, визначені як у SPT, так і в профілі QoS & FT. Крім того, MARTE має ту перевагу, що дозволяє розробникам моделей додавати безпосередньо до моделі дизайну додаткову інформацію, необхідну для різних аналізів, а не створювати спеціальні моделі для аналізу.

OMG also provides the standard for the Systems Modeling Language™ (OMG SysMLTM) [42]. SysML reuses a subset of UML 2 (called UML4SysML) and provides additional extensions to address the concerns for systems engineering applications (called the SysML Profile). Therefore, SysML uses both UML extension mechanisms: the first-class extension via MOF is used to define the UML4SysML subset and then the profile extension mechanism is used not on UML but on UML4SysML. SysML does not use all of the UML diagram types and, thus, it is smaller and easier to learn than UML. In particular, SysML strictly reuses the UML use case, sequence, state machine, and package diagrams. SysML also modifies some of the UML diagrams. The SysML block definition diagram, internal block definition diagram, and activity diagrams extend the UML class diagram, composite structure diagram, and activity diagram, respectively. The SysML “block” is a significant extension in the direction of modeling complex systems. Blocks can be used to decompose the system into individual parts, with dedicated ports for accessing their internals. A block can represent almost any other type of structural entity. Furthermore, SysML allows the description of more general interactions than in software, for example, physical flows such as liquids, energy, or electricity. SysML activity diagrams add support for modeling continuous flows of material, energy, or information. By specifying a continuous rate, the increment of time between tokens approaches zero to simulate continuous flow. Nevertheless, SysML does not extend the time model of UML.

OMG також надає стандарт для Systems Modeling Language™ (OMG SysMLTM) [42]. SysML повторно використовує підмножину UML 2 (називається UML4SysML) і надає додаткові розширення для вирішення проблем, пов’язаних із програмами системної інженерії (називається SysML Profile). Тому SysML використовує обидва механізми розширення UML: розширення першого класу через MOF використовується для визначення підмножини UML4SysML, а потім механізм розширення профілю використовується не на UML, а на UML4SysML. SysML не використовує всі типи діаграм UML, тому він менший і легший для вивчення, ніж UML. Зокрема, SysML суворо повторно використовує варіант використання UML, послідовність, кінцевий автомат і схеми пакетів. SysML також змінює деякі діаграми UML. Діаграма визначення блоку SysML, діаграма визначення внутрішнього блоку та діаграми активності розширюють діаграму класів UML, діаграму складеної структури та діаграму діяльності відповідно. «Блок» SysML є значним розширенням у напрямку моделювання складних систем. Блоки можна використовувати для розкладання системи на окремі частини з виділеними портами для доступу до їхніх внутрішніх частин. Блок може представляти практично будь-який інший тип структурної сутності. Крім того, SysML дозволяє описувати більш загальні взаємодії, ніж у програмному забезпеченні, наприклад, фізичні потоки, такі як рідини, енергія чи електрика. Діаграми діяльності SysML додають підтримку для моделювання безперервних потоків матеріалу, енергії чи інформації. Якщо вказати безперервну швидкість, приріст часу між токенами наближається до нуля, щоб імітувати безперервний потік. Тим не менш, SysML не розширює часову модель UML.

SysML adds two new diagram types: the requirements diagram and the parametric diagram. The requirements diagram captures text-based requirements and the relationships between them—requirements hierarchies and requirements derivation. A requirement can be related to a model element that satisfies or verifies the requirements. Thus, SysML requirements modeling not only supports the process of documenting requirements, but also provides traceability to requirements throughout the design flow. It furthermore provides tabular representations for requirements. Parametric diagrams allow the graphical specification of analytical relationships and constraints on system properties (such as performance and reliability) associated with blocks. Thus, parametric diagrams serve the integration of design models with analysis models.

SysML додає два нових типи діаграм: діаграму вимог і параметричну діаграму. Діаграма вимог відображає текстові вимоги та взаємозв’язки між ними — ієрархії вимог та визначення вимог. Вимога може бути пов’язана з елементом моделі, який задовольняє або перевіряє вимоги. Таким чином, моделювання вимог SysML не тільки підтримує процес документування вимог, але й забезпечує відстеження вимог протягом усього процесу проектування. Крім того, він надає табличні представлення вимог. Параметричні діаграми дозволяють графічно вказувати аналітичні зв’язки та обмеження властивостей системи (таких як продуктивність і надійність), пов’язані з блоками. Таким чином, параметричні діаграми служать інтеграції моделей проектування з моделями аналізу.

SysML and MARTE are complementary and could be used together in a common modeling framework [43]. In general, there exist several profiles defined in various domains, and it is not clear how to combine multiple profiles when this is necessary for a particular interdisciplinary application. Therefore, Espinoza et al. [43] presents how SysML and MARTE can be combined and highlights the open issues in terms of convergence between the two profiles. For requirements engineering, SysML provides traceability relations, whereas MARTE provides ways to specify nonfunctional requirements. For system structure, modelers could start with a model specified with SysML blocks and then apply MARTE stereotypes to add additional semantics to these blocks. For system behavior, MARTE adopted the notion of port and flow from SysML, but they have different semantics. Therefore, when combining SysML and MARTE, it is required to define a common consistent semantics. Furthermore, significant differences exist in the specification of quantitative values for analysis (see Espinoza et al. [43] for a detailed analysis of the two profiles).

SysML і MARTE доповнюють один одного і можуть використовуватися разом у загальній структурі моделювання [43]. Загалом існує декілька профілів, визначених у різних областях, і незрозуміло, як об’єднати декілька профілів, коли це необхідно для конкретного міждисциплінарного застосування. Тому Espinoza et al. [43] представляє, як можна поєднати SysML і MARTE, і висвітлює відкриті проблеми з точки зору конвергенції між двома профілями. Для розроблення вимог SysML забезпечує зв’язки відстеження, тоді як MARTE надає способи визначення нефункціональних вимог. Що стосується структури системи, розробники моделей можуть почати з моделі, визначеної блоками SysML, а потім застосувати стереотипи MARTE, щоб додати до цих блоків додаткову семантику. Для поведінки системи MARTE взяв поняття порту та потоку від SysML, але вони мають різну семантику. Тому при поєднанні SysML і MARTE необхідно визначити загальну послідовну семантику. Крім того, існують значні відмінності в специфікації кількісних значень для аналізу (див. Espinoza et al. [43] для детального аналізу двох профілів).

Even from this short exploration of UML extensions and profiles, it becomes clear that model consistency is a critical aspect of MBE—within *and* across profiles.

Навіть із цього короткого огляду розширень і профілів UML стає зрозуміло, що узгодженість моделі є критичним аспектом MBE — у межах *і* між профілями.

### 5.4.2 Modeling and Analysis of Real-Time and Emb edded Systems

The UML profile for SPT [40] provides a framework for specifying time properties, schedulability analysis (rate monotonic analysis), and performance analysis (queuing theory). MARTE [18] updates SPT for UML 2.x. It allows for modeling of both software and hardware platforms along with their nonfunctional properties. It supports component-based architectures and different computational paradigms, and it allows more extensive performance and schedulability analysis.

Профіль UML для SPT [40] забезпечує структуру для визначення властивостей часу, аналізу планування (аналіз монотонної швидкості) та аналізу продуктивності (теорія масового обслуговування). MARTE [18] оновлює SPT для UML 2.x. Це дозволяє моделювати як програмні, так і апаратні платформи разом із їхніми нефункціональними властивостями. Він підтримує компонентні архітектури та різні обчислювальні парадигми, а також дозволяє більш детальний аналіз продуктивності та планування.

In this section, we present an overview of MARTE’s capabilities and we revisit the BART case study introduced in Section 5.3.2.3.

У цьому розділі ми представляємо огляд можливостей MARTE і повертаємося до прикладу BART, представленого в розділі 5.3.2.3.

#### 5.4.2.1 MARTE Basics

MARTE [18] is structured as a hierarchy of subprofiles (see the UML package diagram in [Figure 5.12](#_bookmark29)) with five foundation profiles and then further extensions used for design or analysis.

MARTE [18] структурований як ієрархія підпрофілів (див. діаграму пакета UML на [Рисунок 5.12](#_bookmark29)) із п’ятьма основними профілями та подальшими розширеннями, які використовуються для проектування чи аналізу.

The foundation profiles are as follows: 

Профілі фундаменту наступні:

•   *Core Elements* define the basic elements used for structural and behavioral modeling. MARTE distinguishes between design-time Classifier elements and runtime instance elements created from the Classifiers. Behaviors are composed of actions and are triggered by events. Behaviors provide context for actions and determine when they execute and what inputs they have. In addition, MARTE supports modeling of operational modes (i.e., modal behavior), which are mutually exclusive at runtime. A mode defines a fragment in the system execution that is characterized by a given configuration when a set of system entities are active and have parameters defined for that mode.

- *Основні елементи* визначають основні елементи, які використовуються для структурного та поведінкового моделювання. MARTE розрізняє елементи класифікатора часу розробки та елементи екземпляра часу виконання, створені з класифікаторів. Поведінка складається з дій і викликана подіями. Поведінка забезпечує контекст для дій і визначає, коли вони виконуються та які вхідні дані мають. Крім того, MARTE підтримує моделювання режимів роботи (тобто модальної поведінки), які є взаємовиключними під час виконання. Режим визначає фрагмент у виконанні системи, який характеризується заданою конфігурацією, коли набір системних об’єктів активний і має параметри, визначені для цього режиму.

•   *Nonfunctional Properties Modeling (NFP)* supports the declaration of nonfunctional properties (such as memory usage and power consumption) as UML data types. The Value Specification Language (VSL) is introduced in MARTE to specify the values of those data types using a textual language for specifying algebraic expressions. An annotated model (see [Figure 5.13](#_bookmark30)) contains annotated elements, which are model elements that have attached NFP value annotations for describing nonfunctional aspects (which can differ from one operational mode to another). The annotated model establishes the context for interpreting names used in the value specification. Examples of annotated elements (defined in other MARTE packages) used for performance analysis are step (a unit of execution), scenario (a sequence of steps), resource, and service (offered by a resource or component). A Modeling Concern establishes the ontology of relevant NFPs for a given domain used for the analysis. A domain model such as Figure 5.13 shows the concepts defined in MARTE. Then, a profile diagram defines the profile packages and how the elements of the domain model extend metaclasses of the UML metamodel. As explained in Section 5.3.3, the elements in the domain model are represented in the UML as stereotypes (e.g., the stereotypes «Nfp», «NfpConstraint», «Mode», etc.). However, not every element in the domain model results directly in a stereotype, because some of the domain concepts are abstract.

- *Моделювання нефункціональних властивостей (NFP)* підтримує оголошення нефункціональних властивостей (таких як використання пам’яті та енергоспоживання) як типи даних UML. Мова специфікації значень (VSL) представлена в MARTE для визначення значень цих типів даних за допомогою текстової мови для визначення алгебраїчних виразів. Анотована модель (див. [Малюнок 5.13](#_bookmark30)) містить анотовані елементи, які є елементами моделі, до яких додано анотації значення NFP для опису нефункціональних аспектів (які можуть відрізнятися від одного робочого режиму до іншого). Анотована модель встановлює контекст для інтерпретації імен, що використовуються в специфікації значення. Прикладами анотованих елементів (визначених в інших пакетах MARTE), які використовуються для аналізу продуктивності, є крок (одиниця виконання), сценарій (послідовність кроків), ресурс і послуга (пропонована ресурсом або компонентом). Проблема моделювання встановлює онтологію відповідних NFP для певної області, яка використовується для аналізу. Модель домену, така як рисунок 5.13, показує концепції, визначені в MARTE. Потім діаграма профілю визначає пакети профілів і те, як елементи моделі домену розширюють метакласи метамоделі UML. Як пояснюється в розділі 5.3.3, елементи в моделі предметної області представлені в UML як стереотипи (наприклад, стереотипи «Nfp», «NfpConstraint», «Mode» тощо). Однак не кожен елемент у моделі домену призводить безпосередньо до стереотипу, оскільки деякі поняття домену є абстрактними.

![image-20220821192929797](media/image-20220821192929797.png)

**FIGURE 5.12** The architecture of the Modeling and Analysis of Real-Time and Embedded systems (MARTE) profile. (From Object Management Group, “UML Profile for MARTE: Modeling and Analysis of Real-Time Embedded Systems” Version 1.0, formal/2009-11-02, OMG, 2009. With permission.)

•   The *Time* profile supports three models of time: chronometric, logical, and synchronous. It enriches the behavior specification from the core elements with explicit references to time concepts. Time is represented as a partial ordering of instants. The occurrence of a time event refers to one instant. The basic model does not refer to physical time and, therefore, supports logical time, which is the basis also for synchronous languages. A time base is a set of instants where MARTE supports discrete and dense time bases (only countable sets). Physical time can be modeled as a dense time base. Clocks (logical or chronometric) use a discrete time base. For distributed systems, multiple time bases are supported.

- Профіль *Час* підтримує три моделі часу: хронометричну, логічну та синхронну. Це збагачує специфікацію поведінки з основних елементів явними посиланнями на концепції часу. Час представлено як часткове впорядкування миттєвостей. Настання події часу відноситься до одного моменту. Базова модель не відноситься до фізичного часу і, отже, підтримує логічний час, який також є основою для синхронних мов. База часу — це набір моментів, де MARTE підтримує дискретну та щільну бази часу (тільки лічильні набори). Фізичний час можна моделювати як щільну часову базу. Годинники (логічні чи хронометричні) використовують дискретну базу часу. Для розподілених систем підтримується кілька баз часу.

![image-20220821193013332](media/image-20220821193013332.png)

**FIGURE 5.13** Nonfunctional properties annotations in MARTE. (From Object Management Group, OMG, 2009, “UML Profile for MARTE: Modeling and Analysis of Real-Time Embedded Systems” Version 1.0, formal/2009-11-02, 2009. With permission.)

Time can be used for triggering behaviors or observing event occurrences. MARTE defines the concepts for relating events, actions, and messages to time. A time constraint is specified as a predicate on timed observations (see [Figure 5.14](#_bookmark31)) and so the TimedObservation is a key concept introduced in MARTE. A constraint can be imposed on the occurrence of an event, the temporal distance between two events, or the duration of a behavior execution. A TimedObservation is a TimedElement, and, therefore, it has associated clocks used for observing time. A TimedObservation is the abstract superclass of TimedInstantObservation and TimedDurationObservation. For a behavior, observed events can be either its *start* or *finish* event. For a request, the possible events are its *send, receive*, or *consume* (the start of its processing by the receiver) events. Duration constraints can be defined on two events not necessarily occurring on the same clock.

Час можна використовувати для ініціювання поведінки або спостереження за подіями. MARTE визначає концепції зв’язку подій, дій і повідомлень із часом. Часове обмеження вказується як предикат часових спостережень (див. [Малюнок 5.14](#_bookmark31)), тому TimedObservation є ключовим поняттям, представленим у MARTE. Обмеження може бути накладено на виникнення події, часову відстань між двома подіями або тривалість виконання поведінки. TimedObservation є TimedElement, і, отже, він має пов’язані годинники, які використовуються для спостереження за часом. TimedObservation — це абстрактний суперклас TimedInstantObservation і TimedDurationObservation. Для поведінки спостережувані події можуть бути або його *початковою*, або *фінішною* подією. Для запиту можливими подіями є його події *send, receive* або *consume* (початок його обробки одержувачем). Обмеження тривалості можна визначити для двох подій, які не обов’язково відбуваються на одному годиннику.

![image-20220821193036483](media/image-20220821193036483.png)

**FIGURE 5.14** TimedConstraints as defined in MARTE. (From Object Management Group, “UML Profile for MARTE: Modeling and Analysis of Real-Time Embedded Systems” Version 1.0, formal/2009-11-02, OMG, 2009. With permission.) 

•   *Generic Resource Modeling (GRM)* provides an ontology of resources that allows the modeling of computing platforms, including computing resources, storage resources, communication media, and execution platforms.

• *Generic Resource Modeling (GRM)* забезпечує онтологію ресурсів, яка дозволяє моделювати обчислювальні платформи, включаючи обчислювальні ресурси, ресурси зберігання, комунікаційні засоби та платформи виконання.

•   *Allocation Modeling (Alloc)* provides concepts for allocation of functionality to implementation entities. It includes space allocation and time allocation (i.e., scheduling). It also addresses the issue of refinement between models of different levels of abstraction. Nonfunctional properties (e.g., worst case execution time) can be attached to an allocation specification.

• *Моделювання розподілу (Alloc)* надає концепції розподілу функціональних можливостей об’єктам реалізації. Він включає в себе розподіл простору та часу (тобто планування). Він також розглядає проблему уточнення між моделями різних рівнів абстракції. Нефункціональні властивості (наприклад, найгірший час виконання) можна приєднати до специфікації розподілу.

Based on the foundational profiles, MARTE provides two packages of extensions (see [Figure 5.12](#_bookmark29)): the MARTE design model supports model-based design of embedded applications and the MARTE analysis model supports model-based analyses and, thus, validation and verification.

Базуючись на базових профілях, MARTE надає два пакети розширень (див. [Малюнок 5.12](#_bookmark29)): модель проектування MARTE підтримує розробку вбудованих програм на основі моделі, а модель аналізу MARTE підтримує аналіз на основі моделі і, таким чином, валідація та перевірка.

For model-based design with MARTE, the *High-Level Application Modeling (HLAM)* subprofile provides extensions for real-time concerns such as Real-time Unit (using the stereotype «RtUnit») for concurrent computing units and Protected passive Unit («PpUnit») for shared information. An «RtUnit» owns one or several schedulable resources and can satisfy several requests from several real-time units at the same time, enabling intraunit parallelism if necessary. An «RtUnit» owns a single message queue for saving the messages it receives, and each message can be used to trigger the execution of a behavior owned by the unit. Real-time units and protected passive units may provide real-time services, which may specify real-time features such as deadlines and periods (with the ArrivalPattern data type). The stereotype for features («rtf») can be applied to multiple kinds of modeling elements (e.g., actions, messages, and signals). For example, the message *Status* from [Figure 5.7 ](#_bookmark26)can be stereotyped as a real-time feature, indicating that is has a period of 500 ms (remember that the AATC system operates in half-second cycles). As a simple example, [Figure 5.15 ](#_bookmark32)depicts the status message, omitting other messages exchanged in this scenario. We define *t*0 as a TimedInstantObservation. Because the message is periodic, the period starts at time event *t*0[*i*]. Later in the chapter, [Figure 5.17 ](#_bookmark34)shows an example for specifying timing constraints on the temporal distance between two events.

Для проектування на основі моделі за допомогою MARTE підпрофіль *High-Level Application Modeling (HLAM)* надає розширення для проблем реального часу, наприклад Модуль реального часу (з використанням стереотипу «RtUnit») для одночасних обчислювальних блоків і Захищений пасивний блок ( «PpUnit») для спільної інформації. «RtUnit» володіє одним або декількома запланованими ресурсами і може задовольнити декілька запитів від кількох блоків реального часу одночасно, забезпечуючи паралелізм усередині блоку, якщо це необхідно. «RtUnit» володіє єдиною чергою повідомлень для збереження повідомлень, які він отримує, і кожне повідомлення може використовуватися для ініціювання виконання поведінки, яка належить цьому модулю. Блоки реального часу та захищені пасивні блоки можуть надавати послуги в режимі реального часу, які можуть визначати функції реального часу, такі як кінцеві терміни та періоди (з типом даних ArrivalPattern). Стереотип для функцій («rtf») можна застосовувати до багатьох типів елементів моделювання (наприклад, дій, повідомлень і сигналів). Наприклад, повідомлення *Status* з [Рис. 5.7 ](#_bookmark26) можна стереотипно сприймати як функцію реального часу, вказуючи, що воно має період 500 мс (пам’ятайте, що система AATC працює в півсекундних циклах). Як простий приклад, [Рисунок 5.15 ](#_bookmark32) зображує повідомлення про стан, опускаючи інші повідомлення, якими обмінюються в цьому сценарії. Ми визначаємо *t*0 як TimedInstantObservation. Оскільки повідомлення є періодичним, період починається в момент події *t*0[*i*]. Далі в цьому розділі [Малюнок 5.17] (#_bookmark34) показано приклад визначення часових обмежень для часової відстані між двома подіями.

![image-20220821193108211](media/image-20220821193108211.png)

**FIGURE 5.15** Bay Area Rapid Transit periodic feature.

The *Generic Component Model (GCM)* subprofile supports component-based design, with both message and data communication between components. The MARTE component model adopted the concepts of ports and flows from SysML and added client/server ports. Furthermore, *Software Resource Modeling (SRM)* and *Hardware Resource Modeling (HRM)* allow designers to specify computing platforms. SRM allows modeling of elements such as tasks, semaphores, mailboxes, etc. The MARTE annexes feature supports modeling of OSEK, ARINC, and POSIXcompliant software computing platforms. The model of computation in MARTE is an asynchronous/event-based approach, but alternative models can be defined as extensions to the MARTE specification by using NFP, Time, and GRM packages.

Підпрофіль *Generic Component Model (GCM)* підтримує проектування на основі компонентів із обміном повідомленнями та даними між компонентами. Компонентна модель MARTE взяла концепції портів і потоків із SysML і додала порти клієнт/сервер. Крім того, *Моделювання програмних ресурсів (SRM)* і *Моделювання апаратних ресурсів (HRM)* дозволяють розробникам визначати обчислювальні платформи. SRM дозволяє моделювати такі елементи, як завдання, семафори, поштові скриньки тощо. Функція додатків MARTE підтримує моделювання OSEK, ARINC і POSIX-сумісних програмних обчислювальних платформ. Модель обчислень у MARTE — це асинхронний/подійний підхід, але альтернативні моделі можна визначити як розширення специфікації MARTE за допомогою пакетів NFP, Time і GRM.

Model-based analysis with MARTE is provided by the *Generic Quantitative Analysis Modeling (GQAM)* subprofile or by its two refinement subprofiles for schedulability and performance analysis. The analysis is based on the annotation mechanism in MARTE, which uses UML stereotypes. The model elements are mapped into analysis elements, which include the values for nonfunctional properties necessary for the analysis.

Аналіз на основі моделі за допомогою MARTE забезпечується підпрофілем *Generic Quantitative Analysis Modeling (GQAM)* або його двома підпрофілями уточнення для планування та аналізу продуктивності. Аналіз базується на механізмі анотації в MARTE, який використовує стереотипи UML. Елементи моделі відображаються в елементи аналізу, які включають значення для нефункціональних властивостей, необхідних для аналізу.

The Architecture Analysis and Design Language (AADL) [44] is an architecture description language defined ab initio (*not* as a UML profile) and standardized by the Society of Automotive Engineers. A system modeled in AADL consists of application software components (made of data, threads, and process components) bound to execution platform components (processors, memory, buses, and devices). Note that there is a MARTE rendering of AADL, formalized as a subset of MARTE.

Мова аналізу та проектування архітектури (AADL) [44] — це мова опису архітектури, визначена ab initio (*не* як профіль UML) і стандартизована Товариством автомобільних інженерів. Система, змодельована в AADL, складається з компонентів прикладного програмного забезпечення (складених з даних, потоків і компонентів процесу), прив’язаних до компонентів платформи виконання (процесори, пам’ять, шини та пристрої). Зауважте, що існує рендеринг MARTE для AADL, формалізований як підмножина MARTE.

#### 5.4.2.2 MARTE Semantics

We discussed in Section 5.3.4 that UML 2.x defines a flexible semantics framework, which leaves several variation points open for profiles to specify. This approach leaves the developers of profiles free to adapt the general framework of UML behavior to the special needs of their target domains. In the case of MARTE, one of the most evident variations is the time model, which we discussed in Section 5.4.2.1. In fact, because the target domain includes real-time systems, the simplistic time model based on a global clock of the UML is not suitable.

У Розділі 5.3.4 ми обговорювали, що UML 2.x визначає гнучку структуру семантики, яка залишає відкритими кілька точок варіації для профілів. Цей підхід дає розробникам профілів можливість адаптувати загальну структуру поведінки UML до особливих потреб їхніх цільових доменів. У випадку MARTE однією з найбільш очевидних варіацій є модель часу, яку ми обговорювали в розділі 5.4.2.1. Фактично, оскільки цільовий домен включає системи реального часу, спрощена модель часу, заснована на глобальному годиннику UML, не підходить.

While time is the most evident variation over standard UML semantics, MARTE defines semantics for many other variation points that the general UML specification left open. For example, we mentioned in Section 5.3.4 that the order in which messages are removed from the message pool and presented to the receiving instance is an open variation point. MARTE addresses this variation point by defining two default policies (first-in-first-out, FIFO and last-in-first-out, LIFO) and specifying that, by default, messages that arrive when the message pool is full will not be blocking and the message pool will silently drop the oldest message it contains to make room for the new one ([see Section 12.3.2.6 ](#_bookmark35)in the MARTE profile specification [18]). A complete discussion of all UML variation points fixed by MARTE is beyond the scope of this chapter. We recommend that the interested reader consult the MARTE profile specification [18] for a complete specification of the MARTE semantics.

Хоча час є найбільш очевидною варіацією стандартної семантики UML, MARTE визначає семантику для багатьох інших точок варіації, які загальна специфікація UML залишила відкритими. Наприклад, ми згадували в Розділі 5.3.4, що порядок, у якому повідомлення видаляються з пулу повідомлень і передаються примірнику-одержувачу, є відкритою точкою варіації. MARTE вирішує цю точку варіації, визначаючи дві політики за замовчуванням (першим прийшов – першим вийшов, FIFO та останнім прийшов – першим вийшов, LIFO) і вказавши, що за замовчуванням повідомлення, які надходять, коли пул повідомлень заповнений, не будуть блокування, і пул повідомлень мовчки видалить найстаріше повідомлення, яке містить, щоб звільнити місце для нового ([див. Розділ 12.3.2.6 ](#_bookmark35) у специфікації профілю MARTE [18]). Повне обговорення всіх точок варіації UML, виправлених MARTE, виходить за рамки цієї глави. Ми рекомендуємо зацікавленому читачеві переглянути специфікацію профілю MARTE [18] для повної специфікації семантики MARTE.

#### 5.4.2.3 MARTE Example

In this section, we revisit the BART example introduced in Section 5.3.2.3. We show different modeling perspectives using MARTE, give an example of timing constraints, and present an inconsistency that can arise when modeling behavior in the different diagrams.

У цьому розділі ми знову розглянемо приклад BART, представлений у розділі 5.3.2.3. Ми показуємо різні перспективи моделювання за допомогою MARTE, наводимо приклад часових обмежень і представляємо невідповідність, яка може виникнути під час моделювання поведінки на різних діаграмах.

Figure 5.16 depicts a component diagram with five components and the interface dependencies between them (we use the graphical notation of a ball-and-socket connection between a provided interface and a required interface). The Environmental Model component models the physical environment containing the trains. The Station AATC uses the Environmental Model to compute commands to send to trains. The Safety Control component checks all commands sent by the Station AATC for safety before forwarding them to each train. The safety computation is based on a simpler model than the one used to compute commands and only focuses on ensuring that all commands sent maintain the safety of each train. The last two components are deployed on the actual train. The Train Controller manages the train accelerations and decelerations, and the Emergency Brake is activated only in case of an emergency and stops the train as quickly as possible.

На малюнку 5.16 зображено діаграму компонентів із п’ятьма компонентами та залежностями інтерфейсу між ними (ми використовуємо графічне позначення з’єднання кулька та гніздо між наданим і необхідним інтерфейсом). Компонент Environmental Model моделює фізичне середовище, в якому знаходяться поїзди. Station AATC використовує модель навколишнього середовища для обчислення команд для надсилання потягам. Компонент Safety Control перевіряє на безпеку всі команди, надіслані станцією AATC, перш ніж пересилати їх до кожного поїзда. Розрахунок безпеки базується на простішій моделі, ніж та, яка використовується для обчислення команд, і зосереджується лише на тому, щоб усі надіслані команди підтримували безпеку кожного поїзда. Останні два компоненти розгортаються на самому поїзді. Поїзний диспетчер керує прискоренням і уповільненням поїзда, а аварійне гальмування активується лише в разі надзвичайної ситуації та зупиняє поїзд якнайшвидше.

![image-20220821193220783](media/image-20220821193220783.png)

**FIGURE 5.16** Component diagram for Bay Area Rapid Transit system.

Figure 5.17 depicts a sequence diagram capturing the common control scenario for the BART system. The figure represents the Issue New Commands diagram referenced earlier in [Figure 5.6](#_bookmark25). This model is annotated with MARTE time constraints to specify the real-time requirements of the BART case study. The behavior specified in the diagram is the following:

На рисунку 5.17 зображено діаграму послідовності, яка відображає загальний сценарій керування для системи BART. На малюнку зображено діаграму «Видати нові команди», згадану раніше на [Малюнок 5.6] (#_bookmark25). Ця модель анотована часовими обмеженнями MARTE, щоб визначити вимоги реального часу прикладу BART. Поведінка, указана на схемі, така:

•   Station AATC sends a request to Environmental Model to compute the commands for the train.

•   Environmental Model computes the commands, taking into account all parameters such as passenger comfort, schedule, etc.

•   After receiving the commands from Environmental Model, Station AATC sends the commands to Safety Control to ensure the commands computed are safe.

•   If the commands are safe, Safety Control forwards them to Train Controller.

•   Train Controller informs Emergency Brake that the commands have been received.

•   Emergency Brake acknowledges the commands received.

•   Finally, Train Controller controls the train engine according to the commands received.

• Станція AATC надсилає запит до Environmental Model для обчислення команд для поїзда.

• Environmental Model обчислює команди, враховуючи всі параметри, такі як комфорт пасажирів, розклад тощо.

• Після отримання команд від Environmental Model станція AATC надсилає команди до Safety Control, щоб переконатися, що обчислені команди безпечні.

• Якщо команди є безпечними, служба безпеки передає їх диспетчеру поїздів.

• Поїзний диспетчер повідомляє екстрене гальмування, що команди отримані.

• Екстрене гальмування підтверджує отримані команди.

• Нарешті, Train Controller керує двигуном поїзда відповідно до отриманих команд.

In Figure 5.17, we annotated two time instants *t*0 and *t*1 using Timed InstantObservations as defined in MARTE, which is indicated by the graphical representations @*t*0 and @*t*1. A TimedInstantObservation denotes an instant in time associated with an event occurrence (e.g., send or receive) and observed on a given clock. *t*0 is the instant when the message Compute Commands is *sent* by Station AATC, whereas *t*1 is the time instant when the message Commands Received is *received* by Emergency Brake.

На малюнку 5.17 ми анотували два моменти часу *t*0 і *t*1 за допомогою Timed InstantObservations, як визначено в MARTE, що вказується графічними представленнями @*t*0 і @*t*1. TimedInstantObservation позначає момент у часі, пов’язаний із подією (наприклад, надсиланням або отриманням), який спостерігається на певному годиннику. *t*0 — це момент, коли станція AATC *надсилає* повідомлення Compute Commands, тоді як *t*1 — момент часу, коли повідомлення Commands Received *отримує* екстрене гальмування.

![image-20220821193258221](media/image-20220821193258221.png)

**FIGURE 5.17** Sequence diagram for computing and delivering Train Commands.

![image-20220821193313722](media/image-20220821193313722.png)

**FIGURE 5.18** State-machine diagrams for the Emergency Brake.

Given those two instants, we leverage MARTE to define three time constraints in our system. With the time constraint (*t*1[*i*] − *t*0[*i*]) < (2000, ms), we limit the duration of each iteration of this scenario to 2 s. The notations *t*0[*i*] and *t*1[*i*] represent the generic *i*th instantiation of the scenario (recall that the system operates in cycles). The second constraint, (*t*0[*i* + 1] − *t*0[*i*]) > (500, ms), imposes that between each instantiation of the scenario, at least half a second passes. Finally, the last constraint, jitter(*t*0) < (10, ms), limits the jitter of the *t*0 event, enforcing that between each iteration of the event at *t*0, there are between 500 and 510 ms.

Враховуючи ці два моменти, ми використовуємо MARTE для визначення трьох часових обмежень у нашій системі. З часовим обмеженням (*t*1[*i*] − *t*0[*i*]) < (2000, мс) ми обмежуємо тривалість кожної ітерації цього сценарію 2 с. Нотації *t*0[*i*] і *t*1[*i*] представляють загальний *i*й екземпляр сценарію (нагадаємо, що система працює в циклах). Друге обмеження, (*t*0[*i* + 1] − *t*0[*i*]) > (500, мс), передбачає, що між кожним екземпляром сценарію проходить принаймні півсекунди. Нарешті, останнє обмеження, тремтіння (*t*0) < (10, мс), обмежує тремтіння події *t*0, забезпечуючи, щоб між кожною ітерацією події *t*0 було від 500 до 510 мс.

Figures 5.18a and 5.18b present state-machine diagrams for the Emergency Brake system. These state machines are two different versions of the same perspective, where the one in Figure 5.18b is a refined version that enables restarting the system after an emergency brake. If we consider the three graphs from [Figures 5.16](#_bookmark33), 5.17, and 5.18a together, we have an inconsistent model: the state machine diagram Figure 5.18a does not acknowledge the Commands Received call from Train Controller— contrary to what the sequence diagram from [Figure 5.17 ](#_bookmark34)demands. Replacing the diagram from Figure 5.18a with Figure 5.18b, we obtain a consistent model.

На малюнках 5.18a і 5.18b представлені діаграми станів системи екстреного гальмування. Ці кінцеві автомати є двома різними версіями однієї точки зору, де одна на малюнку 5.18b є вдосконаленою версією, яка дозволяє перезапустити систему після екстреного гальмування. Якщо ми розглядаємо разом три графіки з [Рисунок 5.16] (#_bookmark33), 5.17 та 5.18a, ми маємо суперечливу модель: діаграма кінцевого автомата (Рисунок 5.18a) не підтверджує виклик «Отримані команди» від диспетчера поїзда—на відміну від того, що діаграма послідовності з [Малюнок 5.17 ](#_bookmark34) вимагає. Замінивши діаграму з рисунка 5.18а на малюнок 5.18б, ми отримаємо узгоджену модель.

[5.3 <--- ](5_3.md) [   Зміст   ](README.md) [--> 5.5](5_5.md)