[6.1 <--- ](6_1.md) [   Зміст   ](README.md) [--> 6.3](6_3.md)

## 6.2. TIMING DEFINITION LANGUAGE

The TDL [8] at its core follows the time-triggered programming model [3,9]. In a time-triggered system, all activities are triggered only by the ticks of a single global clock. To increase the range of applicability, TDL also supports a limited form of event-triggered programming, which allows, for example, responding to hardware interrupts.

 

### TDL ProPerTies

TDL programs that only rely on the time-triggered features exhibit the following properties by construction.

 

#### Time and Value Determinism

Value determinism means that a program provides the same outputs if it is provided with the same inputs. Time determinism means that a program provides the outputs at the same times if it is provided with the inputs at the same times, where all times are relative to the program start. TDL aims for both time determinism and value determinism. Thus, a TDL program provides the same outputs at the same times if it is provided with the same inputs at the same times. In other words, the chrono- logically ordered sequence of outputs (time plus values) of a TDL program, which is also referred to as the observable behavior of a program, is deterministic and platform-independent.

 

#### Portability

TDL programs represent a platform-independent description of the timing behavior of an application. Everything that is platform specific, for example, accessing sen- sors or actuators, is defined outside the TDL program. TDL programs behave exactly the same independent of the underlying CPU, network bandwidth, or operating sys- tem. Even when simulating a TDL application, for example, under MATLAB and Simulink, the application exhibits the same behavior.

 

#### Transparent Distribution

Since TDL abstracts from the execution platform, a TDL application shows the same observable behavior in the case of a distributed system as on a single-node system. Thus, the fact that a distributed system is used as an execution platform is transpar- ent. It is the task of the TDL compiler to generate a suitable network communication schedule for maintaining the observable behavior of the application [10].

 

#### Time Safety

The TDL compiler provides a time safety check, which guarantees that a program behaves as expected for a particular target platform given that the worst case execu- tion times for the tasks to be executed are known for that platform. In the case of a distributed platform, the compiler also guarantees that the network communication preserves the expected observable behavior of the application.



**162**                                       Real-Time Simulation Technologies

 

#### Compositionality

A TDL program consists of a set of so-called modules. All modules are executed in parallel, and the data flow between modules is handled by the TDL runtime system. Adding another module to the application does not change the observable behavior of the previously existing modules.

 

### TDL Language ConsTruCTs

In the sequel, we introduce the individual TDL language constructs informally. For more details including a formal grammar, please refer to the TDL Language Specification [8].

 

#### Modules

At the outermost level, a TDL application consists of a set of modules[35]. Two modules can either be independent, that is, they share no data, or cooperating. Cooperating modules exchange data through ports. Statically, a module provides a namespace. Dynamically, modules are executed in parallel—possibly on different nodes in a distributed system. All modules share a common clock, which, in the case of a distributed execution platform, has to be distributed to the individual nodes of the platform. A module may encapsulate a finite state machine (FSM), where the states are denoted as modes. In a mode, the temporal aspects of all activities are defined.

 

#### Ports

Data flow within a single TDL module, between multiple modules, and between a TDL module and the physical environment is exclusively based on ports. A port is a typed variable that is accessed (read or written) at specific time instances only. Sensor and actuator ports (sensors and actuators for short) are the only means for a TDL module to communicate with the environment. A sensor declaration defines a typed read-only variable to represent a particular value in the physical environment and provides input to the TDL application. An actuator declaration is an initialized and typed write-only variable that influences a particular value in the physical environment and provides output from the TDL application to the environment. The access to the hardware is performed by user-provided setter and getter functions that are external to TDL.

 

#### Tasks

A task is the computational unit in TDL. It defines a namespace for input, output, and state ports. Each task is associated with a task function, that is, a stateless piece of code without any synchronization points. A single invocation of a task at runtime creates a *task activation*. A task activation lasts for a strictly positive amount of time that starts at the release time (the time when the task activation is released) and ends at the termination time (the time when the task activation is terminated). The time between these two instants is called the *logical execution time* (LET) of the task activation ([Figure 6.1](#_bookmark36)). At the release time, the input ports of the corresponding task are updated with the values read from the output ports of other tasks and sensors that have been passed as parameters by the task invocation. The actual execution of the



Modeling and Simulation of Timing Behavior                        **163**



Logical view

Physical



Release



Logical execution time Task activation

​                                 Running                   Running



Termination



Time



view



Read inputs



Start    Preempt    Resume           Finish



Write outputs



**FIGURE 6.1** Logical execution time.

 

task function can be scheduled at will, as long as its execution starts after the release time and finishes before the termination time. The task activation locally buffers the output of the task function. At the termination time, the output ports of the task are updated with the values stored in the local buffers of the task activation. State ports hold data that must persist among multiple activations of a task.

 

#### Modes

Modules that encapsulate a state machine have a dedicated start mode each and can switch between modes independently of others. A mode *m* specifies a mode period *Pm* (in microseconds) and a set of activities. As long as a module remains in mode *m*, the activities associated with *m* are repeated with period *Pm*. A mode activity either is a task invocation, an actuator update, or a mode switch. Mode activities may be guarded. A *guard* is a function that returns either true or false. A guarded mode activity is executed only if its guard evaluates to true.

When defining a mode activity within a mode, a frequency *f* for this activity is specified. This frequency divides the mode period *Pm* into *slots* of duration *Pm*/*f* each. These slots define the times during the mode period at which the guard of the activ- ity is evaluated and the activity is executed. Actuator updates and mode switches are executed at the end of a slot. Task invocations result in the release of a task activation at the beginning and the termination of the particular activation at the end. Thus, the LET of an activation spans the entire slot, and, by default, the task invocation is executed in each slot.

For control systems, the fixed relationship between the rate of task invocations and the LET of each task activation poses problems as the delay between reading the sensors and updating the actuators consumes phase reserve in the control loop (e.g., Ref. [11]). Besides increasing the frequency of a task invocation and thus the sampling rate, which may be prohibitive in terms of CPU load, TDL offers two mechanisms for dealing with this situation: slot selection and task splitting.

*Slot selection* is the explicit selection of the slots in which a mode activity should be executed. For task invocations, slot selection maintains the basic pattern of freez- ing the input ports of a task at the release of each of the task activations and updating the output ports (and actuators) at termination. It allows a separation between the specification of the LET of a task activation and the repetition rate of the associated task. Slots that are not selected go unused.

*Task splitting* means to split the single task function into two functions, one called fast step and the other called slow step. TDL assumes that the fast step does not



**164**                                       Real-Time Simulation Technologies

 

consume any time. At release time, first the input ports of the task are updated and then the fast step is executed. As a modification of the basic actuator update pattern, there is the possibility to update an actuator with a value calculated in the fast step immediately after it has finished execution. The slow step is executed afterwards, during the LET of the activation. At the termination time, the output ports of the task are updated and further actuator updates may be performed. In a control system application, for example, the actual controller may be moved into the fast step. Thus, the delay between reading the output of the plant and updating the actuator that delivers the input to the plant is minimized. A state estimator (e.g., [11]), representing a higher computational load, will then be moved into the slow step.

#### Asynchronous (= Event-Triggered) Activities

In addition to time-triggered (alias synchronous) activities, it is often necessary to execute event-triggered (alias asynchronous) activities as well [12]. TDL supports asynchronous task invocations and actuator updates. Such an asynchronous activity is triggered either by an update of an output port, by the occurrence of a hardware interrupt, or by the tick of a timer that may potentially introduce its own time base.

By integrating asynchronous activities into TDL, the TDL runtime system is able to provide the synchronization of the data flow between synchronous and asyn- chronous activities. It has been shown in Ref. [13] that a lock-free synchronization approach with a negligible impact on the timing of the time-triggered activities is possible with the semantics outlined below.

Events may be associated with a priority and are registered in a priority queue when they arrive. Processing the events is delayed and supposed to be performed sequentially by a single background thread that runs whenever there are no time-triggered activi- ties to perform. Input ports are read as part of the asynchronous execution, not at the time of registering an event. Output ports are updated immediately after an asynchro- nous task invocation has finished. If an activity is triggered again before it has started to execute, it will not be executed a second time but remains registered once. In the case of a distributed system, the communication of asynchronous output values to remote nodes is supposed to rely on asynchronous network operations. Since any net- work operation introduces a delay, the transparent distribution property (see Section 6.2.1.3) does not hold in the case of asynchronous activities [14].

 

### examPLe TDL moDuLes

The following example of two TDL modules exemplifies the textual syntax of TDL ([Figure 6.2](#_bookmark37)). As an alternative to the textual representation, the TDL toolchain also provides a syntax-driven editor that supports a visual and interactive modeling of TDL modules (see [Figure 6.6 ](#_bookmark38)later in the chapter).

 

module Sender {

sensor int s1 uses getS1; actuator int a1 uses setA1;

public task inc { input int i;



Modeling and Simulation of Timing Behavior                        **165**

output int o := 10; uses incImpl(o);

}

start mode main [period=5ms] { task

[freq=1] inc(s1);//LET = 5ms/1 = 5ms actuator

[freq=1] a1 := inc.o; mode

[freq=1] if exitMain(s1) then freeze;

}

mode freeze [period=1000ms] {}

}

module Receiver { import Sender;

…

task clientTask { input int i1;

…

}

start mode main [period=10ms] { task

[freq=1] clientTask(Sender.inc.o); //LET = 10ms

…

}

…

}

 

​                          

​            Sender            

​            main [*p* = 5 milliseconds]      inc [*f* = 1]            

​            Receiver            

​            [*f* = 1]            

​            *a*1            

​            *s*1            

​            main [*p* = 10      milliseconds]            

​            exitMain(*s*1) [*f* = 1]            

​            clientTask [*f* = 1]            

​            freeze [*p* = 1000 milliseconds]            







**FIGURE 6.2** Sample TDL application.



**166**                                       Real-Time Simulation Technologies

 

Module *Sender* contains a sensor variable *s1* and an actuator variable *a1*. The value of *s1* is updated by executing the (platform-specific) function *getS1* and the value of *a1* is sent to the physical actuator by using the platform-specific function *setA1*. The declaration of task *inc* contains an input port *i* and an output port *o* with an initial value of 10. This task is invoked in the mode *main*, where it reads input from the sensor *s1*. In the same mode, actuator *a1* is updated with the value of the task’s output port. The timing behavior of the mode activities is specified by means of individual frequencies within their common mode period. For example, with a frequency of 1, the activation of task *inc* is defined to have a LET of 5 milliseconds. The second module called *Receiver* imports the *Sender* module to connect the output of the task *inc* with the input of the task *clientTask*.

 

### TDL TooLChain

TDL introduces appropriate abstractions to separate timing from functionality and platform-independent from platform-specific aspects. To obtain executable software, the textual TDL description must be compiled and combined with external func- tions that implement the required functionality. Figure 6.3 outlines the TDL tool- chain. It shows as a central component the TDL compiler that compiles a textual TDL program to platform-independent embedded code (so-called E-code). The TDL compiler also offers a plug-in-architecture for generating target platform-specific output. For example, on an automotive platform with OSEK as the operating system, the platform-specific output could include the so-called OIL files [15]. The E-code together with the platform-specific output and the functionality code corresponding to task function implementations is used by the TDL runtime system, the so-called E-machine [16], to execute TDL applications.

 

 

​                  

​            Functionality code            

​            .tdl            

​            Compiler            

​            .ecode            

​            E-machine            

​            Platform specification            

​            Platform plug-in            

​            Platform- specific files            







 

**FIGURE 6.3** TDL toolchain.



Modeling and Simulation of Timing Behavior                        **167**

 

#### E-code

The TDL compiler generates E-code for each mode of a module. The E-code covers a single mode period and is repeated by means of a jump instruction to the begin- ning of the mode. For every logical time instant at which E-code must be executed, one E-code block is generated. An E-code block is a list of E-code instructions. It specifies for one logical time instant the actions that must be taken by the E-machine to comply with the timing specifications and LET semantics. The following generic sequence of actions comprises one E-code block for a logical time instant *t*:

 

\1.   Update the output ports of all tasks that are defined to be terminated at *t*.

\2.   Update all actuators that are defined to be updated at *t*.

\3.   Switch mode if a mode switch is defined at *t*.

\4.   Update the input ports of all tasks that are defined to be released at *t*.

\5.   Release all task activations that are defined to be released at *t*.

\6.   Sleep until the next logical time instant that must execute E-code.

 

Sensors are read whenever their value is required. However, at one particular logi- cal time, a sensor is read at most once.

In the following, we illustrate these actions for the module *Sender* from the previ- ously described example. At time 0, actions in the start mode are processed. Output ports are initialized and connected actuators are updated. Then, the sensor *s1* is read and an activation for task *inc* is released. There are no further actions to be processed at time 0. At time 5, which is the end of the LET of the first activation of task *inc*, the task’s output port is updated. Following this, the actuator *a1* is updated. Next, the mode switch condition in the guard function *exitMain* is evaluated. This causes sen- sor *s1* to be read, and the value is provided as input to *exitMain*. If the guard evaluates to true, a mode switch to the empty mode *freeze* is performed, and no further actions are processed. Otherwise, the module remains in the mode, and the next activation for task *inc* is released. Figure 6.4 shows the periodic execution pattern of the task *inc* in mode *main* of module *Sender* and of the task *clientTask* of module *Receiver*.

In Section 6.2.4, we describe and compare the integration of TDL with the two simulation environments MATLAB and Simulink and Ptolemy. As these two envi- ronments are quite different, this requires two entirely different integration strate- gies. This applies to both modeling and simulation. Whereas Ptolemy is open source, targeted to support different models of computation, and highly adaptable even for fundamental elements, MATLAB and Simulink is proprietary and more restrictive in its adaptability.

 

 



   Sender

in mode main



inc               inc               inc               inc



 



Receiver



clientTask



clientTask



0                 5                 10                15               20      *t*

**FIGURE 6.4** Periodic execution of the tasks *inc* and *clientTask*.

[6.1 <--- ](6_1.md) [   Зміст   ](README.md) [--> 6.3](6_3.md)