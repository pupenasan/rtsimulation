[10.1 <--- ](10_1.md) [   Зміст   ](README.md) [--> 10.3](10_3.md)

## 10.2. PREVIOUS WORK

A hardware/software (HW/SW) codesign flow [2] usually starts at system level, when the boundaries between the hardware and software parts of the final system have not yet been established. After functional verification, the HW/SW partitioning takes place and co-simulation is used to validate and refine the system. The tight time-to-market constraints, the high complexity of current designs, and the low simulation speed of instruction set simulators (ISSs) push for the addition of (RT)OS models in system-level hardware description languages (HDL) (such as SystemC or SpecC). This allows native execution of both the hardware and software models of the system, consistently accelerating simulation. In addition, as both hardware and software partitions are described using the same HDL, it is easy to move functionalities between them. Such ideas have been presented in work that models the application, the hardware, and the services of the RTOS using the same HDL [3–6]. Because of limitations in the typical HDL processing model, true concurrency is not achieved, and a trade-off has to be determined between simulation speed and accuracy of the intertask interaction models. When the design is refined, the RTOS model can be translated automatically into software services. Unfortunately, however, in practice, the use of a widely adopted RTOS is preferred, meaning that results taken during the modeling phase are no longer accurate.

An extension to these works has been implemented by Schirner and Domer [7] addressing the problem of modeling preemption, interrupts, and intertask interactions in abstract RTOS models. Their work mainly concentrates on simulating the system timing behavior, and the code equivalence problem is not taken into account. He et al. [8] present a configurable RTOS model implemented on top of SystemC:

> as opposed to other approaches, only the software part of the system is modeled, while the hardware portion is taken into account only by means of timing annotations inside the RTOS model.

A different technique is used in Yoo et al. [1] for automatic generation of timed OS simulation models. These models partially reuse unmodified OS primitives, thus mitigating the code equivalence problem. High emulation speed is obtained, thanks to native execution on the host machine, but the timing of the target architecture is not accurately replicated and it does not allow precise modeling of multiprocessor systems. In contrast, we use ISSs in our approach, which implies lower simulation speed but also, as the assembly code of the final application is used, minimization of the code equivalence problem. Our approach is also OS-independent, enabling broader DSE.

An untimed abstract model of an RTOS is presented in Honda et al. [9]. The model supports all the services of the *µITRON* standard; therefore, it can be used with a wide range of applications, but this work is applied only to uniprocessor systems.

Similar goals are pursued in Posadas et al. [6] by mapping OS thread management primitives to SystemC. However, because of limitations in the SystemC process model, true concurrency cannot be achieved. Girodias et al. [10] also address the lack of support for embedded software development by working in the .NET environment and by mapping hardware tasks to eSys.net processes and software tasks to an abstract OS interface mapped onto .NET threads. A further refinement step allows the mapping of software tasks on a Win32 port of the chosen target OS.

All these approaches help the designer to perform and refine the HW/SW partition, but they do not help in the validation of the high-level design (for the code equivalence problem) and they are limited in the assessment of the system’s timing properties. However, the execution on an ISS of the exact same software that will be deployed on the embedded system is seldom possible because the RTOS has to be already chosen and ported to the target hardware, meaning that it may be difficult or even impossible to refine the HW/SW partitioning (since the OS should be updated accordingly) and to explore alternative system configurations.

This chapter proposes a way to emulate RTOS primitives to minimize *code equivalence* issues while still maintaining both *independence from a specific OS* and *high timing accuracy*.

[10.1 <--- ](10_1.md) [   Зміст   ](README.md) [--> 10.3](10_3.md)