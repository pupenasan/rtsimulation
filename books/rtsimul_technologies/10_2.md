[10.1 <--- ](10_1.md) [   Зміст   ](README.md) [--> 10.3](10_3.md)

## 10.2. PREVIOUS WORK

A hardware/software (HW/SW) codesign flow [2] usually starts at system level, when the boundaries between the hardware and software parts of the final system have not yet been established. After functional verification, the HW/SW partitioning takes place and co-simulation is used to validate and refine the system. The tight time-to-market constraints, the high complexity of current designs, and the low simulation speed of instruction set simulators (ISSs) push for the addition of (RT)OS models in system-level hardware description languages (HDL) (such as SystemC or SpecC). This allows native execution of both the hardware and software models of the system, consistently accelerating simulation. In addition, as both hardware and software partitions are described using the same HDL, it is easy to move functionalities between them. Such ideas have been presented in work that models the application, the hardware, and the services of the RTOS using the same HDL [3–6]. Because of limitations in the typical HDL processing model, true concurrency is not achieved, and a trade-off has to be determined between simulation speed and accuracy of the intertask interaction models. When the design is refined, the RTOS model can be translated automatically into software services. Unfortunately, however, in practice, the use of a widely adopted RTOS is preferred, meaning that results taken during the modeling phase are no longer accurate.

Потік кодування апаратного/програмного забезпечення (HW/SW) [2] зазвичай починається на рівні системи, коли межі між апаратною та програмною частинами кінцевої системи ще не встановлені. Після функціональної перевірки виконується розділення апаратного/програмного забезпечення та використовується спільне моделювання для перевірки та вдосконалення системи. Жорсткі терміни виходу на ринок, висока складність поточних проектів і низька швидкість моделювання симуляторів набору інструкцій (ISS) спонукають до додавання моделей (RT)ОС на мовах опису апаратного забезпечення системного рівня (HDL) (таких як як SystemC або SpecC). Це дозволяє нативно виконувати як апаратну, так і програмну моделі системи, постійно прискорюючи моделювання. Крім того, оскільки як апаратні, так і програмні розділи описані за допомогою одного HDL, між ними легко переміщувати функціональні можливості. Такі ідеї були представлені в роботі, яка моделює додаток, апаратне забезпечення та сервіси ОСРВ з використанням того самого HDL [3–6]. Через обмеження типової моделі обробки HDL не досягається справжнього паралелізму, і потрібно визначити компроміс між швидкістю моделювання та точністю моделей взаємодії між завданнями. Після вдосконалення дизайну модель ОСРВ може бути автоматично переведена в програмні служби. Однак, на жаль, на практиці перевага надається широко поширеній ОСРВ, що означає, що результати, отримані на етапі моделювання, більше не є точними.

An extension to these works has been implemented by Schirner and Domer [7] addressing the problem of modeling preemption, interrupts, and intertask interactions in abstract RTOS models. Their work mainly concentrates on simulating the system timing behavior, and the code equivalence problem is not taken into account. He et al. [8] present a configurable RTOS model implemented on top of SystemC:

Розширення цих робіт було реалізовано Ширнером і Домером [7], присвяченому проблемі моделювання випередження, переривання та взаємодії між завданнями в абстрактних моделях ОСРВ. Їхня робота в основному зосереджена на моделюванні поведінки синхронізації системи, а проблема еквівалентності коду не береться до уваги. Він та ін. [8] представляє конфігуровану модель RTOS, реалізовану поверх SystemC:

> as opposed to other approaches, only the software part of the system is modeled, while the hardware portion is taken into account only by means of timing annotations inside the RTOS model.

A different technique is used in Yoo et al. [1] for automatic generation of timed OS simulation models. These models partially reuse unmodified OS primitives, thus mitigating the code equivalence problem. High emulation speed is obtained, thanks to native execution on the host machine, but the timing of the target architecture is not accurately replicated and it does not allow precise modeling of multiprocessor systems. In contrast, we use ISSs in our approach, which implies lower simulation speed but also, as the assembly code of the final application is used, minimization of the code equivalence problem. Our approach is also OS-independent, enabling broader DSE.

Інша техніка використовується в Yoo et al. [1] для автоматичної генерації часових імітаційних моделей ОС. Ці моделі частково повторно використовують немодифіковані примітиви ОС, таким чином пом’якшуючи проблему еквівалентності коду. Висока швидкість емуляції досягається завдяки власному виконанню на головній машині, але синхронізація цільової архітектури не точно відтворюється, і це не дозволяє точно моделювати багатопроцесорні системи. На відміну від цього, ми використовуємо ISS у нашому підході, що передбачає нижчу швидкість моделювання, але також, оскільки використовується код складання кінцевої програми, мінімізує проблему еквівалентності коду. Наш підхід також не залежить від ОС, що дозволяє розширити DSE.

An untimed abstract model of an RTOS is presented in Honda et al. [9]. The model supports all the services of the *µITRON* standard; therefore, it can be used with a wide range of applications, but this work is applied only to uniprocessor systems.

Нехронологічна абстрактна модель ОСРВ представлена в Honda et al. [9]. Модель підтримує всі сервіси стандарту *µITRON*; отже, його можна використовувати з широким спектром додатків, але ця робота застосовується лише до однопроцесорних систем.

Similar goals are pursued in Posadas et al. [6] by mapping OS thread management primitives to SystemC. However, because of limitations in the SystemC process model, true concurrency cannot be achieved. Girodias et al. [10] also address the lack of support for embedded software development by working in the .NET environment and by mapping hardware tasks to eSys.net processes and software tasks to an abstract OS interface mapped onto .NET threads. A further refinement step allows the mapping of software tasks on a Win32 port of the chosen target OS.

Подібні цілі переслідують Posadas et al. [6] шляхом відображення примітивів управління потоками ОС на SystemC. Однак через обмеження в моделі процесу SystemC неможливо досягти справжнього паралелізму. Гіродіас та ін. [10] також вирішує проблему відсутності підтримки розробки вбудованого програмного забезпечення, працюючи в середовищі .NET і відображаючи апаратні завдання на процеси eSys.net і програмні завдання на абстрактний інтерфейс ОС, відображений на потоки .NET. Подальший крок уточнення дозволяє зіставляти програмні завдання на порт Win32 вибраної цільової ОС.

All these approaches help the designer to perform and refine the HW/SW partition, but they do not help in the validation of the high-level design (for the code equivalence problem) and they are limited in the assessment of the system’s timing properties. However, the execution on an ISS of the exact same software that will be deployed on the embedded system is seldom possible because the RTOS has to be already chosen and ported to the target hardware, meaning that it may be difficult or even impossible to refine the HW/SW partitioning (since the OS should be updated accordingly) and to explore alternative system configurations.

Усі ці підходи допомагають розробнику виконати та вдосконалити розділ апаратного та програмного забезпечення, але вони не допомагають у перевірці високорівневого проекту (для проблеми еквівалентності коду) і вони обмежені в оцінці властивостей синхронізації системи. Однак виконання на ISS точно такого ж програмного забезпечення, яке буде розгорнуто у вбудованій системі, рідко можливо, оскільки ОСРВ має бути вже обрано та перенесено на цільове обладнання, а це означає, що може бути важко або навіть неможливо вдосконалити Розбиття апаратного/програмного забезпечення (оскільки ОС слід оновити відповідним чином) і дослідити альтернативні конфігурації системи.

This chapter proposes a way to emulate RTOS primitives to minimize *code equivalence* issues while still maintaining both *independence from a specific OS* and *high timing accuracy*.

У цьому розділі пропонується спосіб емуляції примітивів RTOS, щоб мінімізувати проблеми з *еквівалентністю коду*, зберігаючи при цьому *незалежність від конкретної ОС* і *високу точність синхронізації*.

[10.1 <--- ](10_1.md) [   Зміст   ](README.md) [--> 10.3](10_3.md)