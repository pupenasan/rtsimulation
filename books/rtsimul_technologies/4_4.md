[4.3 <--- ](4_3.md) [   Зміст   ](README.md) [--> 5](5.md)

## 4.4. ВИСНОВОК

In this chapter, we introduced several metaprogramming techniques for improving program performance that can be used in the development of real-time software [54,55]. The optimization of the real-time simulation code can include low-level optimizations such as loop unrolling and recoding critical parts in assembly language or even in microcode. In this chapter, we considered optimization at a much higher level that we did not find in the current state of the art in real-time simulation. We discussed different code generation techniques (generation of data and instructions) and also presented the input of DSLs, programming or modeling languages dedicated to a particular domain. MSPLs were also discussed; they include constructs for concisely building object programs guaranteed to be syntactically correct. This class of programming languages includes C++, through the use of TMP. Finally, we offered some insights on partial evaluation, a powerful and automatic method for specializing programs to obtain better performance such as shorter execution time and lower memory footprint. Each of these approaches has already been successfully applied to real-time programming, as can be seen in the numerous references provided. We also proposed a comparison of all the techniques described. A table will help in selecting the most appropriate technique given a set of requirements, since no technique is universally optimal. To provide a more detailed case study using a specific technique, we presented how C++ TMP can be used to develop a DEVS metasimulator exhibiting significant improvements over traditional simulators.

У цій главі ми представили кілька методів метапрограмування для покращення продуктивності програми, які можна використовувати при розробці програмного забезпечення реального часу [54,55]. Оптимізація коду симуляції в реальному часі може включати оптимізацію низького рівня, таку як розгортання циклу та перекодування критичних частин на мові асемблера або навіть у мікрокоді. У цьому розділі ми розглянули оптимізацію на набагато вищому рівні, якого ми не знайшли в поточному стані техніки моделювання в реальному часі. Ми обговорили різні методи генерації коду (генерація даних і інструкцій), а також представили вхідні дані DSL, мови програмування або моделювання, призначені для певної області. Також обговорювалися MSPL; вони містять конструкції для стислої побудови об’єктних програм, які гарантовано будуть синтаксично правильними. Цей клас мов програмування включає C++ через використання TMP. Нарешті, ми запропонували деякі відомості про часткову оцінку, потужний і автоматичний метод для спеціалізації програм для отримання кращої продуктивності, наприклад, скорочення часу виконання та меншого обсягу пам’яті. Кожен із цих підходів уже був успішно застосований до програмування в реальному часі, як можна побачити в численних наданих посиланнях. Ми також запропонували порівняння всіх описаних методик. Таблиця допоможе вибрати найбільш прийнятну техніку з огляду на набір вимог, оскільки жодна техніка не є універсально оптимальною. Щоб надати більш детальне прикладне дослідження з використанням конкретної техніки, ми представили, як C++ TMP можна використовувати для розробки метасимулятора DEVS, що демонструє значні покращення порівняно з традиційними симуляторами.

The next avenue we want to investigate is applying metaprogramming techniques to multicore programming. A more powerful architecture must be considered when a simulation runs slower than real time. The increase in raw computing performance is now linked to parallel architectures. Among these architectures, the GP-GPU (General-Purpose Graphical Processing Unit) technology is an easy, inexpensive, and efficient way to allow processing of large data on a personal computer. Much currently available literature has already revealed that it is possible to use the computational capability of GPUs to implement real-time simulations of complex models [56–58]. However, to make the most of it, the development work is still substantial, mainly because of the slow memory accesses that often force the developer to significantly modify the sequential implementation. The new generation of GP-GPU and the template facilities of the latest release of the NVIDIA C/C++ compiler will help in making up for many of these problems. Together with the increase of computational power and the additional fast local memory available on the GPU cards, it will allow developers to implement much more efficient real-time simulations for various domains.

Наступним напрямком, який ми хочемо дослідити, є застосування методів метапрограмування до багатоядерного програмування. Якщо симуляція працює повільніше, ніж у реальному часі, слід розглянути можливість використання більш потужної архітектури. Підвищення продуктивності необроблених обчислень тепер пов’язане з паралельними архітектурами. Серед цих архітектур технологія GP-GPU (універсальний графічний процесор) є простим, недорогим і ефективним способом обробки великих даних на персональному комп’ютері. Багато наявної на даний момент літератури вже показали, що можна використовувати обчислювальні можливості GPU для реалізації моделювання складних моделей у реальному часі [56–58]. Однак, щоб максимально використати це, робота над розробкою все ще є значною, головним чином через повільний доступ до пам’яті, який часто змушує розробника суттєво модифікувати послідовну реалізацію. Нове покоління GP-GPU і засоби шаблонів останнього випуску компілятора NVIDIA C/C++ допоможуть вирішити багато з цих проблем. Разом зі збільшенням обчислювальної потужності та додатковою швидкою локальною пам’яттю, доступною на картах GPU, це дозволить розробникам реалізувати набагато ефективніші симуляції в реальному часі для різних доменів.

[4.3 <--- ](4_3.md) [   Зміст   ](README.md) [--> 5](5.md)

