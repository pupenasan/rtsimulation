[21 <--- ](21.md) [   Зміст   ](README.md) [--> 21.2](21_2.md)

## 21.1 INTRODUCTION

The Automotive Open System Architecture (AUTOSAR) development partnership, which includes several carmakers or original equipment manufacturers (OEMs), car electronics (Tier 1) suppliers, and tool and software vendors, has been created to develop an open industry standard for automotive software architectures. The AUTOSAR standardization effort spans across all software levels, from device drivers to the operating system, the communication abstraction layers, the network stacks, and also the specification of application-level components.

Партнерство з розробки Automotive Open System Architecture (AUTOSAR), яке включає кілька автовиробників або виробників оригінального обладнання (OEM), постачальників автомобільної електроніки (Tier 1), а також постачальників інструментів і програмного забезпечення, було створено для розробки відкритого галузевого стандарту для архітектури автомобільного програмного забезпечення. . Зусилля зі стандартизації AUTOSAR охоплюють усі рівні програмного забезпечення, від драйверів пристроїв до операційної системи, рівнів абстракції зв’язку, мережевих стеків, а також специфікації компонентів прикладного рівня.

The current version of the standard includes several specifications, which can be roughly classified into

•   A standard specification for the definition of application software components (SWCs), their interfaces, and an environment for their cooperation at the functional level.

•   A standard for the definition of the cooperation of *component behaviors*, including the definition of the events that are relevant for executing the *runnables* of components, which are defined as procedures executed in reaction to events.

Поточна версія стандарту включає кілька специфікацій, які можна приблизно класифікувати

• Стандартна специфікація для визначення компонентів прикладного програмного забезпечення (SWC), їх інтерфейсів і середовища для їх взаємодії на функціональному рівні.

• Стандарт для визначення взаємодії *поведінок* компонентів, включаючи визначення подій, які мають відношення до виконання *запусків* компонентів, які визначаються як процедури, що виконуються у відповідь на події.

•   A reference software *platform architecture*, encapsulating the basic software (BSW) (operating system and device drivers included) and providing a middleware layer for the execution of components and their interactions (including communication and exchange of signals and events).

•   A standard format for the (coarse grain) description of distributed *hardware architectures*, the description of the mapping of runnables to tasks, and the mapping of those onto the execution architecture.

•   A *metamodel* formalizing all the above.

• Еталонне програмне забезпечення *архітектура платформи*, що інкапсулює базове програмне забезпечення (BSW) (включно з операційною системою та драйверами пристроїв) і забезпечує рівень проміжного програмного забезпечення для виконання компонентів та їх взаємодії (включаючи зв’язок та обмін сигналами та подіями).

• Стандартний формат для (грубого) опису розподілених *апаратних архітектур*, опису відображення виконуваних елементів у завдання та відображення їх у архітектурі виконання.

• *метамодель*, яка формалізує все вищесказане.

In addition, AUTOSAR defines a development model (or, more appropriately, major steps and cornerstones in the development process) with automated support by tools and a common interchange format, based on XML, for model information at all stages in the process.

Крім того, AUTOSAR визначає модель розробки (або, точніше, основні кроки та наріжні камені в процесі розробки) з автоматизованою підтримкою за допомогою інструментів і загального формату обміну на основі XML для інформації про модель на всіх етапах процесу.

The AUTOSAR project has focused on the concepts of location independence, interface standardization, and code portability. The initial purpose was to enable the transition from Federated Architectures to Integrated Architectures. In a Federated Architecture, suppliers provide a node or electronic control unit (ECU) to be integrated in a network for each major functionality, which caused a proliferation of nodes and complex dependencies on network messages. In an Integrated Architecture, OEMs provide the specification of SWCs to suppliers, who are responsible for their development according to a standardized interface. OEMs can then integrate SWCs on an architecture platform of their choice. This type of portability and modularity requires the definition of a standard for SWCs, which includes the definition of their interfaces and a standard application program interface (API) for interacting with the software abstracting the physical platform. Hence, the AUTOSAR model has been strongly oriented to the representation of typical interactions among software packages and its semantics is strongly oriented to the modeling of cooperating procedures, rather than the representation of a formal model of computation (MoC) with a mathematical underpinning.

Проект AUTOSAR зосереджений на концепціях незалежності від місця розташування, стандартизації інтерфейсу та переносимості коду. Початковою метою було забезпечити перехід від об’єднаних архітектур до інтегрованих архітектур. У федеративній архітектурі постачальники надають вузол або електронний блок керування (ECU) для інтеграції в мережу для кожної основної функції, що спричинило поширення вузлів і складні залежності від мережевих повідомлень. В інтегрованій архітектурі OEM-виробники надають специфікації SWC постачальникам, які відповідають за їх розробку відповідно до стандартизованого інтерфейсу. Потім OEM-виробники можуть інтегрувати SWC на платформі архітектури на свій вибір. Цей тип переносимості та модульності вимагає визначення стандарту для SWC, який включає визначення їхніх інтерфейсів і стандартного інтерфейсу прикладної програми (API) для взаємодії з програмним забезпеченням, що абстрагує фізичну платформу. Таким чином, модель AUTOSAR була чітко орієнтована на представлення типових взаємодій між пакетами програмного забезпечення, а її семантика чітко орієнтована на моделювання взаємодіючих процедур, а не на представлення формальної моделі обчислень (MoC) з математичною основою.

Later, with the evolution of the standard, the goal has become more ambitious and AUTOSAR is becoming a candidate for full-fledged system-level modeling, including capabilities for simulation and (worst-case) timing analysis or possibly even other types of analysis (such as reliability) that are required on system-level models.

Пізніше, з розвитком стандарту, мета стала більш амбітною, і AUTOSAR стає кандидатом на повноцінне моделювання на системному рівні, включаючи можливості для моделювання та (найгіршого випадку) аналізу часу або, можливо, навіть інших типів аналізу ( такі як надійність), які необхідні для моделей системного рівня.

The need for better control over the emergent behavior, the opportunity for analysis (by simulation or other formal method), and the need for controlling integration of heterogeneous models (for example Simulink® subsystems [1]) led the consortium to the specification of the AUTOSAR metamodel, which however, is still far from being based on a formal MoC.

Потреба в кращому контролі над поведінкою, що виникає, можливість аналізу (шляхом моделювання або іншим формальним методом), а також потреба в контрольній інтеграції гетерогенних моделей (наприклад, підсистем Simulink® [1]) привели консорціум до специфікації Метамодель AUTOSAR, яка, однак, ще далека від того, щоб базуватися на офіційному MoC.

To give an example, the notion of time and timed events was only introduced in the latest (4.0) release of the standard [2], with the goal of enabling worst-case timing analysis of response times at the level of specifications. Unfortunately, it appears that the timed event model is at best cumbersone if the purpose is, for example, to build a common discrete-time base for a system-wide AUTOSAR model integrating synchronous reactive (SR) models as subsystems. In addition, currently there is no tool support for the use of timed events.

Для прикладу, поняття часу та синхронізованих подій було введено лише в останній (4.0) версії стандарту [2] з метою забезпечення найгіршого аналізу часу відгуку на рівні специфікацій. На жаль, здається, що модель подій із синхронізацією в кращому випадку є громіздкою, якщо її метою є, наприклад, побудувати загальну базу дискретного часу для загальносистемної моделі AUTOSAR, яка об’єднує синхронні реактивні (SR) моделі як підсистеми. Крім того, наразі не існує інструментальної підтримки для використання тимчасових подій.

With respect to the goal of simulation, AUTOSAR is clearly oriented toward the following: the simulation of functionality considering the structure of the SWCs and their actual code implementation; the implications of the mapping of the runnables to the elements of the execution architecture; and of scheduling issues and other platform-related delays, such as communication latency and operating system or device-driver delays. As such, AUTOSAR models and tools can be used for both hardware-in-the-loop (HIL) or software-in-the loop simulations (see also the classification in the chapter at Ref. [3]) and can be performed in real time or in logical time. AUTOSAR is not suited to the representation of continuous-time systems.

Щодо мети моделювання, AUTOSAR чітко орієнтований на наступне: моделювання функціональності з урахуванням структури SWC та їх реальної кодової реалізації; наслідки відображення виконуваних елементів на елементи архітектури виконання; а також проблеми з плануванням та інші затримки, пов’язані з платформою, такі як затримка зв’язку та затримки операційної системи чи драйвера пристрою. Таким чином, моделі та інструменти AUTOSAR можна використовувати як для моделювання апаратного забезпечення в циклі (HIL), так і для моделювання програмного забезпечення в циклі (див. також класифікацію в розділі за посиланням [3]) і можуть виконуватися в реального часу або в логічному часі. AUTOSAR не підходить для представлення систем безперервного часу.

Therefore, its use in a model-in-the-loop framework will require integration with other tools (such as Simulink). These tools either provide the plant model and cooperate in a cosimulation environment or produce the code implementations for the models of the missing (continuous-time) systems. AUTOSAR models are a better fit to simulate the controller part. However, the lack of support for a detailed behavioral model makes their use unlikely in the early stages. AUTOSAR runnables are intended to be simple entry points for a code procedure. Even when the runnable behavior is available as a dataflow or as a state machine (or other type of model), either a cosimulation environment linking other tools (such as Simulink) to an AUTOSAR simulation engine or (more likely) the actual code implementation is required.

Таким чином, його використання в структурі моделі в циклі вимагатиме інтеграції з іншими інструментами (такими як Simulink). Ці інструменти або надають модель заводу та співпрацюють у середовищі спільного моделювання, або створюють реалізації коду для моделей відсутніх систем (з безперервним часом). Моделі AUTOSAR краще підходять для імітації частини контролера. Однак відсутність підтримки детальної моделі поведінки робить їх використання малоймовірним на ранніх стадіях. Виконувані файли AUTOSAR призначені як прості точки входу для процедури коду. Навіть якщо виконувана поведінка доступна як потік даних або кінцевий автомат (або інший тип моделі), або середовище спільного моделювання, що зв’язує інші інструменти (такі як Simulink) із механізмом моделювання AUTOSAR, або (більш ймовірно) фактична реалізація коду вимагається.

In conclusion, with respect to the framework outlined in the previous chapter, an AUTOSAR model can be simulated either right before or right after the availability of a real-time executable. The underlying model is a discrete event model based on the available framework of the run-time environment (RTE) events (described in the following sections). An AUTOSAR model can be constructed for the simulation of discrete-time systems by leveraging timed events (although creating a global-time framework is not necessarily an easy task, given that periodic timed events are local to each component).

На завершення, щодо структури, описаної в попередньому розділі, модель AUTOSAR може бути змодельована безпосередньо перед або одразу після появи виконуваного файлу в реальному часі. Базовою моделлю є модель дискретних подій, заснована на доступній структурі подій середовища виконання (RTE) (описано в наступних розділах). Модель AUTOSAR може бути побудована для симуляції систем з дискретним часом, використовуючи події, визначені в часі (хоча створення глобальної рамки часу не обов’язково є легким завданням, враховуючи, що періодичні події є локальними для кожного компонента).

Also, with respect to the task of model verification, the lack of a clear semantics with respect to time makes any type of formal verification of correctness in model- to-model transformations difficult or even impossible altogether.

Крім того, щодо завдання верифікації моделі, відсутність чіткої семантики щодо часу робить будь-який тип формальної перевірки правильності перетворень між моделями складним або навіть неможливим взагалі.

We provide first a short introduction to AUTOSAR and its main concepts. Next, we discuss issues related to the possibility of using an AUTOSAR description of the system for simulating its behavior at increasing levels of accuracy with respect to the model of the execution platform. Finally, issues related to the necessity of maintaining a consistent view of the models that are used for simulation, timing analysis, and code generation are discussed.

Спочатку ми пропонуємо короткий вступ до AUTOSAR та його основних концепцій. Далі ми обговорюємо питання, пов’язані з можливістю використання опису AUTOSAR системи для моделювання її поведінки з підвищенням рівня точності щодо моделі платформи виконання. Нарешті, обговорюються питання, пов’язані з необхідністю підтримки узгодженого уявлення про моделі, які використовуються для моделювання, аналізу часу та генерації коду.

[21 <--- ](21.md) [   Зміст   ](README.md) [--> 21.2](21_2.md)