[1.1 <--- ](1_1.md) [   Зміст   ](README.md) [--> 1.3](1_3.md)

## 1.2. DISCRETE MODELING

As previously stated, a discrete model is one in which the state of the simuland is assumed to change only at specific instances in time. There are two major types of system that can be simulated using discrete models.

### 1.2.1 Queuing Models

The first and probably most familiar type of discrete model is based on queuing models. In a typical queuing model, entities such as customers or parts arrive at service points representing operators or service units, which process them in turn. The waiting entities form queues, and both the arrival times of new entities and the service times of the servers are often generated from statistical distributions using random number generators. Changes in the state of the system caused by queue arrivals or departures, or a completion of service, are referred to as *events* and the time at which the event occurs is the *event time*.

A simulation based on a discrete model establishes an initial state of the system and a future event queue with event timings. The simulation then advances to the first of these event times, and the appropriate changes are made to the system state. These changes may generate changes in the entries in the event queue, including the identification of additional events, and the event queue is modified accordingly. Once the current system state is fully established, the simulation moves on to the next event and the process is repeated. This repeated sequence continues until the simulation satisfies some terminating condition. Models of this kind are used extensively to represent manufacturing plants, distribution networks, service facilities and systems, business operations, and many other applications.

Over time, three main approaches have been developed for simulations that use these models, known as the activity-based, event-based, and process-based methods. Historically, the term *activity-based simulation* was used to describe simulations in which time advances in small steps with checks for changes at each step. More recently, the term has also been used for Discrete Event System Specification (DEVS) simulations, where only components that are potentially active are evaluated (e.g., in fire spread applications, where only the cells modeling the fire front are evaluated) [1,2]. The original kind of activity-based simulation is inefficient and suitable only for simple applications. Event-based simulation in which time advances from event to event in a single software thread has been the basis of many popular discrete simulation languages, but, as parallel computing options increase, process- based simulation using parallel processors and multiple software threads has become the more popular approach. In this approach, the simulation is divided into processes that can be run in parallel [3]. Each process schedules its events in the correct order, but out-of-order execution can occur in which a process receives an event from another process with an event time that is earlier than its current time. Two strate- gies are used for dealing with this problem known as *conservative* and *optimistic synchronization*. Conservative synchronization requires a process to block its next impending event until it is certain that it is safe. Optimistic synchronization uses a roll-back approach when an out-of-order event occurs. This approach is discussed further in Section 1.2.4. 

### 1.2.2 Digital System Models

As noted above, there are two distinct types of discrete model, the queuing models described in Section 1.2.1 and models that are used to represent systems that can be described by means of difference equations or z-transforms. These digital system models include digital electronic circuits and systems, and sampled-data and digital control systems in which the discrete subsystem is updated at typically equally spaced time intervals [4].

This type of discrete model consists of a set of difference equations that define the next state of the system in terms of its current and past states and its external inputs. If the model is defined, in its entirety or in part, by means of z-transforms, it is usually a straightforward task to convert the z-transform model into difference equation form.

Given a difference equation model, and once the initial state of the system is established, the simulation proceeds by advancing time incrementally by the speci- fied time step and calculating the state of the system at each step. This method is widely used in the simulation of all kinds of digital electronic circuits, computer systems, and digital controllers. As mentioned earlier, a continuous simulation is itself a process of this kind.

### 1.2.3 DEVS Formalism

In 1976, Zeigler [1] introduced DEVS, a formalism based on General System Theory that provides a means of specifying a mathematical object called a system. The DEVS conceptual framework consists of three basic objects: the *model*, the *simula- tor*, and the *experimental frame*. The model is a set of instructions that are intended to replicate system behavior, the simulator exercises these instructions to generate the behavior, and the experimental frame describes the way in which the model will be exercised by the simulator. The following description, taken from the introduction to a DEVS tutorial by Zeigler and Sargoujhian [5], draws an interesting comparison between discrete and continuous models:

The Discrete Event System Specification (DEVS) formalism provides a means of specifying a mathematical object called a system. Basically, a system has a time base, inputs, states, and outputs, and functions for determining next states and outputs given current states and inputs. Discrete event systems represent certain constellations of such parameters just as continuous systems do. For example, the inputs in discrete event systems occur at arbitrarily spaced moments, while those in continuous systems are piecewise continuous functions of time.

Although its name, and the above description, suggests that DEVS is restricted to discrete-event models, it has also been extended to continuous models as described by Cellier and Kofman [6]. It is therefore capable of representing hybrid models. Several software products have been developed that are based on DEVS including simulation with continuous and real-time DEVS models [2]. 

### 1.2.4 Time Management for Discrete Simulation

The management of time in a discrete simulation is based on knowledge of the times of future events, which are either known *a priori* or are maintained in a prioritized event queue with priorities that are determined by the time ordering of the events in the queue. It is not necessary to know the time of all events at the start of a simulation but in many cases, as long as the time of the next event is known, time management becomes fairly straightforward. The simulation will begin with a specification of the initial state of the system (length of various queues, status of the queue servers, etc.), and some future events can be determined using the random number generators to generate event times (arrival times, service times, etc.) for the various elements in the system. Time is then advanced to the next event time and appropriate changes made to the state of the system. A queue length may be increased or decreased by an arrival in the queue or by a completion of service; a unit may be seized or released by the simulation and so on. The simulation proceeds alternating between updating the system state as the result of an event and advancing time to the next event. The ter- minal event time is determined by the termination condition set by the programmer.

As mentioned above, it is becoming common to use a parallel-processing approach to accelerate execution times particularly for process-based discrete simulation soft- ware. Using this approach, time may advance in an unsynchronized way on different processors or when using different software threads. This can cause one part of the simulation to advance beyond the generation in another processor or thread of an event that affects it. Conservative scheduling can be used to delay execution of a process until it is safe to do so. Alternatively, optimistic scheduling includes techniques for time to be rolled back so that the effect of an event that has advanced too far in time on the state of the system can be determined. An example of this technique, developed by David Jefferson, is known as *Time Warp* [7]. Because of the need to facilitate roll back of time, these methods are probably not viable for most real-time applications. 

### 1.2.5 Software for Discrete Simulation

Many software products have been developed over the years aimed at supporting discrete-event simulation. Well-known examples include General Purpose Simulation Systems, Simscript, SIMAN/Arena, Simula, and Dymola/Modelica. The Simula language [8] is notable in that it was the first object-oriented, process-based, discrete simulation language having been first released in the 1960s. As stated above, there are also several software products based on the DEVS formalism.

Simulation of digital electronics, digital control, and sampled-data systems can be accomplished using digital hardware design software such as VHDL or Verilog, which combine a specification of the system with a simulator to test the design.

### 1.2.6 Example of a Discrete-Event Simulation

A simple example of a discrete-event simulation is described by Matloff and Davis [9]. It involves two machines that break down from time to time and must be repaired. In one variation, a single repair technician is available. Machine uptime and repair time are exponentially distributed with mean values set by the programmer. Events occur when a machine breaks down and when a repair is completed and a machine returns to service. If a second machine breaks down while the first is being repaired, it goes into a waiting queue until the repair technician is available. Clearly, this problem could be extended to include, for example, more machines, possibly with different uptimes and repair times, and different numbers and types of technicians.



[1.1 <--- ](1_1.md) [   Зміст   ](README.md) [--> 1.3](1_3.md)