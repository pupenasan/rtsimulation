[1.1 <--- ](1_1.md) [   Зміст   ](README.md) [--> 1.3](1_3.md)

## 1.2. ДИСКРЕТНЕ МОДЕЛЮВАННЯ

Як було сказано раніше, дискретна модель — це модель, у якій передбачається, що стан симулянду змінюється лише в певні моменти часу. Існує два основних типи систем, які можна моделювати за допомогою дискретних моделей.

### 1.2.1 Моделі черг (Queuing Models)

Перший і, мабуть, найвідоміший тип дискретної моделі заснований на моделях черг. У типовій моделі черги такі об’єкти, як замовники або деталі, надходять до пунктів обслуговування, що представляють операторів або підрозділи обслуговування, які по черзі їх обробляють. Об’єкти, що очікують, формують черги, і як час прибуття нових об’єктів, так і час обслуговування серверів часто генеруються зі статистичних розподілів за допомогою генераторів випадкових чисел. Зміни в стані системи, спричинені надходженням або відправленням черги, або завершенням обслуговування, називаються ***подіями (events)***, а час, коли відбувається подія, є ***часом події (event time)***.

Імтіаційне моделювання на основі дискретної моделі встановлює початковий стан системи та майбутню чергу подій із часом подій. Потім імітаційна модель переходить до першого з цих моментів часу події, і в стан системи вносяться відповідні зміни. Ці зміни можуть генерувати зміни в записах у черзі подій, включаючи ідентифікацію додаткових подій, і черга подій відповідно змінюється. Коли поточний стан системи повністю встановлено, імітаційна модель переходить до наступної події, і процес повторюється. Ця повторювана послідовність продовжується доти, доки імітаційна модель не задовольнить певну кінцеву умову. Моделі такого типу широко використовуються для представлення виробничих підприємств, розподільних мереж, об’єктів і систем обслуговування, бізнес-операцій і багатьох інших застосувань.

З часом було розроблено три основні підходи до імітаційного моделювання, які використовують ці моделі, відомі як методи на основі діяльності (activity-based), на основі подій (event-based) і на основі процесу (process-based). Історично термін ***імітаціне моделювання на основі діяльності (activity-based)*** використовувався для опису імітаційного моделювання, у якому час рухається невеликими кроками з перевіркою змін на кожному кроці. Зовсім недавно цей термін також використовувався для моделювання специфікації системи дискретних подій (DEVS, Discrete Event System Specification), де оцінюються лише компоненти, які потенційно активні (наприклад, у програмах поширення пожежі, де оцінюються лише комірки, що моделюють фронт пожежі) [1, 2]. Оригінальний вид моделювання на основі діяльності неефективний і підходить лише для простих зстосувань. ***Імітаціне моделювання на основі подій (Event-based)***, у якому час просувається від події до події в одному програмному потоці, була основою багатьох популярних дискретних мов моделювання, але зі збільшенням можливостей паралельних обчислень став більш популярний підхід  ***імітаційного моделювання на основі процесів (process-based)*** з використанням паралельних процесорів і кількох програмних потоків . У цьому підході моделювання поділяється на процеси, які можна запускати паралельно [3]. Кожен процес планує свої події в правильному порядку, але може статися виконання поза чергою, коли процес отримує подію від іншого процесу з часом події, який є раніше, ніж його поточний час. Для вирішення цієї задачі використовуються дві стратегії, відомі як ***консервативна (conservative)*** та ***оптимістична синхронізація (optimistic synchronization)***. Консервативна синхронізація вимагає, щоб процес блокував свою наступну заплановану подію, поки не буде впевнено, що вона безпечна. Оптимістична синхронізація використовує підхід відкату, коли відбувається подія, яка не відповідає порядку. Цей підхід обговорюється далі в розділі 1.2.4.

### 1.2.2 Моделі цифрових систем (digital system models)

Як зазначалося вище, існує два різних типи дискретної моделі: моделі черг, описані в розділі 1.2.1, і моделі, які використовуються для представлення систем, що можна описати за допомогою різницевих рівнянь або z-перетворень. Ці моделі цифрових систем (digital system models) включають цифрові електронні схеми та системи, а також дискретні системи керування та збору даних, в яких дискретна підсистема оновлюється через типові однакові інтервали часу [4].

Цей тип дискретної моделі складається з набору різницевих рівнянь, які означують наступний стан системи з точки зору її поточного та минулого станів та її зовнішніх вхідних даних. Якщо модель означена повністю або частково за допомогою z-перетворень, зазвичай легко перетворити модель z-перетворення у форму різницевого рівняння.

Враховуючи модель різницевого рівняння та коли початковий стан системи встановлено, імітаційне моделювання продовжується шляхом поступового збільшення часу на вказаний крок часу та обчислення стану системи на кожному кроці. Цей метод широко використовується при моделюванні всіх видів цифрових електронних схем, комп'ютерних систем і цифрових регуляторів. Як згадувалося раніше, безперервне імітаційне моделювання саме по собі є процесом такого роду.

### 1.2.3 Формалізм DEVS 

У 1976 році Zeigler [1] представив DEVS, формалізм, заснований на загальній теорії систем, який надає засоби специфікації математичного об'єкта, який називається системою. Концептуальна структура DEVS складається з трьох основних об’єктів: *моделі (model)*, *імітаційної моделі (simulator)* та *експериментальної рамки (experimental frame)*. Модель — це набір інструкцій, які призначені для повторення поведінки системи, імітаційна модель виконує ці інструкції, щоб генерувати поведінку, а експериментальна рамка описує спосіб, у який модель буде використовуватися імітаційною моделлю. У наступному описі, взятому зі вступу до навчального посібника з DEVS Цайглером і Саргуджіаном [5], наводиться цікаве порівняння дискретних і безперервних моделей:

Формалізм Специфікації системи дискретних подій (Discrete Event System Specification (**DEVS**) ) забезпечує засоби специфікації математичного об’єкта, який називається системою. По суті, система має часову базу, входи, стани та виходи, а також функції для означення наступних станів і виходів з урахуванням поточних станів і входів. Системи дискретних подій як і безперервні системи представляють певні плеяди таких параметрів. Наприклад, входи в системах із дискретними подіями відбуваються в довільно віддалені моменти, тоді як у неперервних системах є кусково-неперервними функціями часу.

Хоча його назва та наведений вище опис свідчать про те, що DEVS обмежено моделями з дискретними подіями, його також було розширено до безперервних моделей, як описано Сельє та Кофманом [6]. Тому він здатний представляти гібридні моделі. Було розроблено кілька програмних продуктів, які базуються на DEVS, включаючи моделювання з моделями DEVS безперервного та реального часу [2].

### 1.2.4 Керування часом для дискретного імітаційного моделювання

Управління часом при дискретному імітаційному моделюванні базується на знанні часу майбутніх подій, які або відомі *апріорі*, або зберігаються в пріоритетній черзі подій з пріоритетами, які визначаються часовим порядком подій у черзі. Не обов'язково знати час усіх подій на початку симуляції, але в багатьох випадках, поки відомий час наступної події, керування часом стає досить простим. Симуляція розпочнеться зі специфікації початкового стану системи (довжина різних черг, статус серверів черг тощо), а деякі майбутні події можна визначити за допомогою генераторів випадкових чисел для генерації часу подій (час надходження, час обслуговування тощо) для різних елементів системи. Потім час переноситься до часу наступної події та вноситься відповідні зміни до стану системи. Довжина черги може бути збільшена або зменшена за прибуттям у чергу або за завершенням обслуговування; підрозділ може бути захоплений або звільнений мітаціним моделюванням тощо. Імітаційне моделювання продовжується по черзі між оновленнями стану системи в результаті події та просуванням часу до наступної події. Час кінцевої події означується умовою завершення, встановленою програмістом.

Як згадувалося вище, стає поширеним використання підходу паралельної обробки для прискорення часу виконання, особливо для програмного забезпечення для дискретного моделювання на основі процесів. Використовуючи цей підхід, час може рухатися несинхронізовано на різних процесорах або при використанні різних програмних потоків. Це може призвести до того, що одна частина імітаціного моделювання виходить за рамки генерації в іншому процесорі або потоці події, яка на неї впливає. Можна використовувати консервативне планування, щоб відкласти виконання процесу, поки це не стане безпечним. Як альтернатива, оптимістичне планування включає методи відкату часу, щоб можна було визначити вплив події, яка зайшла занадто далеко в часі щодо визнчення стану системи. Приклад цієї техніки, розробленої Девідом Джефферсоном, відомий як *Time Warp* [7]. Через необхідність полегшити відкат часу ці методи, ймовірно, непридатні для більшості застосувань реального часу.

### 1.2.5 Програмне забезпечення для дискретного моделювання

Протягом багатьох років було розроблено багато програмних продуктів, спрямованих на підтримку дискретно-подієвого імтаційного моделювання. Добре відомі приклади включають системи моделювання загального призначення, Simscript, SIMAN/Arena, Simula та Dymola/Modelica. Мова Simula [8] примітна тим, що це була перша об’єктно-орієнтована мова дискретного моделювання, заснована на процесах, яка була вперше випущена в 1960-х роках. Як було зазначено вище, існує також кілька програмних продуктів, заснованих на формалізмі DEVS.

Моделювання цифрової електроніки, цифрового керування та систем збору даних можна здійснити за допомогою програмного забезпечення для проектування цифрового апаратного забезпечення, такого як VHDL або Verilog, яке поєднує специфікацію системи з імітаційною моделлю для тестування конструкції.

### 1.2.6 Приклад дискретно-подієвого (Discrete-Event) імітаційного моделювання 

Простий приклад **дискретно-подієвого (Discrete-Event)** імітаційного моделювання описано Матлоффом і Девісом [9]. У ньому беруть участь дві машини, які час від часу ламаються і потребують ремонту. В одному варіанті доступний один майстер з ремонту. Час роботи машини та час ремонту експоненціально розподілені із середніми значеннями, встановленими програмістом. Події відбуваються, коли машина виходить з ладу, і коли ремонт завершено, і машина повертається до експлуатації. Якщо друга машина виходить з ладу під час ремонту першої, вона потрапляє в чергу очікування, доки не з’явиться технік з ремонту. Зрозуміло, що цю проблему можна розширити, щоб включити, наприклад, більше машин, можливо, з різним часом безвідмовної роботи та часом ремонту, а також різною кількістю та типами техніків.

[1.1 <--- ](1_1.md) [   Зміст   ](README.md) [--> 1.3](1_3.md)