[11.3 <--- ](11_3.md) [   Зміст   ](README.md) [--> 11.5](11_5.md)

## 11.4. SERVICE REQUESTS

As mentioned briefly before, all intermodel communication is modeled using service requests exchanged via active–passive interface connections.

A service request can be viewed as a communication transaction between two components, similar to the concept of transaction-level modeling [11]. However, it is the implementation of the two service models that will determine if the service request will be implemented as a function call from, for example, a sequential executing piece of code to a function library or if it will be a bus transfer. Communication refinement is supported in several ways. Service requests can include arbitrary data structures as preferred by the designer of the model. If a communication channel must be modeled, an extra service model can be inserted between the two primary communicating service models as illustrated in Figure 11.3. The extra service model

 

​                                                                                           

​            Model      A      Active interface            

​            Model B      Passive interface            







(a)

​                  

​            Model      A            

​            Model B            

​            interface            

​            Active            

​            interface            

​            Passive            

​            interface            

​            Passive            

​            interface            

​            Active            

​            communication channel            

​            Interchange structure/            







(b)

**FIGURE 11.3** Intermodel communication. a) Model A is the active model, initiating communication with model B. b) The communication medium is now modeled explicitely using a separate service model.



**266**                                       Real-Time Simulation Technologies

 

inserted will be transparent to the two communicating service models. This allows, for example, simple properties such as reliability of the communication channel to be modeled. More elaborate communication interconnects such as buses and networkon-chips can also be modeled.

A service request specifies the requested service, a list of arguments (which can be empty), and a unique request number used to identify the service request, for example, to annotate it with a cost. The argument list can be used to provide input arguments to the implementation of a service, for example, to allow modeling of dynamic dependencies or arithmetic operations on actual data values. Depending on the implementation of the service model, an arbitrary number of service requests can be processed in parallel, for example, modeling operating system schedulers, pipelines, very long instruction word, single instruction multiple data, and super scalar architectures.

A service request can be requested as either blocking or nonblocking. It is the designer of a model who determines whether a service request is requested as a blocking or a nonblocking request. The request of a blocking service request implies that the process of the source model that requested the service request is put into its blocked state until it has been executed, indicated by the destination model, as illustrated in Figure 11.4. A nonblocking service request, on the other hand, will be requested and the process of the source model, which requested the service request, will proceed—not waiting for the execution of the request to finish.

 

​            

​          Req          

​          Done          



M1                       M2



 

 



Active



Idle



 

 

 

 

 



Blocked



Active



 

 

 

 

 

Active                             Idle

 

 

 

**FIGURE 11.4** A process of model *M*1 requests a blocking service request from *M*2. *M*1 is blocked till the completion of the request.



Service-Based Simulation Framework                             **267**

 

A number of events are associated with a service request to notify the requester and receiver model of different phases of the lifetime of the service request. The lifetime and corresponding events of a service request are as follows:

 

\1.   The service request is being requested, indicated by a service request requested event.

\2.   The service request is being accepted for processing of the model by which it is requested, indicated by a service request accepted event.

\3.   The service request may be blocked, indicated by a service request blocked event.

\4.   The service request has been executed, indicated by a service request done event.

 

When a service request is being requested at a model interface, the receiver model has the possibility of receiving a notification to change its status to active. The requesting service model will similarly have the possibility of being notified when the request is accepted for processing in the receiver model (i.e., before the actual execution of the service request) and when it has finished executing the service request. During the evaluation of a service request, the request itself can become blocked because of one or more requirements not being fulfilled (e.g., because of mutually exclusive access to resources and missing availability of data operands). When a service request is being blocked during evaluation, the source model is notified to allow it to take appropriate actions, if any. However, the author of the requesting service model need not be interested in receiving these notifications and, hence, the model is allowed to ignore these. In this way, it is the designer who chooses event sensitivity for the individual processes of the service model implementation.

To handle multiple simultaneous service requests, the designer of a service model must incorporate a desired arbitration scheme. The arbitration scheme may be an integrated part of the model or it may be a separate service model itself. The latter is often advantageous if different arbitration schemes are to be investigated.

[11.3 <--- ](11_3.md) [   Зміст   ](README.md) [--> 11.5](11_5.md)