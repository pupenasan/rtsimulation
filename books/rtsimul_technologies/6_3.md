[6.2 <--- ](6_2.md) [   Зміст   ](README.md) [--> 6.4](6_4.md)

## 6.3. TDL INTEGRATION WITH MATLAB® AND SIMULINK®

Simulink builds on MATLAB (both products by MathWorks) [6] and has become the de facto standard for the modeling and simulation of real-time systems in various domains such as automotive, avionics, and aerospace. First attempts to integrate TDL with MATLAB and Simulink started as early as the initial development of TDL in 2003 [17]. In Simulink, systems are modeled in a visual and interactive environment using (mostly time-based) block diagrams. Code generators may then automatically translate the block diagrams into software, for example, into C code.

According to the results described in Ref. [18], manually implementing LET semantics in Simulink is strongly discouraged. Even simple models of single-mode systems are cluttered with additional blocks to ensure that the timing behavior in the simulation conforms to LET semantics. It turned out that it is practically infeasible to model LET-based applications with multimodal behavior by hand, even when using the Simulink extension Stateflow® [6]. In the following, we describe an approach that is based on an explicit timing specification with TDL. For the simulation, the TDL specification is automatically translated into a Simulink model with an E-machine implementation at its core. In this sense, MATLAB and Simulink represents yet another execution platform for TDL modules.

### 6.3.1 Appl ication Developer’s Perspect ive

We will start with a developer’s perspective of the TDL integration with MATLAB and Simulink that covers the modeling, the simulation, and finally the platform mapping and the code generation.

#### 6.3.1.1 Extension of the TDL Toolchain for MATLAB® and Simulink®

Figure 6.5 outlines the TDL toolchain when used together with MathWorks tools. Real-Time Workshop® Embedded Coder™ [20] (RTW-EC in Figure 6.5) can be used to generate the C source code for the TDL task implementations. The so-called

![image-20220822003557786](E:\san\Технології\моделиров\gitver_rtsimul\books\rtsimul_technologies\media\image-20220822003557786.png)

**FIGURE 6.5** TDL toolchain in MATLAB® and Simulink®.

TDL:VisualCreator tool allows the visual and interactive modeling of TDL applications. For mapping TDL modules to specific platforms, that is, for organizing the various build steps, we provide the so-called TDL:VisualDistributor tool. It allows a developer to 

- Define a hardware topology. This can be a single node or a cluster consisting of potentially heterogeneous nodes that are connected, for example, through a time-triggered Ethernet.

- Assign the individual TDL modules to their target nodes.


A built-in code and schedule generation framework generates platform-specific code, a communication schedule in the case of a distributed platform, makefiles, and any other output required for a particular platform [4].

#### 6.3.1.2 Modeling

The modeling typically comprises two principal components: the controller and the plant. The plant is modeled as usual in MATLAB and Simulink. The controller is modeled with one or multiple *TDL module block(s)* (Figure 6.6) available in the TDL library.

![image-20220822003657906](E:\san\Технології\моделиров\gitver_rtsimul\books\rtsimul_technologies\media\image-20220822003657906.png)

**FIGURE 6.6** Modeling with the TDL toolchain in MATLAB® and Simulink®.

Each TDL module block represents one TDL module. Instead of using the textual representation of TDL, the module is edited using the TDL:VisualCreator tool that opens when double-clicking a TDL module block. The TDL module is two-way synchronized with Simulink. This means that a change in the TDL:VisualCreator, such as adding a sensor, is immediately reflected in the Simulink representation of the particular TDL module and vice versa. A sensor of the TDL module is represented as *Inport*, and an actuator is represented as *Outport* of the TDL module block. A task is represented as a (*Function-Call) Subsystem* that resides within the TDL module block. Within this subsystem, the functionality of the task may be modeled with appropriate library blocks (excluding those that comprise continuous-time behavior) with inherited sample time. [Figure 6.6 ](#_bookmark38)shows the previously described TDL example within a MATLAB and Simulink model and the two tools TDL:VisualCreator and TDL:VisualDistributor. The TDL:VisualCreator tool lists the individual elements such as the sensor *s1* and the task *inc* of module *Sender* in a tree representation. The activities of mode *main*, for example, are shown in the right-hand half of the frame. Their timing is specified through properties in the table below the tree representation. 

#### 6.3.1.3 Simulation

The overall system can be simulated once the application developer has finished the modeling phase, that is, timing behavior has been specified using the TDL:VisualCreator, whereas controller functionality and plant behavior have been modeled with Simulink blocks. From the developer’s point of view, there is no observable difference to starting a simulation if there were no TDL blocks present. This is achieved by an internal model translation (as sketched in the toolchain) to ensure that the simulation corresponds with the TDL specification. In fact, during the simulation, the compiled TDL program is executed within an E-machine encapsulated in a Simulink S-function. Details of how this is accomplished are described below.

As the TDL code and the schedule generators ensure that the timing behavior of TDL modules is equivalent when executed on a single node and when distributed among multiple nodes, the simulation can assume execution is on a single node and it is not necessary to account for any communication behavior.

#### 6.3.1.4 Platform Mapping and Code Generation

To generate code for the application, the target platform must be specified. This is performed with the TDL:VisualDistributor tool that is integrated with Simulink as a *TDL Distribution block* (see the shaded box in the top-right corner of the Simulink model in Figure 6.6). The platform involves the specification of the (potentially heterogeneous) node platforms, their interconnections within the cluster, and the communication protocol. For this purpose, the developer may choose from a set of available node (such as a dSpace MicroAutoBox for prototyping) and cluster (such as FlexRay) plug-ins. After every TDL module of the Simulink model has been assigned to a node, the developer may start the generation of platform-specific code, a communication schedule in the case of distributed platforms, makefiles, and any other required output. If desired, the TDL:VisualDistributor tool can also trigger the RTW-EC to generate C code for all the tasks of the TDL modules.

### 6.3.2 Implementation Perspective

On an embedded hardware platform, the E-machine represents the core piece for a LET-based execution. E-machine implementations exist for several different platforms [21]. For the TDL integration with MATLAB and Simulink, we implemented an E-machine that is based on a Simulink S-function [18]. An S-function is a Simulink block that references a user-defined functionality implemented in a programming language such as C and compiled by the *MATLAB EXecutable (MEX)* compiler. In this way, the built-in Simulink blockset can be extended. S-functions are composed of *callback methods* that the Simulink engine executes at particular points during the simulation.

As the S-function implements the E-code interpreter, it must be invoked whenever the simulation time matches the logical time of a TDL activity, as defined in the E-code. According to the E-code instructions, the S-function triggers the execution of Simulink Function-Call Subsystems. Each task and each guard is represented as a Function-Call Subsystem that is provided by the developer. Additional Function- Call Subsystems are generated automatically as part of the model translation when the simulation is started. They implement the port assignment operations, for exam- ple, to update an actuator port with the value of a task output port.

Figure 6.7 exemplifies this E-machine approach for a simplified application. The placement of the individual blocks conforms to the data flow, which is basically from left to right along the arrows from a source to a sink. The source value is read by a sensor, which provides the value to a guard and a task. The actuator block uses the output port of a task to write to a sink. The E-machine triggers the individual blocks according to the E-code resulting in the indicated order (1–6). The input port of such a generated subsystem is directly connected to the output port, which corresponds to an assignment in the imperative programming paradigm as soon as the system is triggered. This ensures the correct LET behavior of a task activation, for example, when triggering its release and termination at the correct time instants. Both fixed and variable sample time approaches for the E-machine are possible [22]. The suggested value for a fixed sample time is the GCD (greatest common divisor) of all activity periods.

![image-20220822003808458](E:\san\Технології\моделиров\gitver_rtsimul\books\rtsimul_technologies\media\image-20220822003808458.png) 

**FIGURE 6.7** Basic principle of an E-machine as a Simulink® S-function and Function-Call Subsystems. 

#### 6.3.2.1 Resolving Data Dependencies

The S-function implementation of the E-machine for a simulation environment is analogous to E-machine implementations for hardware platforms. Compared to other simulation approaches, such a Simulink E-machine results in an efficient simulation model [18]. However, because of data dependency problems that can occur in simulation environments, the practical applicability of this basic mechanism turned out to be limited. We identified the following application scenarios that in general cannot be handled by this integration concept:

- •   Cyclic import relationships between LET-based controllers (TDL modules)

- •   Control loops involving plants without delay

- •   Control loops with mixed LET-based and conventionally modeled controllers


These cases are discussed in detail in Ref. [22]. They are all related to cyclic data flow dependencies and the ability of the simulation environment to find a valid strategy for executing each individual block. Like many other simulation environments, Simulink does not support cycles without a delay except for special cases [23]. Delays are introduced by explicit delay blocks or by other blocks whose output is not directly controlled by the input (although possibly dependent on the block state). Those blocks are said to have indirect (or nondirect) feedthrough. When Function- Call Subsystems are involved, Simulink reports a *data dependency violation*, which is similar to an *algebraic loop error* [24], when attempting to simulate a model with a direct data dependency cycle. From the control engineer’s point of view, this appears to be counterintuitive, since the LET of a task is always greater than zero and thus should introduce the required delay. The problem is that the simulation environment is not aware of this LET characteristic.

In Ref. [25], we propose an E-machine implementation that consists of two interacting S-functions. Without violating the TDL specification, that is, without changing the timing behavior of the simulation, this approach introduces additional delay blocks to resolve the cyclic dependencies. This *two-step E-machine architecture* is capable of simulating these three scenarios with cyclic data flow dependencies and also supports TDL applications with mixed timeand event-triggered (asynchronous) activities [22]. In the case of simulating event-triggered activities, the simulation of events and the corresponding reaction cannot be guaranteed to match the behavior on a specific target platform. This is because asynchronously activated tasks do not have a LET and also because the simulation is not aware of any scheduling strategy, distribution topology, or CPU speed of the target platform.

[6.2 <--- ](6_2.md) [   Зміст   ](README.md) [--> 6.4](6_4.md)