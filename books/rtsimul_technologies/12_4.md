[12.3 <--- ](12_3.md) [   Зміст   ](README.md) [--> 12.5](12_5.md)

## 12.4. DISCUSSION

In this section, we discuss our consistency checking approach, including its strengths and weaknesses. We demonstrated our approach for consistency management based on queries and constraints on a reduced subset of UML and its MARTE profile. The goal of this work was to demonstrate the feasibility of the approach by providing a case study where we were able to identify inconsistencies in UML models. Thus, the translation we gave assigned a semantics only to a subset of the modeling elements defined in UML and MARTE. However, even using this reduced subset we were able to detect and formally verify the inconsistency between models of our BART case study including timing constraints. Because our translation binds query and constraint tuples to single entities in the UML metamodel, an extension to the full language definition of UML 2.0 and its different profiles is straightforward, albeit complex. Such an extension requires us to decide on a precise semantics for each diagram. Therefore, we must fix how each syntactic element of each diagram contributes to its semantics.

У цьому розділі ми обговорюємо наш підхід до перевірки узгодженості, включаючи його сильні та слабкі сторони. Ми продемонстрували наш підхід до управління узгодженістю на основі запитів і обмежень на зменшеній підмножині UML і його профілі MARTE. Мета цієї роботи полягала в тому, щоб продемонструвати здійсненність підходу шляхом надання прикладу, де ми змогли виявити невідповідності в моделях UML. Таким чином, переклад, який ми надали, присвоїв семантику лише підмножині елементів моделювання, визначених у UML і MARTE. Однак, навіть використовуючи цю зменшену підмножину, ми змогли виявити та офіційно перевірити невідповідність між моделями нашого прикладу BART, включаючи часові обмеження. Оскільки наш переклад прив’язує кортежі запитів і обмежень до окремих сутностей у метамоделі UML, розширення до повного визначення мови UML 2.0 і його різних профілів є простим, хоча й складним. Таке розширення вимагає від нас визначення точної семантики для кожної діаграми. Тому ми повинні визначити, як кожен синтаксичний елемент кожної діаграми впливає на її семантику.

Tailoring our consistency notion to a particular target domain (real-time distributed systems in this case) may, at first, seem limiting. However, we argue that a completely general definition of consistency for a general purpose language such as UML ultimately limits the applicability of consistency checking to very abstract models or to purely structural notions of consistency (without taking the notion of behavior into account). This claim is supported by our analysis of the related work. We observe in [Tables 12.2 ](#_bookmark71)and 12.3 that all approaches that dealt with behavior consistency translated UML to some other language supporting a specific target domain. Similarly, our approach precisely defines the semantic space for both structural and behavioral consistency—albeit at the expense of complete generality. If we decide to target a different domain, a new target model and updated translation rules are necessary.

Пристосування нашого поняття узгодженості до конкретного цільового домену (у цьому випадку розподілених систем реального часу) може спочатку здатися обмеженим. Проте ми стверджуємо, що цілком загальне визначення узгодженості для мови загального призначення, такої як UML, зрештою обмежує застосовність перевірки узгодженості до дуже абстрактних моделей або до суто структурних понять узгодженості (не беручи до уваги поняття поведінки). Це твердження підтверджується нашим аналізом відповідної роботи. У [таблицях 12.2] (#_bookmark71) і 12.3 ми спостерігаємо, що всі підходи, які стосуються узгодженості поведінки, перекладають UML на іншу мову, що підтримує певний цільовий домен. Подібним чином наш підхід точно визначає семантичний простір як для структурної, так і для поведінкової узгодженості — хоча й за рахунок повної загальності. Якщо ми вирішимо націлити інший домен, потрібна нова цільова модель і оновлені правила перекладу.

Different decisions in how to interpret diagrams can lead to different translations. For example, we decided to interpret sequence diagrams universally regarding the messages exchanged. Each message represented in the diagram is exchanged and messages not represented are not. In contrast, state transitions are not part of our translation of sequence diagrams. This is why we set the Clock in the query of row 2 of [Table 12.4 ](#_bookmark75)as greater than the time the previous message was sent without setting a specific interval. This is equivalent to a commitment to eventually have a state in which the constraint is true.

Різні рішення щодо інтерпретації діаграм можуть призвести до різних перекладів. Наприклад, ми вирішили інтерпретувати діаграми послідовності універсально щодо повідомлень, якими обмінюються. Кожне повідомлення, представлене на діаграмі, обмінюється, а повідомлення, які не представлені, – ні. Навпаки, переходи станів не є частиною нашого перекладу діаграм послідовностей. Ось чому ми встановлюємо Годинник у запиті рядка 2 [Таблиці 12.4] (#_bookmark75) як більше, ніж час, коли було надіслано попереднє повідомлення, не встановлюючи певний інтервал. Це еквівалентно зобов’язанню зрештою мати стан, у якому обмеження є істинним.

The definitions of horizontal and vertical consistencies we gave seem adequate for the domain of real-time systems. However, when a richer subset of UML will become amenable to translation and more experience is acquired in verifying it, we see potential for reevaluating the definitions. One possible area of concern with the current definition arises when we allow side effects between the queries and constraints of multiple diagrams, in other words, nonlocal constraints. In this case we could change the definition of horizontal consistency, for instance, to yield inconsistency if the majority of the queries do not match.

Наведені нами визначення горизонтальної та вертикальної узгодженості здаються адекватними для сфери систем реального часу. Однак, коли багатша підмножина UML стане піддатливою для перекладу і буде придбано більше досвіду в її перевірці, ми бачимо потенціал для переоцінки визначень. Одна з можливих проблем із поточним визначенням виникає, коли ми допускаємо побічні ефекти між запитами та обмеженнями кількох діаграм, іншими словами, нелокальні обмеження. У цьому випадку ми могли б змінити визначення горизонтальної узгодженості, наприклад, щоб отримати невідповідність, якщо більшість запитів не збігаються.

The benefit of moving from the abstract domain of UML metamodels to the query and constraint abstract language is that the translation rules define the semantics and implicitly also the consistency rules. We can then avoid enumerating a long list of consistency rules and obtaining a very simple definition of consistency.

Перевага переходу від абстрактної області метамоделей UML до абстрактної мови запитів і обмежень полягає в тому, що правила перекладу визначають семантику і неявно також правила узгодженості. Тоді ми можемо уникнути перерахування довгого списку правил узгодженості та отримати дуже просте визначення узгодженості.

With this approach, we have converted the problem of detecting the consistency of graphs based on the UML metamodel to verifying emptiness of sets. The sets are defined by logical formulae, each defining the effect of one model element on the system runs. The composition of specifications is defined by set intersection. Additionally we have presented a modularity theorem (Theorem 12.1) that enables reasoning on separate subsets of the query/constraint specifications. This setup is amenable to translation into propositional LTL and supports use of many automatic formal verification tools, such as SAT solvers. We have provided Theorem 12.2 that affirms the equivalence of proving that an LTL expression is satisfiable with horizontal consistency of the corresponding specification.

За допомогою цього підходу ми перетворили проблему виявлення узгодженості графів на основі метамоделі UML на перевірку порожнечі множин. Набори визначаються логічними формулами, кожна з яких визначає вплив одного елемента моделі на роботу системи. Склад специфікацій визначається перетином множин. Крім того, ми представили теорему модульності (теорема 12.1), яка дозволяє міркувати на окремих підмножинах специфікацій запиту/обмеження. Це налаштування піддається перекладу в пропозиційний LTL і підтримує використання багатьох автоматичних формальних інструментів перевірки, таких як розв’язувачі SAT. Ми надали теорему 12.2, яка підтверджує еквівалентність доведення того, що LTL-вираз задовольняє горизонтальну узгодженість відповідної специфікації.

We evaluate the query and constraint approach we proposed by identifying how it addresses the 12 requirements we identified in [Table 12.1](#_bookmark70).

Ми оцінюємо запропонований нами підхід до запитів і обмежень, визначаючи, як він відповідає 12 вимогам, які ми визначили в [таблиці 12.1] (#_bookmark70).

*R1. Support inconsistent models*. We address this requirement by not forcing the user to remove inconsistencies. Models that are inconsistent can be identified by identifying the tuples that are in contradiction. More modeling elements can be added and more contradictions detected before the system is made consistent.

*R1. Підтримка неузгоджених моделей*. Ми виконуємо цю вимогу, не змушуючи користувача вилучати невідповідності. Неузгоджені моделі можна ідентифікувати шляхом ідентифікації кортежів, які суперечать. Можна додати більше елементів моделювання та виявити більше протиріч, перш ніж система стане узгодженою.

*R2. Automatic inconsistency discovery*. Inconsistencies are discovered by hand in our example. The goal was to show the complexity of the problem and a possible solution. It is possible, however, to automate translation (which leverages the UML metamodel used by all UML modeling tools) and detection to discover inconsistencies automatically. Furthermore, inconsistencies can be tracked by identifying the subset of specifications that are in contradiction.

*R2. Автоматичне виявлення невідповідності*. У нашому прикладі невідповідності виявляються вручну. Мета полягала в тому, щоб показати складність проблеми та можливе вирішення. Однак можна автоматизувати переклад (який використовує метамодель UML, що використовується всіма інструментами моделювання UML) і виявлення для автоматичного виявлення невідповідностей. Крім того, невідповідності можна відстежувати, визначаючи підмножину специфікацій, які суперечать.

*R3. Support inconsistency resolution*. The support to resolve inconsistencies is provided by the ability to identify a small subset of the specification that is sufficient to prove the inconsistency (this property stems from the Modularity Theorem).

*R3. Підтримка вирішення невідповідностей*. Підтримка усунення невідповідностей забезпечується можливістю ідентифікувати невелику підмножину специфікації, достатню для підтвердження невідповідності (ця властивість випливає з теореми модульності).

*R4. Support multiple modeling languages*. The query and constraint approach supports multiple languages by creating different translation rules from the UML metamodel to the abstract target language. It could also support languages that are not UML as long as they are based on a metamodel and a translation is provided.

*R4. Підтримка кількох мов моделювання*. Підхід запитів і обмежень підтримує кілька мов шляхом створення різних правил перекладу з метамоделі UML на абстрактну цільову мову. Він також може підтримувати мови, які не є UML, якщо вони базуються на метамоделі та надається переклад.

*R5. Support different levels of abstraction*. We have identified different consistency rules and translation rules to support different levels of abstraction.

*R6. Support extensions*. We demonstrated the support for extensions of UML providing a translation rule for the MARTE profile.

*R7. Support horizontal consistency*. We provided two horizontal consistency definitions.

*R8. Support vertical consistency*. We provided one definition for vertical consistency.

*R9. Support static consistency*. This approach supports static consistency by querying entity properties and channel messages and by constraining them.

*R5. Підтримка різних рівнів абстракції*. Ми визначили різні правила узгодженості та правила перекладу для підтримки різних рівнів абстракції.

*R6. Підтримка розширень*. Ми продемонстрували підтримку розширень UML, надаючи правило перекладу для профілю MARTE.

*R7. Підтримка горизонтальної послідовності*. Ми надали два визначення горизонтальної узгодженості.

*R8. Підтримка вертикальної узгодженості*. Ми надали одне визначення для вертикальної узгодженості.

*R9. Підтримка статичної узгодженості*. Цей підхід підтримує статичну узгодженість, запитуючи властивості сутності та повідомлення каналу та обмежуючи їх.

 **TABLE** **12.5**  **Evaluation** **of** **the** **Consistency** **Checking** **Presented** **in** **This** **Chapter**

| **Translation** **Target** **Language**                      | **R1** | **R2** | **R3** | **R4** | **R5** | **R6** | **R7** | **R8** | **R9** | **R10** | **R11** | **R12** |      |
| ------------------------------------------------------------ | ------ | ------ | ------ | ------ | ------ | ------ | ------ | ------ | ------ | ------- | ------- | ------- | ---- |
| Queries and Constraints                                      | ✓      | ✓      | ✓      | ✓      | ✓      | ✓      | ✓      | ✓      | ✓      | ✓       | ✓       | ✓       |      |
| *Note:* The  symbol ✓ indicates  that the requirement is met. |        |        |        |        |        |        |        |        |        |         |         |         |      |

*R10. Support dynamic consistency*. The approach supports dynamic consistency by constraining the properties of different states in admissible runs. By leveraging LTL logic and the Clock, it is possible to set constraints on consecutive states or future states.

*R10. Підтримка динамічної узгодженості*. Підхід підтримує динамічну узгодженість шляхом обмеження властивостей різних станів у допустимих прогонах. Використовуючи логіку LTL і годинник, можна встановити обмеження на послідовні стани або майбутні стани.

*R11. Provide tool support*. While we have not provided any tool support for this approach, we have demonstrated that a translation of the consistency problem to SAT of LTL formulae exists (Theorem 12.2). The translation from UML to another domain can be automated and because we can encode queries and constraints in LTL, we can use existing SAT solvers for this logic to automate the verification.

*R11. Забезпечте підтримку інструментів*. Хоча ми не надали інструментальної підтримки для цього підходу, ми продемонстрували, що існує переклад проблеми узгодженості на SAT формул LTL (теорема 12.2). Трансляцію з UML в інший домен можна автоматизувати, і оскільки ми можемо кодувати запити та обмеження в LTL, ми можемо використовувати існуючі розв’язувачі SAT для цієї логіки, щоб автоматизувати перевірку.

*R12. Address scalability*. Thanks to the modularity theorem our approach does not require reasoning about the entire model to identify inconsistencies. This makes it applicable to large models. However, depending on how the different specifications are interconnected, to ensure that no inconsistency exists it may be necessary to compose a large number of tuples, which could slow down the identification of inconsistencies on some models.

*R12. Масштабованість адреси*. Завдяки теоремі про модульність наш підхід не потребує міркування про всю модель для виявлення невідповідностей. Це робить його придатним для великих моделей. Однак, залежно від того, як різні специфікації взаємопов’язані, щоб гарантувати відсутність невідповідності, може знадобитися скласти велику кількість кортежів, що може уповільнити виявлення невідповідностей на деяких моделях.

From this requirements analysis, summarized in Table 12.5, we conclude that the query and constraint approach proposed is a step toward a more comprehensive consistency management approach for UML models. However, more work is required to implement tools to automate the approach and experiment with the effective scalability of such tools by testing them on large industrial-scale system models.

З цього аналізу вимог, узагальненого в таблиці 12.5, ми робимо висновок, що запропонований підхід запитів і обмежень є кроком до більш комплексного підходу до управління узгодженістю для моделей UML. Однак для впровадження інструментів для автоматизації підходу та експериментування з ефективною масштабованістю таких інструментів, тестуючи їх на великих промислових моделях систем, потрібна додаткова робота.

[12.3 <--- ](12_3.md) [   Зміст   ](README.md) [--> 12.5](12_5.md)