[12.3 <--- ](12_3.md) [   Зміст   ](README.md) [--> 12.5](12_5.md)

## 12.4. DISCUSSION

In this section, we discuss our consistency checking approach, including its strengths and weaknesses. We demonstrated our approach for consistency management based on queries and constraints on a reduced subset of UML and its MARTE profile. The goal of this work was to demonstrate the feasibility of the approach by providing a case study where we were able to identify inconsistencies in UML models. Thus, the translation we gave assigned a semantics only to a subset of the modeling elements defined in UML and MARTE. However, even using this reduced subset we were able to detect and formally verify the inconsistency between models of our BART case study including timing constraints. Because our translation binds query and constraint tuples to single entities in the UML metamodel, an extension to the full language definition of UML 2.0 and its different profiles is straightforward, albeit complex. Such an extension requires us to decide on a precise semantics for each diagram. Therefore, we must fix how each syntactic element of each diagram contributes to its semantics.

Tailoring our consistency notion to a particular target domain (real-time distributed systems in this case) may, at first, seem limiting. However, we argue that a completely general definition of consistency for a general purpose language such as UML ultimately limits the applicability of consistency checking to very abstract models or to purely structural notions of consistency (without taking the notion of behavior into account). This claim is supported by our analysis of the related work. We observe in [Tables 12.2 ](#_bookmark71)and 12.3 that all approaches that dealt with behavior consistency translated UML to some other language supporting a specific target domain. Similarly, our approach precisely defines the semantic space for both structural and behavioral consistency—albeit at the expense of complete generality. If we decide to target a different domain, a new target model and updated translation rules are necessary.

Different decisions in how to interpret diagrams can lead to different translations. For example, we decided to interpret sequence diagrams universally regarding the messages exchanged. Each message represented in the diagram is exchanged and messages not represented are not. In contrast, state transitions are not part of our translation of sequence diagrams. This is why we set the Clock in the query of row 2 of [Table 12.4 ](#_bookmark75)as greater than the time the previous message was sent without setting a specific interval. This is equivalent to a commitment to eventually have a state in which the constraint is true.

The definitions of horizontal and vertical consistencies we gave seem adequate for the domain of real-time systems. However, when a richer subset of UML will become amenable to translation and more experience is acquired in verifying it, we see potential for reevaluating the definitions. One possible area of concern with the current definition arises when we allow side effects between the queries and constraints of multiple diagrams, in other words, nonlocal constraints. In this case we could change the definition of horizontal consistency, for instance, to yield inconsistency if the majority of the queries do not match.

The benefit of moving from the abstract domain of UML metamodels to the query and constraint abstract language is that the translation rules define the semantics and implicitly also the consistency rules. We can then avoid enumerating a long list of consistency rules and obtaining a very simple definition of consistency.

With this approach, we have converted the problem of detecting the consistency of graphs based on the UML metamodel to verifying emptiness of sets. The sets are defined by logical formulae, each defining the effect of one model element on the system runs. The composition of specifications is defined by set intersection. Additionally we have presented a modularity theorem (Theorem 12.1) that enables reasoning on separate subsets of the query/constraint specifications. This setup is amenable to translation into propositional LTL and supports use of many automatic formal verification tools, such as SAT solvers. We have provided Theorem 12.2 that affirms the equivalence of proving that an LTL expression is satisfiable with horizontal consistency of the corresponding specification.

We evaluate the query and constraint approach we proposed by identifying how it addresses the 12 requirements we identified in [Table 12.1](#_bookmark70).

*R1. Support inconsistent models*. We address this requirement by not forcing the user to remove inconsistencies. Models that are inconsistent can be identified by identifying the tuples that are in contradiction. More modeling elements can be added and more contradictions detected before the system is made consistent.

*R2. Automatic inconsistency discovery*. Inconsistencies are discovered by hand in our example. The goal was to show the complexity of the problem and a possible solution. It is possible, however, to automate translation (which leverages the UML metamodel used by all UML modeling tools) and detection to discover inconsistencies automatically. Furthermore, inconsistencies can be tracked by identifying the subset of specifications that are in contradiction.

*R3. Support inconsistency resolution*. The support to resolve inconsistencies is provided by the ability to identify a small subset of the specification that is sufficient to prove the inconsistency (this property stems from the Modularity Theorem).

*R4. Support multiple modeling languages*. The query and constraint approach supports multiple languages by creating different translation rules from the UML metamodel to the abstract target language. It could also support languages that are not UML as long as they are based on a metamodel and a translation is provided.

*R5. Support different levels of abstraction*. We have identified different consistency rules and translation rules to support different levels of abstraction.

*R6. Support extensions*. We demonstrated the support for extensions of UML providing a translation rule for the MARTE profile.

*R7. Support horizontal consistency*. We provided two horizontal consistency definitions.

*R8. Support vertical consistency*. We provided one definition for vertical consistency.

*R9. Support static consistency*. This approach supports static consistency by querying entity properties and channel messages and by constraining them.

 **TABLE** **12.5**  **Evaluation** **of** **the** **Consistency** **Checking** **Presented** **in** **This** **Chapter**

| **Translation** **Target** **Language**                      | **R1** | **R2** | **R3** | **R4** | **R5** | **R6** | **R7** | **R8** | **R9** | **R10** | **R11** | **R12** |      |
| ------------------------------------------------------------ | ------ | ------ | ------ | ------ | ------ | ------ | ------ | ------ | ------ | ------- | ------- | ------- | ---- |
| Queries and Constraints                                      | ✓      | ✓      | ✓      | ✓      | ✓      | ✓      | ✓      | ✓      | ✓      | ✓       | ✓       | ✓       |      |
| *Note:* The  symbol ✓ indicates  that the requirement is met. |        |        |        |        |        |        |        |        |        |         |         |         |      |

*R10. Support dynamic consistency*. The approach supports dynamic consistency by constraining the properties of different states in admissible runs. By leveraging LTL logic and the Clock, it is possible to set constraints on consecutive states or future states.

*R11. Provide tool support*. While we have not provided any tool support for this approach, we have demonstrated that a translation of the consistency problem to SAT of LTL formulae exists (Theorem 12.2). The translation from UML to another domain can be automated and because we can encode queries and constraints in LTL, we can use existing SAT solvers for this logic to automate the verification.

*R12. Address scalability*. Thanks to the modularity theorem our approach does not require reasoning about the entire model to identify inconsistencies. This makes it applicable to large models. However, depending on how the different specifications are interconnected, to ensure that no inconsistency exists it may be necessary to compose a large number of tuples, which could slow down the identification of inconsistencies on some models.

From this requirements analysis, summarized in Table 12.5, we conclude that the query and constraint approach proposed is a step toward a more comprehensive consistency management approach for UML models. However, more work is required to implement tools to automate the approach and experiment with the effective scalability of such tools by testing them on large industrial-scale system models.

[12.3 <--- ](12_3.md) [   Зміст   ](README.md) [--> 12.5](12_5.md)