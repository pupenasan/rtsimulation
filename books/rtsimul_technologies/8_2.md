[8.1 <--- ](8_1.md) [   Зміст   ](README.md) [--> 8.3](8_3.md)

## 8.2. ARCHITECTURE OF A SIMULATION WITH THE VALIDATOR

Remember that a simulation with the Validator is a closed-loop co-simulation of the plant under control and the controller tasks. Currently, the Validator supports continuous-time plant models in MATLAB® [6] and Simulink. For that purpose, a communication interface was implemented as a MATLAB and Simulink S-function (see [Figure 8.6](#_bookmark49)). The underlying protocol for communication between the plant and the simulation with the Validator is TCP/IP. So both simulations can execute in parallel on the same computer or on different cores or, for example, for efficiency reasons, on different computers. We will extend the Validator to support co-simulation with other simulation environments in the future. For that purpose, communication interfaces must be implemented for the particular simulation environment.

Пам’ятайте, що симуляція за допомогою Validator – це спільне моделювання контрольованої установки та завдань контролера в замкнутому циклі. В даний час Validator підтримує безперервні моделі заводів у MATLAB® [6] і Simulink. З цією метою було реалізовано комунікаційний інтерфейс як S-функцію MATLAB і Simulink (див. [Малюнок 8.6](#_bookmark49)). Базовим протоколом для зв’язку між установкою та симуляцією з валідатором є TCP/IP. Тому обидва симуляції можуть виконуватися паралельно на одному комп’ютері або на різних ядрах або, наприклад, з міркувань ефективності, на різних комп’ютерах. У майбутньому ми розширимо інструмент перевірки для підтримки спільного моделювання з іншими середовищами моделювання. З цією метою інтерфейси зв’язку повинні бути реалізовані для конкретного середовища моделювання.

![image-20220822170914767](media/image-20220822170914767.png)

**FIGURE 8.6** Architecture of a closed-loop simulation with the Validator.

The Validator also offers a file reader for processing time-stamped values of input data from recorded signals. This is useful for regression testing as discussed in Section 8.4.2.

Валідатор також пропонує зчитувач файлів для обробки значень із мітками часу вхідних даних із записаних сигналів. Це корисно для регресійного тестування, як описано в розділі 8.4.2.

The Validator simulation engine is a discrete event simulation that takes the platform specifications into account. The platform specifications comprising the operating system (OS), the communication bus, hardware timers, etc. are plug-ins of the Validator simulation engine. The lower half of Figure 8.6 sketches this aspect of the architecture of a Validator simulation. The discrete event simulation controls which of the tasks are executed once the control flow gets back to the discrete event simulation from a task execution. For example, based on the scheduling strategy used by the OS, a higher priority task must interrupt one with a lower priority. In such a situation, the discrete event simulation will switch the execution to the appropriate task. Dashed arrows express this control flow between the instrumented tasks and the discrete event simulation in Figure 8.6. In an analogous way, the Validator takes care of the appropriate reading of sensor values and writing of actuator values.

Механізм моделювання Validator — це симуляція дискретних подій, яка враховує специфікації платформи. Специфікації платформи, що включають операційну систему (ОС), комунікаційну шину, апаратні таймери тощо, є плагінами механізму моделювання Validator. У нижній половині рисунка 8.6 зображено цей аспект архітектури симуляції валідатора. Симуляція дискретної події контролює, які із завдань виконуються, коли потік керування повертається до симуляції дискретної події після виконання завдання. Наприклад, на основі стратегії планування, яка використовується ОС, завдання з вищим пріоритетом має переривати завдання з нижчим пріоритетом. У такій ситуації симуляція дискретної події переключить виконання на відповідне завдання. Пунктирні стрілки показують цей потік керування між інструментальними завданнями та симуляцією дискретної події на малюнку 8.6. Подібним чином Validator піклується про належне зчитування значень датчика та запис значень виконавчого механізму.

[Figure 8.7 ](#_bookmark50)illustrates the discrete event simulation in the Validator in more detail. As the discrete event simulation of the controller tasks proceeds from what we call a *spot* (S) within a task to the next spot, the control flow between tasks and the discrete event simulation constantly switches back and forth. In the sample scenario in Figure 8.7, the discrete event simulation starts executing sampleTask(). This task executes till it reaches the first spot and returns control to the discrete event simulation. Based on the platform specification, the discrete event simulation decides to interrupt sampleTask() and to give control to anotherTask(), for example, because that one was triggered for execution and has higher priority than sampleTask(). As anotherTask() has only one spot at the end, it executes completely and then returns the control back to the discrete event simulation. Now the discrete event simulation gives back control to sampleTask(). The discrete event simulation continues with the execution of sampleTask() also at the other two spots.

[Малюнок 8.7 ](#_bookmark50) більш детально ілюструє симуляцію дискретної події в Validator. Оскільки симуляція дискретної події завдань контролера переходить від того, що ми називаємо *точкою* (S) у межах завдання, до наступної точки, потік керування між завданнями та симуляцією дискретної події постійно перемикається вперед і назад. У прикладі сценарію на малюнку 8.7 симуляція дискретної події починає виконувати sampleTask(). Це завдання виконується, доки воно не досягне першої точки та не поверне керування симуляції дискретної події. Базуючись на специфікації платформи, симуляція дискретної події вирішує перервати sampleTask() і передати керування anotherTask(), наприклад, оскільки це завдання було запущено для виконання та має вищий пріоритет, ніж sampleTask(). Оскільки anotherTask() має лише одне місце в кінці, він виконується повністю, а потім повертає керування назад до симуляції дискретної події. Тепер симуляція дискретної події повертає контроль до sampleTask(). Симуляція дискретної події продовжується виконанням sampleTask() також у двох інших місцях.

![image-20220822170956152](media/image-20220822170956152.png)

**FIGURE 8.7** Sample switching between tasks at *spots* (S).

### 8.2.1 Basic Features of the Validator

Let us conclude this overview of the architecture and some core simulation concepts by summarizing the features that result from a bare-bones setup of the Validator:

Давайте завершимо цей огляд архітектури та деяких основних концепцій симуляції підсумовуванням функцій, які є результатом простого налаштування валідатора:

- *Variable monitoring.* The Validator allows the logging of the time-stamped values of selected variables (global variables and variables local to tasks) to a file. The variable monitor in [Figure 8.6 ](#_bookmark49)corresponds to that functionality.
- *Моніторинг змінних.* Засіб перевірки дозволяє реєструвати значення вибраних змінних (глобальних змінних і змінних, локальних для завдань) із міткою часу у файл. Монітор змінних на [Рис. 8.6 ](#_bookmark49) відповідає цій функції.
- *Stop and restart simulation runs.* The Validator allows stopping a simulation and saving the state of the overall simulation, that is, the simulations of both the plant and the controller tasks. A simulation can later be restarted from a saved state.
- *Зупинка та перезапуск симуляції.* Валідатор дозволяє зупинити моделювання та зберегти стан загальної симуляції, тобто симуляції як заводу, так і завдань контролера. Пізніше симуляцію можна буде перезапустити зі збереженого стану.


[8.1 <--- ](8_1.md) [   Зміст   ](README.md) [--> 8.3](8_3.md)