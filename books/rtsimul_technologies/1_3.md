[1.2 <--- ](1_2.md) [   Зміст   ](README.md) [--> 1.4](1_4.md)

## 1.3. НЕПЕРЕРВНЕ МОДЕЛЮВАННЯ

Безперервна модель — це модель, у якій передбачається, що стан системи змінюється безперервно без миттєвих змін у значеннях станів системи або їх похідних.

### 1.3.1 Природа безперервних моделей

Безперервні моделі зазвичай складаються з математичного опису фактичної системи за допомогою комбінації диференціальних і алгебраїчних рівнянь. Цей тип математичної моделі можна виразити у формі диференціальних рівнянь першого порядку, кожне з яких означує змінну стану системи, і додаткових рівнянь, які означують допоміжні змінні. Незалежною змінною є час, створюючи математичну модель для безперервно змінної динамічної системи. Деякі моделі можуть мати додаткові незалежні змінні (зазвичай просторові розміри), у цьому випадку математична модель формулюється як набір рівнянь у частинних похідних. Простим прикладом є моделювання змін температури вздовж тонкого металевого стрижня під час його нагрівання. Змінною стану є температура, і вона змінюється як з часом, так і з координатою уздовж стрижня.

Математична модель — це диференціальне рівняння в частинних похідних із двома незалежними змінними — часом і просторовою координатою.

Імітацйне моделювання з використанням безперервної моделі передбачає ініціалізацію значень станів системи з наступним обчисленням початкових значень інших алгебраїчних змінних. Цей процес ініціалізації встановлює початкові значення всіх системних змінних і супроводжується повторюваним процесом покрокового збільшення часу з використанням алгоритму чисельного розв’язання диференціальних рівнянь. Часові кроки можуть мати постійний розмір (зазвичай це стосується імітаційного моделювання в реальному часі) або змінний розмір. Підпрограми зі змінними кроками зазвичай включають оцінку помилки, створеної на поточному кроці, і стратегію зміни розміру кроку, щоб задовольнити заданий користувачем допуск до помилки. Такі підпрограми зі змінними кроками зазвичай не підходять для імітаційного моделювання в реальному часі, оскільки час їх обчислення змінюється від кроку до кроку.

### 1.3.2 Керування часом для безперервного моделювання

Безперервне моделювання базується на розв’язках звичайних диференціальних рівнянь або рівнянь із частинними похідними, для яких час є змінною, що постійно змінюється, без миттєвих змін від одного значення часу до наступного, на відміну від поведінки дискретного моделювання, у якому час стрибає від одного часу події до наступного. Комп’ютери запрограмовані на створення наближених рішень математичної моделі за допомогою чисельного наближення, у якому час рухається малими дискретними кроками. Спосіб, у який просувається час, частково означується програмістом і в основному керується алгоритмом, вибраним програмістом для вирішення рівнянь у математичній моделі. Існує багато доступних алгоритмів для розв’язування диференціальних рівнянь, і вибір алгоритму є одним із ключових рішень, які приймає користувач безперервного моделювання. На цьому етапі буде корисно зробити короткий екскурс про різні типи та властивості алгоритмів чисельного інтегрування.

#### 1.3.2.1 Типи алгоритму числового інтегрування

Припустимо неперервна математична модель виражена в формі

![image-20220817223109610](media/image-20220817223109610.png)

де *y* — вектор станів, *y*′ — вектор похідних за станом, *x* — вектор допоміжних змінних (алгебраїчних змінних), *u* — вектор вхідних даних, *f* і *g* є довільними, але правильними функціями.

Алгоритми числового інтегрування зазвичай обчислюють наступний стан системи в термінах поточного стану та, в деяких випадках, минулих станів. Припускається, що час просувається кінцевими кроками, що призводить до рівнянь виду

![image-20220817223149440](media/image-20220817223149440.png)

де *t* поточний час; *h* — приріст часу для поточного кроку; а *y*, *x* і *u* — стан системи, інші системні змінні та вхідні дані системи відповідно. У багатьох випадках алгоритм можна розкласти в скінченний або нескінченний ряд, який відповідає розкладу в ряд Тейлора для перших кількох членів.

Ряд Тейлора можна виразити як

![image-20220817223218041](media/image-20220817223218041.png)

Простий метод інтегрування Ейлера, наприклад, розв’язує рівняння 1.1a та 1.1b шляхом обчислення

![image-20220817223232882](media/image-20220817223232882.png)

Іншими словами, інтеграція Ейлера просто екстраполює стани, *y*, припускаючи, що похідні від *y* залишаються незмінними протягом усього кроку та дорівнюють значенню на початку кроку. Процес зображено на рис. 1.1.

Припустимо систему першого порядку,

![image-20220817223249451](media/image-20220817223249451.png) 

![image-20220817223307495](media/image-20220817223307495.png)

Рис. 1.1 Інтегрування Ейлера

На рис.1.1 показано частину справжнього рішення для змінної стану *y*(*t*). Початкове значення *y* дорівнює $y_0$ у момент *t* = *t*(0). Початкове значення похідної з рівняння 1.5 визначається як

![image-20220817223337345](media/image-20220817223337345.png)

Застосовуючи інтегрування Ейлера до кроку довжиною *h*, ми маємо

![image-20220817223352304](media/image-20220817223352304.png)

Тепер можна обчислити похідні $(t_0 + h)$

![image-20220817223407258](media/image-20220817223407258.png)

Цей процес можна повторювати до досягнення кінцевого часу.

Цей алгоритм узгоджує перші два члени ряду Тейлора (аж до члена в першій похідній *y*′) і відомий як метод першого порядку. Доступні більш складні методи, які відповідають ряду Тейлора термінам у *y*″ (методи другого порядку), *y*‴ (методи третього порядку) тощо. Ці методи на основі рядів Тейлора намагаються наблизити рішення за один крок за допомогою поліноміальної апроксимації, лінійної для першого порядку (Ейлера), квадратичної для методів другого порядку тощо. Альтернативний підхід, заснований на експоненціальних наближеннях, буде представлено в розділі 1.5.3. Загалом, метод порядку *n* матиме похибку апроксимації, яка залежить від нехтованих членів ряду Тейлора, якими є члени в $h^{n+1}$ і вище. Ця похибка відома як похибка скорочення (truncation error). Додаткові похибки можуть виникати через накопичення похибок округлення, особливо при використанні форматів даних із нижчою точністю та великої кількості кроків. Як ми побачимо, це може мати особливе значення в деякому імітаційному моделюванні у реальному часі. Існує багато різних алгоритмів числового інтегрування. Широко використовуються методи Рунге–Кутта різних порядків. Часто обирають методи четвертого порядку Рунге–Кутта, які забезпечують хороший компроміс між точністю та обчислювальною складністю [10].

Двома основними факторами, які впливають на точність числового інтегрування, є порядок і розмір кроку. Загалом, похибки зменшуються зі зменшенням розміру кроку та збільшенням порядку. У крайніх випадках кроки можуть бути настільки короткими, що похибка округлення може стати проблемою, особливо з форматами даних з нижчою точністю. Зі збільшенням розміру кроку деякі алгоритми можуть стати нестабільними, навіть якщо нестабільна поведінка з’являється в точці, коли похибки до цього моменту були прийнятними. Іншими словами, прийнятні стабільні рішення можуть здійснювати швидкий перехід до неприйнятних нестабільних рішень з дуже малими збільшеннями розміру кроку.

#### 1.3.2.2 Фіксований крок проти змінного

Один із варіантів, з якими стикаються користувачі безперервного моделювання, полягає в тому, чи використовувати алгоритм, який збільшує час рівними кроками (алгоритм із фіксованим кроком), чи той, який змінює розмір кроків часу, щоб задовольнити надані користувачем допуски похибок.

Сучасні підпрограми зі змінним кроком часто використовують підхід, у якому оцінені рішення порядку $n$ і $n − 1$ генеруються на кожному кроці, а оцінка похибки базується на різниці між ними. Обґрунтуванням цього є те, що ця різниця приблизно дорівнює значенню останнього члена в ряді Тейлора перед скороченням. Припускається, що це консервативна оцінка загальної похибки скорочення. Процедура за замовчуванням у MATLAB® і Simulink® [11] (ODE45) є, наприклад, методом цього типу, який порівнює наближення п’ятого та четвертого порядку з розв’язком.

Процедури з фіксованими кроками є простішими та кращими для імітаційного моделювання в реальному часі, оскільки вони призводять до постійного часу обчислення. Процедури зі змінними кроками безпечніші, популярні та часто використовуються як стандартні в тих системах моделювання, які пропонують вибір алгоритмів.

#### 1.3.2.3 Явний проти неявного

Алгоритми, які обчислюють наступний стан на основі поточних (і, можливо, попередніх) станів, мають праві частини, які можна оцінити безпосередньо, і називаються ***явними алгоритмами (explicit )***. Однак для деяких алгоритмів рівняння 1.2 змінено, щоб включити один або більше членів у $(t + h)$ у правій частині:

![image-20220817223149440](media/image-20220817223149440.png)

![image-20220817223542222](media/image-20220817223542222.png)

що призводить до неявної формули. Зазвичай це вимагає вирішення набору одночасних алгебраїчних рівнянь на кожному кроці. Якщо система рівнянь є лінійною, це часто можна зробити прямим обчисленням, але нелінійні системи потребують ітераційної процедури вирішення на кожному кроці. Неявні методи, як правило, непридатні для моделювання в реальному часі, оскільки обсяг обчислень може змінюватися від кроку до кроку без *апріорі* відомої верхньої межі. Крім того, може виявитися необхідним завчасно надати вхідні дані зовнішнього апаратного забезпечення в циклі (тобто $u(t + h)$ може знадобитися в момент *t*). Однак неявні методи можуть запропонувати покращену стабільність і часто використовуються для жорстких систем (див. Розділ 1.3.2.5).

#### 1.3.2.4  Однокроковий проти багатокрокового

Методи, які обговорювалися досі, є самодостатніми в межах кожного кроку та називаються однокроковими методами. Деякі методи поширюють обчислення на більш ніж один крок і називаються багатокроковими. Наприклад, значення стану системи на наступному кроці може бути визначено в термінах стану системи на поточному та попередньому кроці. Для деяких алгоритмів потрібні дані з останніх трьох або чотирьох кроків. Рівняння 1.2 тепер змінено таким чином:

![image-20220817223606878](media/image-20220817223606878.png) 

Ці методи часто є економічно ефективними (з точки зору обсягу обчислень, необхідних для досягнення заданої точності), але вони вимагають спеціальних процедур для їх запуску, оскільки попередні дані недоступні на початку моделювання. Ці методи також можуть спричинити проблеми з гібридним імітаційним моделюванням і імітаційним моделюванням у реальному часі.

#### 1.3.2.5 Алгоритми зі змінним порядком і жорсткі системи

Багато алгоритмів інтеграції мають проблеми зі стабільністю при застосуванні до жорстких систем. ***Жорсткі системи (Stiff systems)*** [Wiki](https://uk.wikipedia.org/wiki/Жорстке_диференціальне_рівняння ) — це системи, які мають широку варіацію динаміки системи, яку часто описують як такі, що мають постійні часу або власні значення, що сильно варіюються. Ці системи характеризуються тим, що містять як високошвидкісні, так і низькошвидкісні динамічні властивості, усі з яких повинні бути охоплені методом рішення. Коли активні високошвидкісні режими (тобто змінні швидко змінюються), для фіксації швидких змін стану необхідні короткі розміри кроків, співмірні з задіяними постійними часом. Основна проблема з жорсткими системами виникає, коли швидкі режими неактивні (тобто затухають), а траєкторії розв’язання гладкі. Як правило, для покриття плавних траєкторій використовуються більш довгі кроки, але в моделюванні жорсткої системи сплячі високочастотні режими можуть стимулюватися алгоритмом інтеграції, що спричиняє нестабільність, якщо розмір кроку не залишається коротким, що може забрати багато часу. Цю задачу часто вирішують за допомогою спеціальних стабільних жорстких системних алгоритмів. Одним із найвідоміших є метод Гіра [12], неявний метод, заснований на зворотному диференціюванні, який регулює порядок, а також розмір кроку алгоритму, щоб підтримувати як точність, так і стабільність, мінімізуючи кількість необхідних обчислень. Оригінальна процедура Gear DIFSUB була згодом вдосконалена Hindmarsh у широко використовуваній процедурі GEAR [13]. Методи зі змінним порядком та змінним кроком такого типу зазвичай не підходять для іімтіаційного моделювання у реальному часі, критичних за часом.

#### 1.3.2.6 Різницеві рівняння

Який би метод не було обрано для розв’язання диференціальних рівнянь у математичній моделі, результатом є їх перетворення на набір приблизно еквівалентних різницевих рівнянь. Саме ці різницеві рівняння фактично оцінюються на кожному кроці моделювання, і спосіб реалізації цього процесу може мати значний вплив на спосіб кодування імітаційного моделювання, особливо для застсоунків реального часу.

### 1.3.3 Програмне забезпечення для безперервного моделювання

Існує довга історія мов для безперервного моделювання (традиційно їх називають мовами безперервного моделювання систем або **CSSL** - continuous system simulation languages), починаючи з 1950-х і 60-х років. Спочатку програмне забезпечення, доступне для підтримки безперервного моделювання, було розроблене на основі аналогових комп’ютерних методів. Аналогові комп’ютери використовували спеціально розроблені електронні підсилювачі, налаштовані на виконання таких математичних операцій, як інтегрування, додавання, множення та генерування функцій. Ці підсилювачі були з’єднані програмістом разом за допомогою патч-кордів для представлення диференціальних рівнянь, які потрібно розв’язати. Системні константи та параметри встановлювалися на потенціометрах (змінних подільниках напруги). Перші системи безперервного моделювання для цифрових комп’ютерів імітували цей підхід. Були поширеними такі назви, як DAS (цифровий аналоговий симулятор, Digital Analog Simulator) і MIDAS (модифікована інтеграція DAS, Modified Integration ) [14,15] . Ці системи вимагали від програміста створення блок-схеми, що показує взаємозв’язок компонентів (суматори, помножувачі, інтегратори тощо), які були подібні до фізичних компонентів аналогового комп’ютера. По суті, цифрова програма імітувала аналогову комп’ютерну імітаційну модель системи! Оскільки графічні вхідні дані були недоступні, блок-схеми були введені в табличній формі, що показує, як різні входи та виходи були з’єднані між собою (подібно до Netlist для сучасного імітатора електричного кола, такого як SPICE). Виразність цього підходу була обмежена доступним репертуаром компонентів, і блок-схеми, засновані лише на цих примітивних елементах, швидко стали дуже великими. Із зростанням популярності мов програмування загального призначення високого рівня, таких як FORTRAN і Algol 60, виник попит на мови моделювання, в яких програма могла б бути виражена в термінах програмних операторів, а не блок-схем. Щоб розрізнити два підходи, були введені назви *блочно-структурований* (для методу блок-схеми) і *структурований оператором* (для мов на основі операторів). Поява структурованих операторами мов моделювання як заміна блоково-структурованих імітаторів була оцінена як великий крок вперед.

Мови зі структурованими операторами (statement-structured languages) включають **CSMP** (програма моделювання безперервної системи, Continuous System Modeling Program), **DSL** (мова цифрового моделювання, Digital Simulation Language), **ACSL** (мова вдосконаленої безперервної симуляції), CSSL4 (мова моделювання безперервної системи 4, Continuous System Simulation Language 4), **ESL** (європейська мова моделювання, European Simulation Language), а нещодавно MATLAB і Simulink. Важливою подією стала публікація в 1967 році специфікації для CSSL компанією Simulation Councils, Inc. (SCi) у їхньому журналі *SIMULATION* [16]. Незважаючи на те, що ця специфікація була далека від повного стандарту, вона надала шаблон для CSSL, які виникли після її публікації. Однією з його головних і незмінних особливостей була структура виконання моделювання, що складається з трьох основних областей, позначених як *Початкова (Initial), Динамічна (Dynamic)* та *Кінцева (Terminal)* області. Ці назви досить зрозумілі з обчисленнями в нульовий час (або якийсь інший заданий користувачем початковий час), що виконуються в початковій області, рішення математичної моделі з випереджаючим часом у динамічній області та умовами завершення та обчисленнями після запуску в термінальну область.

Пізніше завдяки поєднанню значно збільшеної комп’ютерної потужності та недорогих графічних дисплеїв було розроблено нове покоління блочно-структурованого програмного забезпечення моделювання. Сучасне програмне забезпечення безперервного моделювання зазвичай надає графічний редактор, за допомогою якого можна означити блок-схему системи. На відміну від оригінальних блочно-структурованих мов, сучасне програмне забезпечення для моделювання пропонує ієрархічний підхід, у якому примітивні елементи можна комбінувати в більш складні компоненти та додавати до бібліотек. Великі бібліотеки доступні від постачальників програмного забезпечення, і користувачі також мають можливість розробляти власні бібліотеки моделей. Деякі продукти все ще надають користувачеві доступ до основної еквівалентної форми програми, структурованої за допомогою інструкцій, яку досвідчені користувачі можуть переглянути для задоволення особливих потреб. Поточні версії ESL і ACSL, наприклад, забезпечують цю функцію. За допомогою сучасних графічно заснованих мов моделювання користувач може побудувати блок-схему моделювання, часто використовуючи елементи моделювання, вибрані з наборів інструментів загальних компонентів і підсистем. Керування моделюванням є неявним і контролюється користувачем за допомогою інтерактивних екранів, за допомогою яких вибираються параметри моделювання (наприклад, час початку, умова завершення, алгоритм інтеграції та розмір кроку, деталі виведення тощо). Деякі критики дивляться на використання наборів інструментів із занепокоєнням, стверджуючи, що це забирає від користувача деталі точної природи використовуваних моделей і що це може створити переконливі, але неточні імітаційні моделі. Однак при обережному використанні та з достатнім знанням деталей моделі кожної підсистеми цей підхід забезпечує дуже зручний спосіб швидкої розробки імітаційних моделей.

### 1.3.4 Приклад безперервного моделювання

Розглянемо простий приклад невеликої металевої сфери, яка була нагріта до температури $T_0$ у момент *t* = 0 і охолоджується на повітрі з температурою навколишнього середовища $T_a$.

Диференціальне рівняння, яке хоча б приблизно описує цей процес, таке

![image-20220817223639227](media/image-20220817223639227.png) 

Зверніть увагу, що ми можемо обчислити початкове значення $dT/dt = K*(T_a − T_0)$. Якщо $T_a < T_0$, то $dT/dt$ буде негативним, що вказує на охолодження, а якщо *T*a > *T*0, то $dT/dt$ буде позитивним для нагрівання. Використовуючи метод Ейлера, це дасть оцінку для $T(h)$ як

![image-20220817223658375](media/image-20220817223658375.png) 

Потім можна обчислити похідну d*T*/d*t* при *T* = *h* і повторити процес, доки не буде досягнуто кінцевої умови.

Процес однаковий для більш складних алгоритмів інтегрування або для більших систем диференціальних рівнянь. У всіх випадках розрахунок чергується між визначенням поточних значень похідних і допоміжних змінних і використанням алгоритму інтегрування для випередження часу на один крок і обчислення відповідних значень змінних стану. Це чергування між встановленням поточного стану системи та випередженням часу відображає процес, що використовується в дискретному моделюванні, у якому перехід часу до часу наступної події чергується з переоцінкою стану системи.

[1.2 <--- ](1_2.md) [   Зміст   ](README.md) [--> 1.4](1_4.md)