[6.5 <--- ](6_5.md) [   Зміст   ](README.md) [--> 6.7](6_7.md)

## 6.6. RELATED WORK

There is a Simulink integration of another LET-based language called HTL [26]. The HTL compiler is capable of compiling an HTL description into a Simulink model, which is then equipped with functionality for the control laws. The Simulink integration supports the hierarchical structure of HTL descriptions but restricts communication with the environment (plant model) to a single module, which limits the support for simulating distributed applications. Although HTL, similar to TDL, is based on an E-code variant, the HTL Simulink integration does not follow an E-machine approach but uses standard built-in MATLAB and Simulink blocks. This results in a simulation that does not exhibit the same behavior as the execution of the generated code, since the timing is distorted in several situations (e.g., by Unit-Delay blocks).

Існує інтеграція Simulink іншої мови на основі LET під назвою HTL [26]. Компілятор HTL здатний компілювати HTL-опис у модель Simulink, яка потім оснащена функціями для законів керування. Інтеграція Simulink підтримує ієрархічну структуру описів HTL, але обмежує зв’язок із середовищем (моделлю підприємства) одним модулем, що обмежує підтримку моделювання розподілених програм. Хоча HTL, подібно до TDL, базується на варіанті електронного коду, інтеграція HTL Simulink не слідує підходу електронної машини, а використовує стандартні вбудовані блоки MATLAB і Simulink. Це призводить до симуляції, яка не демонструє таку ж поведінку, як виконання згенерованого коду, оскільки синхронізація спотворюється в кількох ситуаціях (наприклад, блоками Unit-Delay).

Simulink is closely related to synchronous languages. The simulation engine of Simulink executes subsystems implementing controller functionality in logical zero time. However, the semantics of Simulink are not defined formally [27], whereas synchronous languages are based on strict formal definitions and aim at formal verifiability. In several approaches, synchronous languages are combined with Simulink: Argos, a synchronous language with a rigorously defined graphical notation, is prototypically embedded in Simulink as a less powerful but also less complicated alternative to Stateflow [28]. The implementation assumes that outputs calculated in response to an event are provided immediately. An extension [29] accounts for computational delays and corresponds to the implementation of the synchronous languages Argos and Esterel, where the response must be provided before a next event occurs. In both approaches, a synchronous program is embedded in Simulink.

Simulink тісно пов'язаний із синхронними мовами. Механізм моделювання Simulink виконує підсистеми, що реалізують функціональність контролера, за час логічного нуля. Однак семантика Simulink не визначена формально [27], тоді як синхронні мови базуються на строгих формальних визначеннях і націлені на формальну верифікованість. У кількох підходах синхронні мови поєднуються з Simulink: Argos, синхронна мова зі строго визначеною графічною нотацією, прототипно вбудована в Simulink як менш потужна, але також менш складна альтернатива Stateflow [28]. Реалізація передбачає, що виходи, обчислені у відповідь на подію, надаються негайно. Розширення [29] враховує затримки обчислень і відповідає реалізації синхронних мов Argos і Esterel, де відповідь повинна бути надана до наступної події. В обох підходах синхронна програма вбудована в Simulink.

The work by Caspi, Adrian, Maignan, Sofronis, and Tripakis [30] focuses on the conversion of a Simulink model into a synchronous program. Simulink systems consisting of a predefined subset of discrete-time blocks are translated automatically into Lustre, such that the original Simulink behavior is preserved. This enables the usage of tools for formal validation, simulation, synthesis, and so on. Another work [31] also includes Stateflow blocks. Caspi, Curic, Maignan, Sofronis, Tripakis, and Niebert [32] apply these results in the context of distributed systems. They present a layered end-to- end approach by translating Simulink models to the Lustre-based modeling environment SCADE in a first step. In a second step, the Lustre program is annotated to define timing assumptions and requirements and to specify the mapping to individual nodes. Finally, the application is mapped to a Time-Triggered Architecture (TTA) cluster [9]. The MathWorks product SimEvents® [6] extends Simulink with a mechanism for discrete-event simulation. This allows for simulating models that comprise continuous-time, discrete-time, and discrete-event components. Similar to the TDL integration with Ptolemy, an event-based scheduling can ensure the correct LET semantics of tasks in Simulink. However, based on the experience gained in the previous work, we doubt that a manual modeling of LET semantics scales to complex applications with multimodal behavior. A future research project may attempt to combine SimEvents with the TDL-based approach. Our Simulink integration could especially benefit from the event-based approach to simulate asynchronous activities of TDL. It is also conceivable that the E-machine is not sample-based but is itself triggered asynchronously by events. 

Робота Каспі, Адріана, Меньяна, Софроніса та Тріпакіса [30] присвячена перетворенню моделі Simulink у синхронну програму. Системи Simulink, що складаються з попередньо визначеної підмножини блоків дискретного часу, автоматично переводяться в Lustre таким чином, що оригінальна поведінка Simulink зберігається. Це дозволяє використовувати інструменти для формальної перевірки, моделювання, синтезу тощо. Інша робота [31] також включає блоки Stateflow. Caspi, Curic, Maignan, Sofronis, Tripakis і Niebert [32] застосовують ці результати в контексті розподілених систем. Вони представляють багаторівневий наскрізний підхід шляхом перекладу моделей Simulink до середовища моделювання SCADE на основі Lustre на першому кроці. На другому кроці до програми Lustre додаються анотації, щоб визначити припущення та вимоги щодо часу та визначити відображення окремих вузлів. Нарешті, додаток відображається в кластері архітектури, що запускається часом (TTA) [9]. Продукт MathWorks SimEvents® [6] розширює Simulink за допомогою механізму моделювання дискретних подій. Це дозволяє імітувати моделі, які містять компоненти безперервного часу, дискретного часу та дискретних подій. Подібно до інтеграції TDL із Ptolemy, планування на основі подій може забезпечити правильну семантику LET завдань у Simulink. Однак, виходячи з досвіду, отриманого в попередній роботі, ми сумніваємося, що ручне моделювання семантики LET масштабується до складних програм із мультимодальною поведінкою. Майбутній дослідницький проект може спробувати поєднати SimEvents із підходом на основі TDL. Наша інтеграція Simulink може особливо виграти від підходу на основі подій для моделювання асинхронної діяльності TDL. Також можна припустити, що електронна машина не базується на вибірці, а сама запускається асинхронно подіями.

TrueTime [33] is a Simulink toolbox for simulating networked control systems. It facilitates the cosimulation of control tasks, network transmissions, and continuous plant dynamics. TrueTime addresses the fact that traditional control design in MATLAB and Simulink often disregards temporal behavior and introduces a realtime kernel to be simulated in parallel with the plant. The *kernel block* is implemented as an S-function that simulates a flexible real-time kernel and provides support for A/D and D/A converters, network connections, and interrupt channels. It is event-driven and supports both periodic and aperiodic tasks. Different scheduling mechanisms, such as rate-monotonic or earliest-deadline-first, may be used. Control tasks are implemented in MATLAB functions, C, or Simulink blocks. For simulating distributed applications, network blocks support different network types. TrueTime allows a developer to experiment with various scheduling mechanisms and to investigate the true timing behavior of control applications in Simulink, taking into account latencies, execution times, jitter, and network effects. It requires execution times, distribution, and scheduling mechanism to be known in advance to approximate the behavior on the real execution platform. It is a platform-centered approach, whereas simulating TDL modules abstract from the platform and the network topology.

TrueTime [33] — це набір інструментів Simulink для моделювання мережевих систем керування. Це полегшує спільне моделювання завдань керування, мережевих передач і безперервної динаміки установки. TrueTime враховує той факт, що традиційний дизайн керування в MATLAB і Simulink часто не враховує тимчасову поведінку, і вводить ядро реального часу, яке моделюється паралельно з установкою. *Блок ядра* реалізовано як S-функцію, яка імітує гнучке ядро реального часу та забезпечує підтримку аналого-цифрових і цифро-аналогових перетворювачів, мережевих з’єднань і каналів переривання. Він керується подіями та підтримує як періодичні, так і аперіодичні завдання. Можуть використовуватися різні механізми планування, такі як монотонний курс або перший кінцевий термін. Завдання керування реалізуються у функціях MATLAB, C або блоках Simulink. Для моделювання розподілених програм мережеві блоки підтримують різні типи мереж. TrueTime дозволяє розробнику експериментувати з різними механізмами планування та досліджувати справжню поведінку синхронізації програм керування в Simulink, беручи до уваги затримки, час виконання, тремтіння та мережеві ефекти. Це вимагає, щоб час виконання, розподіл і механізм планування були відомі заздалегідь, щоб наблизити поведінку на реальній платформі виконання. Це підхід, орієнтований на платформу, тоді як імітація модулів TDL абстрагується від платформи та топології мережі.

The TDL domain in Ptolemy II is related to the experimental Giotto domain in Ptolemy II [34]. The Giotto domain is designed based on basic Ptolemy II software components, whereas the TDL domain leverages the existing DE domain. The implementation of the TDL domain reflects the distinction between the fundamental concepts (LET, modes) and the manner in which these concepts are used (the operational semantics). The implementation is two-layered: the basic layer pertains to scheduling LET-based tasks grouped in modes, and the operational layer corresponds to a specific time-triggered programming model. The latter extends the basic layer by specifying additional operations as well as the order of data transfer and mode-change operations according to the programming model semantics. In principle, this forms the basis of domain controllers for any other time-triggered programming models (including Giotto) by extending the basic layer.

Домен TDL у Птолемея II пов’язаний з експериментальним доменом Джотто у Птолемея II [34]. Домен Giotto розроблений на основі основних програмних компонентів Ptolemy II, тоді як домен TDL використовує існуючий домен DE. Реалізація домену TDL відображає різницю між фундаментальними поняттями (LET, режими) і способом використання цих понять (операційна семантика). Реалізація дворівнева: базовий рівень стосується планування завдань на основі LET, згрупованих у режими, а операційний рівень відповідає певній моделі програмування, що запускається за часом. Останній розширює базовий рівень, вказуючи додаткові операції, а також порядок передачі даних і операцій зміни режиму відповідно до семантики моделі програмування. В принципі, це формує основу контролерів домену для будь-яких інших моделей програмування, що запускаються часом (включаючи Giotto), шляхом розширення базового рівня.

[6.5 <--- ](6_5.md) [   Зміст   ](README.md) [--> 6.7](6_7.md)