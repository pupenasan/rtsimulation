[6.5 <--- ](6_5.md) [   Зміст   ](README.md) [--> 6.7](6_7.md)

## 6.6. RELATED WORK

There is a Simulink integration of another LET-based language called HTL [26]. The HTL compiler is capable of compiling an HTL description into a Simulink model, which is then equipped with functionality for the control laws. The Simulink integration supports the hierarchical structure of HTL descriptions but restricts communication with the environment (plant model) to a single module, which limits the support for simulating distributed applications. Although HTL, similar to TDL, is based on an E-code variant, the HTL Simulink integration does not follow an E-machine approach but uses standard built-in MATLAB and Simulink blocks. This results in a simulation that does not exhibit the same behavior as the execution of the generated code, since the timing is distorted in several situations (e.g., by Unit-Delay blocks).

Simulink is closely related to synchronous languages. The simulation engine of Simulink executes subsystems implementing controller functionality in logical zero time. However, the semantics of Simulink are not defined formally [27], whereas synchronous languages are based on strict formal definitions and aim at formal verifiability. In several approaches, synchronous languages are combined with Simulink: Argos, a synchronous language with a rigorously defined graphical notation, is prototypically embedded in Simulink as a less powerful but also less complicated alternative to Stateflow [28]. The implementation assumes that outputs calculated in response to an event are provided immediately. An extension [29] accounts for computational delays and corresponds to the implementation of the synchronous languages Argos and Esterel, where the response must be provided before a next event occurs. In both approaches, a synchronous program is embedded in Simulink.

The work by Caspi, Adrian, Maignan, Sofronis, and Tripakis [30] focuses on the conversion of a Simulink model into a synchronous program. Simulink systems consisting of a predefined subset of discrete-time blocks are translated automatically into Lustre, such that the original Simulink behavior is preserved. This enables the usage of tools for formal validation, simulation, synthesis, and so on. Another work [31] also includes Stateflow blocks. Caspi, Curic, Maignan, Sofronis, Tripakis, and Niebert [32] apply these results in the context of distributed systems. They present a layered end-to- end approach by translating Simulink models to the Lustre-based modeling environment SCADE in a first step. In a second step, the Lustre program is annotated to define timing assumptions and requirements and to specify the mapping to individual nodes. Finally, the application is mapped to a Time-Triggered Architecture (TTA) cluster [9]. The MathWorks product SimEvents® [6] extends Simulink with a mechanism for discrete-event simulation. This allows for simulating models that comprise continuous-time, discrete-time, and discrete-event components. Similar to the TDL integration with Ptolemy, an event-based scheduling can ensure the correct LET semantics of tasks in Simulink. However, based on the experience gained in the previous work, we doubt that a manual modeling of LET semantics scales to complex applications with multimodal behavior. A future research project may attempt to combine SimEvents with the TDL-based approach. Our Simulink integration could especially benefit from the event-based approach to simulate asynchronous activities of TDL. It is also conceivable that the E-machine is not sample-based but is itself triggered asynchronously by events. 

TrueTime [33] is a Simulink toolbox for simulating networked control systems. It facilitates the cosimulation of control tasks, network transmissions, and continuous plant dynamics. TrueTime addresses the fact that traditional control design in MATLAB and Simulink often disregards temporal behavior and introduces a realtime kernel to be simulated in parallel with the plant. The *kernel block* is implemented as an S-function that simulates a flexible real-time kernel and provides support for A/D and D/A converters, network connections, and interrupt channels. It is event-driven and supports both periodic and aperiodic tasks. Different scheduling mechanisms, such as rate-monotonic or earliest-deadline-first, may be used. Control tasks are implemented in MATLAB functions, C, or Simulink blocks. For simulating distributed applications, network blocks support different network types. TrueTime allows a developer to experiment with various scheduling mechanisms and to investigate the true timing behavior of control applications in Simulink, taking into account latencies, execution times, jitter, and network effects. It requires execution times, distribution, and scheduling mechanism to be known in advance to approximate the behavior on the real execution platform. It is a platform-centered approach, whereas simulating TDL modules abstract from the platform and the network topology.

The TDL domain in Ptolemy II is related to the experimental Giotto domain in Ptolemy II [34]. The Giotto domain is designed based on basic Ptolemy II software components, whereas the TDL domain leverages the existing DE domain. The implementation of the TDL domain reflects the distinction between the fundamental concepts (LET, modes) and the manner in which these concepts are used (the operational semantics). The implementation is two-layered: the basic layer pertains to scheduling LET-based tasks grouped in modes, and the operational layer corresponds to a specific time-triggered programming model. The latter extends the basic layer by specifying additional operations as well as the order of data transfer and mode-change operations according to the programming model semantics. In principle, this forms the basis of domain controllers for any other time-triggered programming models (including Giotto) by extending the basic layer.

[6.5 <--- ](6_5.md) [   Зміст   ](README.md) [--> 6.7](6_7.md)