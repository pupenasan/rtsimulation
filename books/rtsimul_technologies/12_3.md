[12.2 <--- ](12_2.md) [   Зміст   ](README.md) [--> 12.4](12_4.md)

## 12.3. SOLVING UML CONSISTENCY

None of the approaches surveyed in the previous section fully address all requirements of [Table 12.1](#_bookmark70). We believe that the common challenge of previous work is in losing track of the abstractions implemented in the models that are checked for consistency.

Previous work has taken two routes: either analyzing the semantics of the diagrams at the metamodel level (or defining consistency rules between different notation types from there) or translating the models into an existing formal language leveraged for verification. In contrast, we propose an approach that defines an explicit ontology that captures the target domain we are modeling and, further, we define a simple execution framework (similar to a “virtual machine”) based on this target ontology. The ontology concepts map one-to-one onto elements of the system class we are interested in modeling.

The main novelty of the consistency checking approach presented here is in the comprehensive, yet simple mechanism we introduce for specifying consistency rules. By defining a simple “virtual machine” containing the abstraction used in our models, we can treat all UML diagram types as model generators for this virtual machine. Each diagram selects entities of the virtual machine and constrains their structure or behavior. Model consistency is then simply defined as the presence of virtual machine behaviors under the specified constraints.

We encode constraints as a set of logic propositions over elements of our target ontology and reduce the verification of virtual machine behaviors to a satisfiability (SAT)



Consistency Management of UML Models                         **305**

 

problem. Although the work presented here is specific to UML, the same approach can be leveraged to integrate other modeling languages with UML-like models.

For the proposed approach to work, we first tailor the UML to the target domain that we are interested in—we leverage the UML MARTE profile to target embedded real-time systems. For the purposes of this chapter, we limit ourselves to a subset of the MARTE notations, rich enough for us to show the value of our consistency notion. In particular, the subset we demonstrate in this chapter includes state diagrams, component diagrams, and interaction diagrams. In Section 12.4, we will analyze avenues to extending this approach to a richer subset of UML 2.0 and to other modeling languages.

 

**12.1.1**           **q****ueRies and** **C****onstRaints** **s****eMantiCs**

To provide the backdrop for our definition of model consistency, we provide a formal semantic framework based on an abstract model of distributed reactive systems, similar to a “virtual machine.” We call this model of our target domain the “abstract semantic space.” In this space, we show how each element of a model can be interpreted as a constraint on the system. The consistency property can then be trivially defined over the “abstract semantic space” as the existence of a system in that domain satisfies all constraints imposed by the models.

Our semantics is based on two elements: queries and constraints. Each model element of a UML specification is interpreted as a set of (query, constraint) tuples. Each query selects some elements in the “abstract semantic space” that we have defined where the corresponding constraint defines a restriction on the structure or behavior of these elements in a system satisfying the specification. The key benefits of our approach are (1) a mathematically simple, yet comprehensive definition of consistency, (2) the ability to tie the reasoning about consistency to entities of the target domain—resulting in a nongeneric model subclass to which the consistency notion applies, and (3) the interpretation of model elements as constraints over the target domain.

Our consistency checking approach contrasts with other translation-based approaches that we surveyed in the literature in the way we perform the translation. In fact, the target model of our translation abstracts the main components of the target implementation domain. The semantics is then specified by directly mapping each element of the UML model onto some configuration of the target model. Our first step is to define an ontology for real-time distributed systems. This ontology is used to assign precise semantics to the UML models we use and is formalized with Queries and Constraints. This step allows us to formally reason about the specification (using first-order logic). After the formalization, we present the grammar of a language to describe systems based on the target ontology formalism. This step enables the translation of UML models to the new domain. The final steps are the definition of the semantics for our abstract language and, based on such semantics, the definition of consistency.

[Figure 12.2 ](#_bookmark73)captures the core elements of our ontology for distributed systems with real-time constraints. A real-time system in our ontology is described by five types of elements: two elements, Entities and Channels, form the structural configuration



**306**                                       Real-Time Simulation Technologies

​                                                                                           

​            Channel            

​            1            

​            Subscribes            

​            *            

​            Entity            

​            1            

​            1            

​            Clock            

​            1            

​            *            

​            1            

​            * Message            

​            2            

​            *            

​            *            

​            * Property      Var:=x            

​            State            







**FIGURE 12.2** Core elements.

 

 

 

of the system; another two, Messages and Properties, define the behavior; and the Clock captures real-time constraints.

An Entity captures the concept of a process in a distributed system. An Entity has local variables, captures state information, has computational capabilities, and can communicate with other Entities by means of sending and receiving messages over channels. Channels are the communication infrastructure. Each entity that must send or receive messages subscribes to a channel. Channels transport Messages. When a message is sent on a channel, all entities that have subscribed to the channel eventually receive the message. Properties can be used to capture variables and their state. Each entity has a named set of properties that can be evaluated at runtime. Finally, the Clock captures the time relative to an entity. We could have used different notions of time, the choice depends on the type of system we intend to model and the profile of UML we use. MARTE supports not only the type of time we model here but also other time models, for example, modeling of synchronous reactions.

Figure 12.2 shows these five core elements forming the *abstract* state of the system. At each instant, the structural part of the system state is defined by the existing Entities and Channels and by the subscription of Entities to Channels. The behavioral part is defined by the Messages exchanged on each Channel and by the internal state of each Entity defined by the valuation of its Properties. Timing relations are expressed by the collections of all clocks associated to entities. Each Entity has its own reference of time given by the clock. At any given instant, when we capture the state of the system, different clocks can have different time values. It is interesting



Consistency Management of UML Models                         **307**

to note that, because the state comprises both a behavioral and a structural part, it is possible to represent a reconfiguration of the system as a change of state.

Based on the concept of state, we can now define a run as an infinite sequence of states (cf. Figure 12.3). In turn, we now define the semantics of a system based on runs. In Figure 12.4, we show the full ontology that we use to assign a semantics to UML. A system is defined by a set of runs. A specification defines a set of acceptable

Run

​                  

​            Time            

​            State            







**FIGURE 12.3** Definition of a run.

 

   UML Diagram               UML



\*     1 Specification

Defines





Query



 



Specification

*

 

Defines

System      1

 

 

*

Message

\*                *



Elementary Specification

 

Composite Specification

 

 

 

\*       Run

1

Sequence

\* State

1





 

 

Constraint

 

 

 

Evaluation

 

 

 

 

Property

\*         *



Send Time



*

1

Channel



Source 1

 

Subscribes

1                *



\*        *

Entity      1

1



1

Instant

1                   *



Now

 

Defines





 

1



1       1

Clock



**FIGURE 12.4** Ontology for distributed real-time system semantics.



**308**                                       Real-Time Simulation Technologies

 

runs. The specification can constrain the acceptable runs by specifying the initial states and the acceptable transitions.

Another interesting element of [Figure 12.4 ](#_bookmark74)is the definition of Specification. A Specification can either be composite or elementary. Every Elementary Specification is made up of two elements: Query and Constraint. A Query selects states from all possible runs while the corresponding Constraint defines the characteristics for the run to be acceptable. We can think of the selector as an operator that is applied to all possible runs. All states selected by the Query are compared with the rules specified in the constraints. If they match, the run is accepted as part of the system whereas if they do not match, the run is discarded.

An important point to notice is how time is treated in the ontology. Each Entity has access to one private Clock. The Clock defines a series of Instants. At any given time, the Clock refers to one of the instants as Now. Each message has one Send Time (an instant on the clock of the entity that sends the message) and one Source Entity (the sender of the message). Therefore, it is possible to reason about when each Message was sent and by which Entity. Messages can be received by different Entities at different times. When an Entity that has subscribed to a Channel receives a Message, it can identify the local Entity time using its Clock and obtain the time of the sending Entity from the Message. Depending on the system and the requirements, it is possible to define synchronization strategies between the Clocks so as to be able to reason about times of events across different Clocks.

We can now give a formalization of the semantics informally described above. To this end, we first formalize the concepts of state and run as a foundation for the semantics of a distributed system specification. Then we present a simple grammar for a specification based on Queries and Constraints and use the formal definitions introduced before to provide a semantic for it.

 

**12.1.1.1**     **Notational** **Preliminaries** **and** **System** **Formalization**

We represent sets with capital Greek letters. For instance, the set of properties will be represented by Y. Each element of the set will be represented by the corresponding lowercase letter. For instance, a property in Y would be represented by Y. A function from a domain *A* to a codomain *B* is expressed as f: *A* ® *B*. A tuple is defined as *y* = (*y*1, *y*2 , ) Î*Y*1 ´ *Y*2 ´ and p*i* × *y* = *yi* is the projection operator returning the *i*th element of the tuple. Given a set *X* , P(*X* ) is the power set of *X*, where |*X* | returns the cardinality of *X*. Furthermore, with B we indicate the set of Boolean values (true and false), N the set of natural numbers, N+ the set of natural numbers without 0, and with N¥ the set of natural numbers with its supremum ¥.

A stream [32] is a finite or infinite sequence of Messages. Given a set of Messages *M*, we indicate with *M* * the set of finite sequences over *M*, with *M*¥ the set of infinite sequences, and with *M*w the union of those two sets. We can obtain the *i*th element of a stream *x* by using the infix dot operator *x*.*i*. The notation *x* ¯ *i* returns the prefix stream of length *i*, whereas *x* ­ *i* returns the tail stream obtained by removing the first *i* elements from *x*. The concatenation of two streams *x* and *x*¢ is denoted as *x* *x*¢. We overload this notation to work with sets of streams *X* *X* ¢ such that the resulting set contains all streams of the form *x* *x*, where *x* Î*X* Ù *x*¢ Î*X* ¢.



Consistency Management of UML Models                         **309**

 

We can now give a formal definition of the elements of our ontology. For the two structural elements, Entities and Channels, we define two sets: the set *E* of Entities and the set *X* of Channels. For each Channel c we have a set sigma Sc keeping track of the Entities subscribed to c. A Channel valuation relates the Channels (elements of the set *X*) to Messages exchanged over the Channels. Because a Channel can be used to send multiple Messages at any given moment, for every Channel c

we define a set *M*c of Messages currently sent over it. Furthermore, for each Entity

e we define a set Ye of Properties. A special Property *v*e encodes the current time of entity ’s Clock.

State is defined by (1) a structural configuration formed by Entities, Channels, and the subscriptions of Entities to Channels; (2) a behavioral configuration formed by Messages on each Channel, and valuation of Properties for each Entity; and (3) the current time value of the Clock property for each Entity.

Properties are intended to encode the state of an Entity. To abstract from the concrete data types used to define the variable space we define a set of functions F. Each

f ÎF is a function defined from the values of a tuple of Properties to a Boolean:

"f ÎF : ({f : Y ´ Y ´ ® B}). This allows for easy translation of UML specifications. For instance, if we want to model a UML Deployment Diagram specifying that a node would run a particular program *P*, we can define a function *run* and have it

evaluate to *true* on the entity corresponding to the node (*run*(*P*) = *true*). The evaluation of the function set F over an entity e is defined as Fe º {(f, fe ) : f ÎF ÙfeÎB}.

We can now define structural configuration as

*Conf**Structural* º (*E*, *X* ,{Sc : c Î *X* })

We define behavioral configuration as

*ConfBehavioral* º ({*M*c : c Î*X* },{Fe : e Î*E*},{*v*e : e Î*E*})

We define state as

 

*State* º (*ConfStructural* ,*ConfBehavioral* ) Î *StateUniverse*

 

where *State* is an element of the *StateUniverse* set containing all possible states.

We can now define the concept of a run using streams: *Run* Î *StateUniverse*¥. The semantics of a system specification in this framework emerges as the set of admissible runs:

*System* Î P(*StateUniverse*¥)

**12.1.1.2**     **Abstract** **Specification** **Language**

We now define the abstract language we use to specify Queries and Constraints (and, therefore, systems). The benefits of defining this language are twofold. First, it provides an explicit context for mapping specifications (both composite and elementary) to systems in the semantic framework. Second, it provides a target



**310**                                       Real-Time Simulation Technologies

 

language for the UML translation. The goal of the language is not to introduce a new textual syntax, and, therefore, we keep it simple by ignoring punctuation and other syntactic sugar necessary for a complete textual language definition.

​         We present the grammar of the language in a Backus–Naur Form using production rules of the following form:

 



​                     N :: = *alt*1N



*alt* N



 *alt* N



 

​                                 

​        2        



​        *n*        



Nonterminals are enclosed in angular brackets, the symbol || separates alternative productions, optional terms are enclosed in square brackets, and the notation {T}* represents the repetition of term {T} for 0 or more times.



 



​         ELEM-SPEC SPEC



:: =

   :: =



QUERY CONSTRAINT SPEC SPEC   ELEM-**S**PEC



​                            QUERY CONSTRAINT



:: = { MSG }* ASSERTION

​                                :: = [$ Ø$]{**[**Ø] MSG }* ASSERTION



​               MSG MSGCONTENT *ASSERTION*



:: =

   :: =

:: =



MSGCONTENT CHANNEL

​                                                   MSGNAME ( SENDER TIME { PARAM }* ) **F**UNCTION ({ PROPERTY }* )

​        UN-OPERATOR ASSERTION 

​                ASSERTION BIN-OPERATOR ASSERTION



 

​                  Operator definitions are not part of this grammar. Instead, they will be introduced when necessary in the translation of UML. In particular, we express all unary operators with the nonterminal UN-OPERATOR and binary operators with BIN-OPERATOR . FUNCTION is a Boolean formula from property names to Boolean. Using this grammar, we can specify a system based on the ontology we have devised using Queries and Constraints. In the next section, we define the semantics of such specifications.

​      Using the CONSTRAINT optional operators $ and Ø$, it is possible to affect the structure of the system. We use $ to create new entities and channels, Ø$ to remove them.

​            Time is addressed in this language as a property of entities. In particular, we use the notation *next*(*t*) to indicate the value of an entity clock in the first state where the value is greater than *t*. With *next* we are able to reason about next states without constraining their occurrence to a particular time value. Moreover, the messages contain the SENDER entity and the sending TIME of the message in its parameter list.

 

**12.1.1.3**     **Specification** **Language** **Semantics**

​                        An elementary specification ELEM-SPEC is captured in our abstract language by a tuple QUERY , CONSTRAINT . The goal of a specification is to define what runs are part of a system implementing such a specification. The QUERY identifies



Consistency Management of UML Models                         **311**

 

​            what parts of the run the specification is constraining, whereas the CONSTRAINT specifies how those parts are constrained. A run that fulfills a pair of query and constraint is such that in all states following a state where the query is true the constraint is true. Therefore, an ELEM-SPEC encodes a transition function between two states.

​      We define a QUERY as a communication context selecting the states that follow a particular message interaction, and a Boolean formula over properties, which identifies states to constrain. A query thus addresses both the contents of channels (the channel history) and predicates over the local data state of the relevant entities. We first define the channel configuration *X*c as

*X*c º (*X* ,{*M*c : c Î *X* },{åc : c Î *X* })

​      This definition captures the part of a state *S* that specifies the channel configuration and the messages being exchanged in the given state. The semantics *q* of a QUERY *q* is, therefore,

 



   "*q* Î



QUERY , *q* º(*h* Î P(*X*c* ), *a* : P(Y) ® B)



 

   where *X*c* is a finite stream of channel configurations, the channel history *h* ÎP(*X*c*) is a set of such streams, and the assertion *a* is a function from a set of properties to Boolean values.

We define a helper function

 

*query* : (P(*X**), P(y) ® B) ´ *StateUniverse*¥ ® {P(*E*) ´ N¥}

​      that, given a QUERY semantics and a run, returns a set of tuples containing (1) the indexes of the states where one of the message histories is matched and (2) the corresponding set of entities for which the evaluation of the function is true. This helper function gives us all states in the run where we have to constrain the next state, as well as the corresponding entities to be constrained.

​            CONSTRAINT is defined as a tuple of channel configurations, Boolean functions over properties, and one of the three quantifiers {$, Ø$, -}. Similar to what we did for queries, we define the semantics of CONSTRAINT as

 

​      "*c* Î CONSTRAINT , *c* º (Xc, *a* : P(Y) ® B,{$, Ø$, -})

We can define a helper function

 

*constr* : (Xc, *a* : P(Y) ® B,{$, Ø$, -}) ´ {P(E) ´ N¥} ´ *StateUniverse*¥ ® B

where *constr* takes as arguments a run, the result of a query operation, and the semantics of a constraint. This function returns true if the constraint is satisfied. To be satisfied, the channel configuration of the selected states must match the *X*c specified by the constraint. Moreover, how the rest of the constraints is satisfied



**312**                                       Real-Time Simulation Technologies

 

depends on the choice among the three quantifiers {$, Ø$, -}. If the chosen quantifier is –, the assertion *s* must evaluate to true in all entities selected. If the quantifier is $, the assertion *s* must evaluate to true in some entities not part of the selected ones. Finally, if the quantifier is Ø$ the selected entities must not be present in the selected states.

​      Now we can define a SPEC in the semantic domain as a set of tuples of the form (query, constraint), and the system corresponding to the specification as the set of all possible runs that fulfill all such tuples (query, constraint) of the set.

Formally,

 



​      SPEC



Í {( QUERY , CONSTRAINT ) :



QUERY , CONSTRAINT }



 

​                                    □ SPEC º {*Run* : *Run* Î *StateUniverse*¥ : "*s* Î SPEC ,

"*q* Î*query*(*s*.0, *Run*), *constr*(*s*.1, *q*, *Run*)}

 

**12.1.2**           **n****otion of** **C****onsistenCy**

We are interested in defining dynamic consistency for real-time distributed systems. This is the reason why we have tailored our semantic framework to this domain rather than staying within the generality of the UML language metamodels. Given the semantic framework presented in the previous section, it is now straightforward to define dynamic consistency for models in this system class. We will first define horizontal consistency and then vertical consistency.

​      We can define horizontal consistency as follows: a specification is horizontally consistent if the system it defines admits at least one run. This is consistent with the definition of horizontal consistency we gave before. In fact, a specification SPEC is formed of multiple views at the same level of abstraction (in our formalism this means multiple sets of query and constraint tuples).

 



**Definition** **12.1**

 

​            A specification SPEC such that SPEC Î P(*StateUniverse*¥)

​      consistent *iff* SPEC ¹ Æ.



 

 

is horizontally



This definition captures the idea that the specification is implementable. There are two possibilities for a system to fulfill this property. Either there are no contradictions in the specification or the admissible runs do not match any query that defines inconsistent constraints. There is nothing wrong in using different perspectives to constrain the system behavior specified by other perspectives. However, if a perspective constrains the behavior of the system such that no run satisfying the specifications of that perspective is allowed in the final system, there can be a consistency problem. A stricter rule for horizontal consistency requires that the system has at least one run admissible for each perspective, meaning that there is at least one run satisfying some queries of each perspective specification.



Consistency Management of UML Models                         **313**

**Definition** **12.2**

​                    A specification SPEC such that SPEC Î P(*StateUniverse*¥) and SPEC made of

​                     *N* specifications PERSP*i* called perspectives such that SPEC = ∩*i*Î*N* PERSP*i*



​            is horizontally consistent *iff* " PERSP*i*

that *query*(*s*.0, *Run*) ¹ Æ.



, $ *Run* Î SPEC Ù $*s* Î



PERSP*i*



such



A possible problem with our first definition of horizontal consistency is that we could have a system specification with no runs satisfying any query of the general specification. The consistency specification for such a system is vacuously satisfied (i.e., runs are possible because selectors never match). The second definition solves this problem requiring that some runs matching the specification queries are present. The two definitions of horizontal consistency we gave support two different usage scenarios. In fact, we can identify two main reasons to create a specification. First, we can be interested in constraining how the system works in a given scenario. The scenario we want to constraint must, therefore, be possible and the corresponding query must select some runs. For this type of usage we should use consistency Definition 2. A different use case is when we want to specify recovery from some failure of the system. For example, we may identify that a given interaction can happen as a result of a failure even if the specification would not allow for it. In this case, the goal is to describe the detection and recovery from a given failure. In this case, we can use consistency Definition 1. Vertical consistency is defined between two specifications at different levels of abstraction. We can define this consistency notion by a containment relation between runs. If we have a more abstract specification SPEC*a* and a more concrete specification SPEC*c*, we define vertical consistency as follows: a concrete specification SPEC*c* is consistent with an abstract specification SPEC*a* if all runs allowed in the concrete system specification are also allowed in the abstract one. Moreover, the abstract system allows runs that the concrete system does not allow. This definition requires that

the concrete systems admit a strict subset of the runs admitted by the abstract one.

 

**Definition** **12.3**

 

​            Two specifications SPEC*a* and SPEC*c* , where the first is the abstract and the second

​            the concrete specification, are vertically consistent *iff* SPEC*a* Í SPEC*c* .

​                              Given the definitions of SPEC and SPEC of the previous section, we can now define a modularity theorem. We first observe that each specification has a set of tuples containing one query and one constraint. Therefore, each of these tuples defines a set of runs. From the definition of SPEC , we can infer a lemma asserting that the semantics of a complex SPEC (i.e., formed by multiple tuples of query and constraint) is the intersection of the semantics of all the subspecifications formed by single query/constraint tuples. The modularity theorem states that for any complex specification SPEC we can always identify two subspecifications such that the intersection of the runs permitted by the two contains exactly the runs permitted by the original specification. Moreover, the theorem states that, to obtain such subspecifications we can simply take two subsets of the tuples of the original specification, provided that all



**314**                                       Real-Time Simulation Technologies

 

tuples of the original specification are in at least one of the two subspecifications. Now we can formally define the lemma and the theorem as follows.

 

**Lemma 12.1**

 



​      Given a specification SPEC





​      □ SPEC =





∩

   "*t*Î SPEC





   {*t*} 



​            **Proof:** Lemma 1 can be proved by observing that the definition of SPEC is such that if a specification contains a single query/constraint tuple *t*, the " quantification in "*s* Î SPEC return a single element. Therefore, we have

 

 {*t*} º {*Run* : *Run* Î *StateUniverse*¥ : "*q* Î*query*(*t*.0, *Run*), *constr*(*t*.1, *q*, *Run*)}

given the definition of intersection: ∩"*s*Î*S s* = {*e* : "*s* Î *S*, *e* Î*s*}. Replacing the

specification of the semantics of a query/constraint tuple into the definition of intersection we obtain



​      ∩

"*t*Î SPEC



 {*t*} = {*e* : "*t* Î SPEC ,

​      *e* Î{*Run* : *Run* Î*StateUniverse*¥ :

"*q* Î*query*(*t*.0, *Run*),*constr*(*t*.1, *q*, *Run*)}}



From this, by replacing *e* with the definition of *Run* we obtain

 



 

​               

​        ∩        



"*t* Î SPEC





 {*t*} = {*Run* : "*t* Î



SPEC , *Run* Î *StateUniverse*¥ :



​      "*q* Î *query*(*t*.0, *Run*), *constr*(*t*.1, *q*, *Run*)}

​        which is our definition of SPEC .

 

The Modularity theorem asserts that complex query/constraint specifications can be split into two simpler ones without losing information.

 

​      **Theorem 12.1**

 



​                 Modularity. Given a specification SPEC such that



SPEC



\> 1 (i.e., the specification



​         is complex), " SPEC1 , SPEC2 such that

 



​      SPEC1



Ì SPEC Ù



SPEC2



Ì SPEC Ù



 



​                              SPEC1



\> 0 Ù



SPEC2



\> 0 Ù



SPEC1



∪ SPEC2



= SPEC



​                                                □ SPEC = SPEC1 ∩ SPEC2



 .



Consistency Management of UML Models                         **315**

 

The proof of Theorem 12.1 derives easily form Lemma 12.1. In fact, because the semantics of a specification is equivalent to the intersection of the semantics of all its constituent query and constraint tuples, we can use the commutative and associative properties of intersection to prove Theorem 12.1.

 

**12.1.3**           **e****xaMple of** **C****onsistenCy** **M****anageMent**

To show how the methodology outlined in this chapter applies to consistency checking in the context of UML for real time, we are required to provide a translation from UML and from its MARTE profile to the abstract language we introduced. Translating the entire UML and MARTE metamodels is beyond the scope of this chapter. Instead, we chose a simple subset of UML and MARTE that uses three graphical notations: component diagrams, sequence diagrams, and state diagrams, which we used in the example of [Figure 12.1](#_bookmark69). Furthermore, we translate MARTE timed constraints as we used them in our example.

The translation from UML models to our query and constraint language assigns a precise semantics to each model. Several options for assigning semantics to each notation exist. For the sequence diagram, for instance, we have many possibilities for interpreting them existentially (at least the specified behavior must be possible) or universally (precisely the specified behavior is required) [43]. Notice that the decision of interpreting the diagrams existentially or universally depends on what the goal of the specification is. For example, in a requirements document an interaction can exemplify one of many possible scenarios and the existential interpretation would be correct. For real-time systems modeling we interpret sequence diagrams universally. All messages exchanged in the system must be represented in diagrams. This interpretation of sequence diagrams is viable for our application domain. In fact, one of the key uses of models of communication in real-time systems is to analyze the network traffic and ensure that real-time constraints can be met. To this end a complete view of which messages are exchanged over the communication channels is necessary.

Our translation strategy interprets every element of a UML graph as a query and constraint tuple. We introduce an operator to compose those elementary specifications—this closes the loop with the introduction of the abstract query/constraint syntax. For demonstration purposes, we introduce the parallel operator. This operator is applied between any two specifications in our translation and returns the specification containing all query and constraint tuples of the operand specifications.

 

​      a,b Î SPEC

 

 a PAR b º {*s* : *s* Îa Ú *s* Îb}

In [Table 12.4](#_bookmark75), we provide translation rules for some of the interesting model elements used in our example. The entire set of rules is beyond the scope of this chapter. Each rule provides a set of query/constraint tuples that can be composed in a specification using the parallel operator. To support the translations, we define a small set of helper functions.



**316**                                       Real-Time Simulation Technologies

 

 

| **TABLE** **12.4**  **Translation** **Rules** **for** **UML** **Metamodel** **Elements** |                             |                                                              |
| ------------------------------------------------------------ | --------------------------- | ------------------------------------------------------------ |
| **Name**                                                     | **Metamodel**  **Element**  | **Translation**                                              |
| UML::BasicComponents:: Component                             | [Figure 12.5](#_bookmark76) | *Q* :{}  *true*  *C* : ${}*EType* = *Component*.*name*       |
| UML::BasicInteractions:: MessageOccurrence Specification     | Figure 12.6                 | *MOS*  º *MessageOccurrenceSpecification t* º time of last message received in history *Q* : *ExtractHistory* ({*MOS*}) *Clock* > *t C* : *toMSG*({*MOS*}) *true* |
| UML::  BehaviorStateMachines:: Transition                    | [Figure 12.7](#_bookmark78) | *TR* º *Transition*, *B* º *TR*.*effect s*1 =*TR*.*source*, *s*2 =*TR*.*target*  *Q* : *ExtractHistory*({*TR*.  *trigger*}) *State* = *s*1 Ù *Clock* = *t*  *C* : *toMSG*(*B*) *State* = *s*2 Ù *Clock* = *next*(*t*) |
| TimedConstraints::Timed Constraint                           | [Figure 12.8](#_bookmark78) | *PR* º*TimedInstantConstraint*.*specification Q* : *MsgFromObservations*(*PR*. *observation*) *PropFromObservations*(*PR*.  *observation*)  *C* :{}*evalVSL*(*PR*) = *true* |

 

The function *toMSG*() is used to convert two elements of the UML metamodel, MessageOccurrenceSpecification and Triggers, into objects suitable for our abstract language. Informally, we can think of MessageOccurrenceSpecification as representations on sequence diagram lifelines of the events related to message sending and receiving (plus execution of actions and other details we do not consider in our simplified model). The function *toMSG*() expresses the translation from OccurrenceSpecification elements of the UML metamodel to messages in our abstract language specification.

Similarly, the *ExtractHistory*() function applied to a model element of type MessageOccurrenceSpecification returns the sequence of messages that maps to the EventsinthelifelinebeforetheonedefinedbythegivenMessageOccurrenceSpecification. Intuitively, this function returns the history necessary for a query to select the correct interactions before applying the constraint to match the message event defined by the MessageOccurrenceSpecification model element. We do not describe the details of how this translation is performed because it is beyond the scope of this chapter. In fact, the UML metamodel is very complex. Extracting relations between events and specification elements in different diagrams often requires the exploration of a deep class hierarchy. For example, by inspecting the metamodel of [Figure 12.6](#_bookmark77), we can observe that to extract the history of events before a given message in a sequence diagram, we have to identify the Lifeline the OccurrenceSpecification is covered by. Then, leveraging the fact that the set of events of a lifeline is ordered, we could extract all the OccurrenceSpecifications that precedes the one for which we are creating the history. Once we have the ordered list of OccurrenceSpecifications in the history, we can navigate their event property to obtain the corresponding Events. By reflection, we



Consistency Management of UML Models                         **317**

 

can identify the events that are related to sending and receiving messages and use this information to generate the list of message specifications.

The four translations given in [Table 12.4](#_bookmark75) map the elements of UML and MARTE metamodels depicted in Figures 12.5 through 12.8 to query and constraint tuples. The first line of the table gives a translation for Figure 12.5. This part of the metamodel defines UML components in a component diagram. The simple model in the figure captures the relation between Components and Interfaces, which can be required or provided by the Component. Our translation simply asserts that a specification of a component always imposes the existence of an entity with a property called *EType* and value equal to the component name in the UML diagram.

The translation of line 2 of Table 12.4 defines constraints imposed by a MessageOccurrenceSpecification in a UML sequence diagram. The query extracts the message history before the given MessageOccurrenceSpecification. As we already mentioned discussing ExtractHistory, this is not a trivial operation. [Figure 12.6](#_bookmark77) presents the relevant subset of the UML model for sequence diagrams. Interactions are the type of behavior specified by this type of diagram. In particular, an Interaction is a type of InteractionFragment that can be composed of other such fragments. Special types of InteractionFragments are OccurrenceSpecifications which reference communication Events and Lifelines. An example of such specifications is MessageOccurrenceSpecifications, which represent messages exchanged according to the interaction modeled. The constraint in our translation is the existence of the message corresponding to the

 

​                  

​            **UML::Classes::** **Dependencies::** **NamedElement**            

​            **UML::**      **CompositeStructures::** **StructuredClasses::Class**            

​            **Component**      IsIndirectlyInstantiated: Boolean      *                    *            

​            {readOnly} required      *            

​            {readOnly}      * provided            

​            **UML::Classes::** **Interfaces::Interface**            







 

**FIGURE 12.5** Subset of the UML Component metamodel. (Adapted from Object Management Group, “Unified Modeling Language (OMG UML), Superstructure, Version 2.3.” 2010, formal/2010-05-05, OMG.)



**318**                                       Real-Time Simulation Technologies

​                  

​            **UML::**      **CommonBehaviors::**      **Interaction**               **BasicBehaviors::Behavior**      0..1      enclosingInteraction      **MessageOccurrenceSpeci cation**            

​            **Lifeline**      covered    1            

​            fragment            

​            *            

​            **InteractionFragment**            

​            **OccurrenceSpeci cation**      *            

​            events    {ordered}            

​            *            

​            1 event      **UML::**      **CommonBehaviors::** **Communications::Event**            







**FIGURE 12.6** Subset of the UML Message metamodel. (Adapted from Object Management Group, “Unified Modeling Language (OMG UML), Superstructure, Version 2.3.” 2010, formal/2010-05-05, OMG.)

 

 

MessageOccurrenceSpecification. This translation covers only events that are messages. Other types of events cause properties in some entity to be set and are not covered in our example.

The third line of [Table 12.4 ](#_bookmark75)defines a Translation for state-machine transitions. To this end, we introduce an entity property named State. [Figure 12.7 ](#_bookmark78)depicts the relevant subset of the UML metamodel for state-machine diagrams. According to the UML metamodel, a Transition has a source and target Vertex, and State is a type of Vertex. A Transition can be taken only if the guard constraint is true and, in this case, is taken when a given trigger occurs. Moreover, a Transition can have an effect. The effect is a Behavior. An example of Behavior is the Interaction (as depicted in Figure 12.6), which can contain message-related events (because MessageOccurrenceSpecifications are also InteractionFragments). For our case study, we simplify the translation to address just triggers and effects that are messages. The query part of the translation of Transition selects entities, where the State variable coincides with the source state of the model. Other propositions in the query can be used to restrict the selection to only specific entities. In fact, state diagrams define the behavior of particular model elements. For example, in our case study we want to apply the state diagram of Figure 12.1c only to the component Emergency Brake. In this case, the query should also limit the selection to states of the entity Emergency Brake. To this end, we can add to the query another clause that selects only entities of the correct type (i.e., *EType* = “Emergency Brake”). The other part of the query limits the selection to states where the trigger message is present. The constraint simply forces the next state of the selected entities to have the target state in the State property.



Consistency Management of UML Models                         **319**



 

 

**Vertex**

1 source      1

\* outgoing *



target incoming



**UML::Classes::** **Kernel::** **NamedElement**



**UML::Classes::** **Kernel::**



**Transition**

Kind: TransitionKind 0..1



0..1



0..1





 

 

 

 

{subset



 

 

**State**



**Namespace**





 

0..1



{subset ownedElement}

entry

0..1





0..1



ownedElement} effect

**UML::**



/isComposite: Boolean

/isOrthogonal: Boolean

/isSimple: Boolean

/isSubmachineState: Boolean





0..1



{subset ownedElement}

exit

0..1

{subset ownedElement}

doActivity



**CommonBehaviors::** **BasicBehaviors::** **Behavior**



{subset owner} owningState

 

**FinalState**



0..1

 

*



0..1    0..1

 

deferrableTrigger





trigger

*



0..1



 

{subsets ownedElement}

stateInvariant



**UML::CommonBehaviors::** **Communications::Trigger**

0..1       0..1



**UML::Classes::** **Kernel::Constraint**



{subset ownedRule} guard



   **FIGURE 12.7** Subset of the UML Transition metamodel. (Adapted from Object Management Group, “Unified Modeling Language (OMG UML), Superstructure, Version 2.3.” 2010, formal/2010-05-05, OMG.)

​                  

​            **TimedInstantConstraint**            

​            specification            

​            1            

​            **InstantPredicate**            

​            **VSL::TimeExpressions::** **InstantExpression**            

​            1..*            

​            observation            

​            **TimedConstraint**            

​            **TimedInstantObservation**            

​            **UML::**      **CommonBehaviors::** **Communications::Event**            

​            1      event            

​            1    eocc      **EventOccurrence**            







**FIGURE 12.8** Subset of the MARTE TimedConstraints metamodel. (Adapted from Object Management Group, “UML Profile for MARTE: Modeling and Analysis of Real-Time Embedded Systems, Version 1.0.” 2009, formal/2009-11-02, OMG.)

Finally the last line of [Table 12.4](#_bookmark75) defines the translation for MARTE TimedInstantConstraint. Figure 12.8 shows the relevant MARTE metamodel. A TimedInstantConstraint has a specification that is a predicate over a set of observations (TimedInstantObservations). Each observation identifies an event occurrence. EventOccurrences relate MARTE observations to UML Event elements.



**320**                                       Real-Time Simulation Technologies

 

MARTE introduces the Value Specification Language (VSL) to formulate algebraic and time expressions. The translation of MARTE InstantPredicates has to interpret the VSL InstantExpression. To this end, in our translation, we use an *evalVSL* Boolean function that evaluates a VSL expression. Moreover, we use two functions, *MsgFromObservations* and *PropFromObservations* , to obtain the messages and properties that correspond to the events referred to by the observation of a predicate. From [Figure 12.8](#_bookmark78), we can observe the complexity of obtaining an event from a TimedConstraint. Obtaining messages and properties from events requires a good understanding of the UML metamodel and the exploration of many nested relations. Although complex, those functions can be implemented in a program. The translation then selects the correct messages and entities in the query part of the specification and asserts that the specification in VSL evaluates to true in the constraint.

We can now show how to detect inconsistency with this query and constraint framework using the example of [Figure 12.1](#_bookmark69). Thanks to the modularity theorem defined in the previous section, we can split each specification into simpler specifications. In particular, because the intersection of the specifications obtained with the modularity theorem is equivalent to the original specification, we can prove inconsistency by just translating a subset of the model and proving that such subset is inconsistent (no runs allowed).

For example, we can translate the model element of Figure 12.1b that represents the sending of an Ack message from the Emergency Brake to the Train Controller. This translation, according to [Table 12.4](#_bookmark75), would look like

 

*Q* : {}*{(Commands Received (Train Controller, *t*1))} *EType*

= Emergency Brake Ù *Clock* > *t*1

 

*C* : {(Ack(Emergency Brake, tack ))} *EType* = Emergency Brake

 

The translation of the Figure 12.1c transition triggered by the Commands Received message is

 

*Q* : {(Commands Received (Train Controller, *t*¢))} *EType* = Emergency Brake Ù *State*

= Wait Commands Ù *Clock* = *t*¢¢ Ù *t*¢¢ > *t*¢

*C* : {} *EType* = Emergency Brake Ù *State* = Reset Timer Ù *Clock* = *next*(*t''*)

 



and





 

*Q* : {} *EType* = Emergency Brake Ù *State* = Reset Timer Ù *Clock* = *t'''*



 

*C* :{} *EType* = Emergency Brake Ù *State* = Wait Commands Ù *Clock* = *next*(*t'''*)

 

Let us analyze the type of runs that satisfy the translation of the sequence diagram. We can observe that, for a run to satisfy the specification, if in a state there is a Commands Received message received by the Emergency Brake component, it



Consistency Management of UML Models                         **321**

 

must send an Ack message. In the sequence diagram translation, we do not specify if there is some other action local to the Emergency Brake. In fact, our simplified translation for sequence diagrams deals only with messages sent and received, not local actions. So the message can be returned immediately (next state) or after some local transitions (that is the meaning of {}*, which represents a sequence of zero or more states where the channel is empty). The specification, however, is clear in identifying that no other messages are sent or received by Emergency Brake before returning a message.

The translation of the state diagram of Figure 12.1c triggers a transition from Wait Commands to Reset Timer when the Commands Received message is received by Emergency Brake. We can identify the inconsistency by observing that all runs that fulfill our translation for Figure 12.1c never send the Ack message. The intersection of sets of runs identified by the two specifications is, therefore, empty. Thus, the two specifications are inconsistent.

In our formalism, we can prove consistency by composing query and constraint tuples and identifying contradictions. In particular, we chose to encode queries and constraints using Propositional LTL formulae [44]. The encoding changes for each definition of consistency. We can then prove that a system is consistent according to the chosen definition by proving that the LTL formula that encodes such definition is satisfiable. This proof can be automated by means of a SAT solver for LTL formulas. Examples of algorithms for assessing SAT of propositional LTL formulas and tools implementing them can be found in Goranko et al. [45] and Rozier and Vardi [46].

In this chapter, we do not give a complete translation for all definitions. Instead, we use the example of inconsistent specification from Figure 12.1b and 12.1c and encode the query and constraint specification to prove inconsistency according to Definition 1. For each tuple of query (*Q*) and constraint (*C*), we create the implication *Q* Þ **X***C*, where **X** is the next operator in LTL. If we can find a set of variables that satisfies the disjunction of all these implications, the specification is consistent according to Definition 1.

We capture this in the following theorem.

 

**Theorem 12.2**

 

​                  Consistency D1 Satisfiability. Given a specification SPEC , SPEC is consistent according to consistency Definition 12.1 *iff* the expression ⋀"(*Q*,*C*)Î SPEC *Q* Þ **X***C* is satisfiable.

​                  In this theorem, we assume that messages in the channel history are encoded using appropriate variables and nested temporal operators. The exact discussion of how to encode these messages is beyond the scope of this chapter. The proof of Theorem 12.2 follows from the definition of SPEC . In fact, the semantics of SPEC is defined as the set of runs that satisfy all query/constraint tuples. We encode each tuple as an implication in LTL that is true if a run satisfies it. The conjunction of all the LTL implications is true only if a run satisfies all of them. If the formula in Theorem 12.2 is not satisfiable, there exists no run that can satisfy all implications at the same time, thus SPEC is empty. On the other hand, if the expression is satisfiable, there exists



**322**                                       Real-Time Simulation Technologies

 

​      at least one run that can satisfy all queries and constraints, thus SPEC is nonempty. This proves Theorem 12.2.

Now we can consider how Theorem 12.1 and Theorem 12.2 apply to our example. From Theorem 1 we know that to prove inconsistency we are not required to compose all the queries and constraints. Instead we can split the specification into two sub-specifications, and the original one will be equivalent to the intersection of the new specifications. Then, if we can prove that one of the two is empty we know that the full specification must be inconsistent. We chose to compose only the specifications of Figure 12.1b and 12.1c. We prove that this subspecification is inconsistent (i.e., has an empty set of runs) and from Theorem 1 we obtain that the full specification is also inconsistent.

Consider all runs satisfying the translation of the transition from Wait Commands to Reset Timer in Figure 12.1c. We identify all runs with a trigger message Commands Received and a transition in the entity Emergency Brake with State changing from “Wait Commands” to “Reset Timer.”

Because the constraint of this specification is the query of the translation for the transition from Reset Timer to Wait Commands in Figure 12.1c, if we compose the two specifications, we obtain all runs where Emergency Brake reacts to a Commands Received by changing two states without sending any message.

We can now compose the current system into the translation of the Ack message specification in Figure 12.1b and discover that one of the next states of the runs selected must send an Ack message before any other messages are received by Emergency Brake. However, from state Wait Commands the system can exit only if the trigger message Commands Received is received. Therefore, by exploring specification tuples we can argue that because the Clock time greater than *t*1, at which the Ack message must be sent by the sequence diagram constraint, is finite and the specification of the state diagram does not allow any transition that sends messages without receiving anything from the state that it enters after the trigger message, we have a contradiction, and, therefore, the specifications are inconsistent.

If we observe the specification of the state diagram in Figure 12.1d, we can give the following translation for the transition from Reset Timer to Wait Commands:

*Q* :{} *EType* = Emergency Brake Ù *State* = Reset Timer Ù *Clock* = *t'''*

 

*C* :{(Ack(Emergency Brake, tack ))} *EType* = Emergency Brake Ù *State*

= Wait Commands Ù *Clock* = *next*(*t'''*)

With this change, the composition of the specifications for the state machine identifies a sequence of states initiated by the trigger message Commands Received that ends with the sending of an Ack message. In the composition with the specification from Figure 12.1b, we have that the state where the Ack message is sent must

happen at a time *next* (*next*(*t*¢¢)) that is greater than *t*1. Therefore, there is no contra-

diction between constraints and, thus, no inconsistency. To prove that the entire specification is consistent we would be required to add the translations of the remaining elements. Although this process is long and error-prone if performed by hand, the existence of automated tools for solving the SAT problem makes it a viable solution.

[12.2 <--- ](12_2.md) [   Зміст   ](README.md) [--> 12.4](12_4.md)