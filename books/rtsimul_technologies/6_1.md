[6 <--- ](6.md) [   Зміст   ](README.md) [--> 6.2](6_2.md)

## 6.1. INTRODUCTION

Traditional development of software for embedded systems is highly platform specific. Exploiting a specific platform enables reducing cost of hardware to a minimum, whereas high development costs of software are considered acceptable in the case of large quantities of devices being sold. Nowadays, with ever more powerful processors in the low-cost range, we observe even more of a shift of functionality from hardware to software and a general tendency toward more ambitious requirements. Modern cars or airplanes, for example, contain dozens of the so-called electronic control units interconnected by multiple buses and are driven by several million lines of code. To cope with the increased complexity of the embedded software, a platform-independent “high-level” programming style becomes mandatory, as testing alone can never identify all the errors. In particular, in the case of safetycritical real-time software, this applies not only to functional aspects but to the temporal behavior of the software as well. Dealing with time, however, is not covered at all by any of the existing high-level imperative languages. Simulation environments that offer delay blocks allow at best the approximation of the simulated behavior to the behavior on the execution platform.

Традиційна розробка програмного забезпечення для вбудованих систем дуже залежить від платформи. Експлуатація конкретної платформи дозволяє знизити вартість обладнання до мінімуму, тоді як високі витрати на розробку програмного забезпечення вважаються прийнятними у випадку великої кількості проданих пристроїв. У наш час із дедалі потужнішими процесорами в недорогому діапазоні ми спостерігаємо ще більше переміщення функціональності від апаратного забезпечення до програмного забезпечення та загальну тенденцію до більш амбітних вимог. Сучасні автомобілі чи літаки, наприклад, містять десятки так званих електронних блоків керування, з’єднаних між собою декількома шинами та керованими кількома мільйонами рядків коду. Щоб впоратися зі зростаючою складністю вбудованого програмного забезпечення, незалежний від платформи стиль програмування «високого рівня» стає обов’язковим, оскільки лише тестування ніколи не може виявити всі помилки. Зокрема, у випадку критично важливого для безпеки програмного забезпечення реального часу це стосується не лише функціональних аспектів, але й тимчасової поведінки програмного забезпечення. Однак робота з часом взагалі не охоплюється жодною з існуючих імперативних мов високого рівня. Середовища моделювання, які пропонують блоки затримки, дозволяють у кращому випадку наблизити змодельовану поведінку до поведінки на платформі виконання.

One reason is that execution and communication times related to computational tasks of an application can have a substantial influence on the application behavior that is unaccounted for in high-level models [1]. Consequently, the implementation of a model on a certain execution platform may violate requirements that are proved to be satisfied in the model. Explicitly considering execution times at higher levels of abstractions has been proposed as a way to achieve satisfaction of real-time properties [2]. One promising direction in this respect is the logical execution time (LET) [3]. This chapter presents the explicit specification of the timing behavior using the LET-based notation called Timing Definition Language (TDL). TDL is under active, commercially supported development [4]. As simulation is widely used in industry for testing and validation of complex systems (e.g., Ref. [5]), it is important to be able to simulate TDL-based systems. Thus, we describe how TDL has been integrated with two distinctly different simulation environments, that is, MATLAB® and Simulink® [6] from MathWorks® and Ptolemy [7], an open source environment developed at the University of California at Berkeley. Where MATLAB and Simulink is treated as yet another execution platform, Ptolemy is more closely aligned with TDL principles and so offers simulation capabilities that allow a more straightforward integration of TDL. We chose these two simulation environments to demonstrate two quite different approaches for simulating TDL-based systems.


Однією з причин є те, що час виконання та зв’язку, пов’язаний з обчислювальними завданнями програми, може мати суттєвий вплив на поведінку програми, яка не враховується в моделях високого рівня [1]. Отже, реалізація моделі на певній платформі виконання може порушити вимоги, які, як доведено, задовольняються в моделі. Явне врахування часу виконання на вищих рівнях абстракцій було запропоновано як спосіб досягнення задоволення властивостей реального часу [2]. Одним з перспективних напрямів у цьому відношенні є логічний час виконання (LET) [3]. У цій главі представлено явну специфікацію поведінки синхронізації з використанням нотації на основі LET, яка називається Мова визначення часу (TDL). TDL знаходиться в стадії активної комерційної підтримки [4]. Оскільки моделювання широко використовується в промисловості для тестування та перевірки складних систем (наприклад, [5]), важливо мати можливість моделювати системи на основі TDL. Таким чином, ми описуємо, як TDL було інтегровано з двома чітко різними середовищами моделювання, тобто MATLAB® і Simulink® [6] від MathWorks® і Ptolemy [7], середовищем з відкритим кодом, розробленим в Університеті Каліфорнії в Берклі. Там, де MATLAB і Simulink розглядаються як ще одна платформа виконання, Ptolemy більше узгоджується з принципами TDL і тому пропонує можливості моделювання, які дозволяють більш просту інтеграцію TDL. Ми вибрали ці два середовища моделювання, щоб продемонструвати два досить різні підходи до моделювання систем на основі TDL.

[6 <--- ](6.md) [   Зміст   ](README.md) [--> 6.2](6_2.md)