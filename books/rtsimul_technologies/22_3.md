[22.2 <--- ](22_2.md) [   Зміст   ](README.md) [--> 22.4](22_4.md)

**22.1**            **MODELICA FEATURES**

With that brief introduction to the Modelica language, this section elaborates more specifically on Modelica language features and associated attributes that make Modelica a desirable platform for real-time simulation. The focus will be primarily on Modelica although a few tool-specific implementations relative to real-time simulation capability are briefly discussed.

 

**22.1.1**             **o****pen** **p****latforM**

Modelica is a nonproprietary language and thus offers an open platform for model and application development. The nonproprietary nature of the language allows intellectual property captured in models to be maintained separate from the tools thereby allowing model developers to move freely among Modelica-capable tools based on their relative merits. This situation is in stark contrast to other simulation tools where the models are integrated with the tools in a proprietary way and thus are not portable to other tools. While conformance to the same language syntax allows tool-independent model formulation, it should be noted that simulating the same model identically between tools also requires that the execution engine is formalized and used as reference semantics for each of the tools.

Another opportunity that arises from the open platform is that of accessibility. Since the Modelica specification is open and freely available, any interested party is welcome to create a parser and even a compiler to interpret Modelica source code. With source code for many solvers already available, it is certainly feasible to create custom tools for Modelica model development and simulation. For example, the Modelica Software Development Kit (SDK) [12] provides an API and Modelica compiler to allow Modelica code to be embedded into existing software and tools.



Modelica as a Platform for Real-Time Simulation                     **557**

 

The open platform also supports innovation from small companies and universities. Several open-source, Modelica-based projects have been initiated. OpenModelica [13] is an open-source Modelica modeling and simulation environment. JModelica.org [14] is an open-source Modelica-based platform for simulation and optimization. Scicos

[15] developed at INRIA is a modeling and simulation environment that includes partial support for Modelica. While these offerings may not be as comprehensive in their support of the Modelica language as existing commercial tools, they certainly illustrate potential for innovative offerings based on the open Modelica platform.

Besides accessibility to the Modelica language for custom tool development, another benefit of the open platform is the large quantity of high-quality models that are available in the MSL and free Modelica libraries. Rather than working on simplified, academic problems, the existing Modelica model base provides high-quality, relevant models in multiple engineering domains that can be used to fully support tool and algorithm development. These models allow tool and algorithm innovators to work on real technical problems with models that are already available thus reducing the burden of creating complex examples to showcase new algorithm or tool capabilities.

 

**22.1.2**              **a****causal** **M****odeling**

Modelica supports two of the most common modeling formalisms for continuous systems: block diagram and acausal modeling [8]. The block diagram approach involves constructing systems of component blocks to calculate unknown quantities from known quantities. The block diagram, or causal, approach is very well suited to modeling of controllers where the signal flow concept is quite natural. The sensor signals are known inputs, and the controller model is responsible for calculating actuation signals based on the sensed signals. The block diagram approach is not as well suited to physical system modeling in which the relevant mathematical description for the behavioral dynamics consists of conservation equations. For example, what would be the “input” to a resistor?

Acausal modeling involves modeling components from a free body or first principles sense without a priori assumptions about I/O causality. Acausal models specify relationships in which potentials across components drive flow of conserved quantities. Physical components are naturally acausal and are naturally described by the Modelica connec- tor-based approach. [Figure 22.7 ](#_bookmark136)shows an example of a mechanical system modeled with both acausal and block diagram formalisms in Modelica. For those familiar with the physical system schematics, the acausal representation is a natural virtual representation. Furthermore, the acausal component models can be reused regardless of the causality imposed by the system while the implementation of the block diagram model changes drastically because of fundamental changes in the inputs and thus the model structure.

Another benefit of the acausal modeling formalism as implemented in Modelica is that components can generally be connected in a physical way without restriction. This feature has a profound impact both on model management and configuration and on model computational efficiency, a critical factor in real-time simulation. One of the key challenges in real-time simulations is striking a balance between model fidelity and computational expense. To achieve this balance, idealizations to improve performance are often required.



**558**                             Real-Time Simulation Technologies

 

Fixed

​                                                                

​          Torque pro le          

​          Planetary          

​          Torque          

​          shaft_1          

​          shaft_2          

​          Tau          

​          Duration = 2          

​          *J* = *J*1          

​          Ratio = *R*          

​          *J* = *J*2          











Fixed1





(a)



 

​            

​          omega_1          

​          phi_1          

​          Phi1          

​          l     *k* = 1          

​          tau_in          

​          alpha_2          

​          omega_2          

​          *k* = –*R*     phi_2          

​          Phi2          

​          l                    l     *k* = –*R*/(*R*^2**J*1+ *J* 2)         *k* = 1                *k* = 1     alpha_1             tau_1          

​          tau_s     –          

​          tau_carrier          

​          tau_c          

​          *k* = –*R*          

​          *k* = *J*1          

​          *k* = – (1 + *R*)          









(b)

**FIGURE 22.7** Sample model in (a) acausal and (b) block diagram formalisms.

 

To illustrate this point, a vehicle modeling example is considered. There are many compliant elements in a vehicle drivetrain, and these elements can lead to significant noise, vibration, and harshness (NVH) issues in the driveline as excited under various driving conditions. Capturing the NVH effects in the driveline necessitates the modeling of the key compliances in the system and results in higher-order dynamics in the vehicle drivetrain. These higher-order dynamics are, in fact, the focus of the NVH modeling effort. In addition to the NVH model, another class of vehicle models is focused on the simulation of vehicle performance and fuel economy. Performance and fuel economy models are typically simulated over long time scales, including drive cycles that can be thousands of seconds in length. On this time scale, the higher-frequency NVH effects do not typically impact the vehicle-level results significantly. Thus, the idealization of the drivetrain as rigid is a perfectly reasonable assumption for a performance and fuel economy model.



Modelica as a Platform for Real-Time Simulation                     **559**



 

 

 

 

 

 

 

 

 

 

 

 

 

Engine





 

 

 

Driver WOT

 

 

 

 

Crankshaft

 

*J* = *J*crank





 

 

Shift schedule

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

   Transmission





 

 

 

 

 

 

 

 

 

 

Final drive

 

 

Ratio = fd_ratio





 

 

Right wheel inertia

 

 

​     ![Підпис: Right halfshaft](file:///C:/Users/OLEKSA~1/AppData/Local/Temp/msohtmlclip1/01/clip_image004.png)     ![Підпис: J = Jhalfshaft](file:///C:/Users/OLEKSA~1/AppData/Local/Temp/msohtmlclip1/01/clip_image005.png)     ![Підпис: Right compliance](file:///C:/Users/OLEKSA~1/AppData/Local/Temp/msohtmlclip1/01/clip_image006.png)     ![Підпис: c = c d = d](file:///C:/Users/OLEKSA~1/AppData/Local/Temp/msohtmlclip1/01/clip_image007.png)*J* = *J*wheel

 

 

 

 

 

​     ![Підпис: Left halfshaft](file:///C:/Users/OLEKSA~1/AppData/Local/Temp/msohtmlclip1/01/clip_image008.png)     ![Підпис: Dierential](file:///C:/Users/OLEKSA~1/AppData/Local/Temp/msohtmlclip1/01/clip_image009.png)Brakes





 

 

​     ![Підпис: Vehicle speed v ](file:///C:/Users/OLEKSA~1/AppData/Local/Temp/msohtmlclip1/01/clip_image010.png)Right wheel





 

 

 

 

 

 

 

 

 

 

Chassis





 

 

 

 

 

 

 

 

 

Aero drag

 

 

 

 

Rolling resistance



 

 



​     ![Підпис: J = Jhalfshaft](file:///C:/Users/OLEKSA~1/AppData/Local/Temp/msohtmlclip1/01/clip_image011.png)Mounts





​     ![Підпис: Lift compliance](file:///C:/Users/OLEKSA~1/AppData/Local/Temp/msohtmlclip1/01/clip_image012.png)     ![Підпис: c = c](file:///C:/Users/OLEKSA~1/AppData/Local/Temp/msohtmlclip1/01/clip_image013.png)     ![Підпис: d = d](file:///C:/Users/OLEKSA~1/AppData/Local/Temp/msohtmlclip1/01/clip_image014.png)Left wheel

Left wheel inertia



 

*J* = *J*wheel

(a)

 



   Shift schedule

 

Driver                                          Right wheel inertia

WOT





Right wheel



​     ![Підпис: Right halfshaft](file:///C:/Users/OLEKSA~1/AppData/Local/Temp/msohtmlclip1/01/clip_image016.png)     ![Підпис: Vehicle speed v ](file:///C:/Users/OLEKSA~1/AppData/Local/Temp/msohtmlclip1/01/clip_image017.png)*J* = *J*wheel

 

 



 

​     ![Підпис: J = Jhalfshaft](file:///C:/Users/OLEKSA~1/AppData/Local/Temp/msohtmlclip1/01/clip_image018.png)Crankshaft





Final drive





Chassis



Aero drag



 



Engine





*J* = *J*crank





Transmission





Ratio = fd_ratio





​     ![Підпис: Left halfshaft](file:///C:/Users/OLEKSA~1/AppData/Local/Temp/msohtmlclip1/01/clip_image019.png)Brakes





 

​     ![Підпис: Dierential](file:///C:/Users/OLEKSA~1/AppData/Local/Temp/msohtmlclip1/01/clip_image020.png)Rolling resistance



 

 



​     ![Підпис: J = Jhalfshaft](file:///C:/Users/OLEKSA~1/AppData/Local/Temp/msohtmlclip1/01/clip_image005.png)Mounts





Left wheel

Left wheel inertia



 

*J* = *J*wheel

(b)

**FIGURE 22.8** Simplified vehicle models with a (a) compliant and (b) rigid drivetrain.

 

To illustrate the two classes of vehicle models, consider Figure 22.8, which shows a simplified vehicle model with a compliant and rigid drivetrain. The two models are identical save for the spring-damper element that represents the compliance of the half shafts. Note that the rigid model actually has two inertia elements connected



**560**                             Real-Time Simulation Technologies

 

together representing the wheel and half shaft inertias. While many physical modeling tools have difficulties with such configurations (because they lead to high-index DAEs), this is not the case in Modelica, which was designed with high-index systems in mind. Connecting two inertias together might seem odd, especially in a flat model such as the ones shown in [Figure 22.8](#_bookmark137). This topic will be addressed shortly as part of the configuration management discussion.

Now consider the situation where the compliant model is used for performance and fuel economy simulations, perhaps because of limitations in the modeling tool to handle rigid, kinematic connections. In an attempt to stiffen the compliant model to mimic the behavior of a truly rigid model, the stiffness of the compliant element is increased. Figure 22.9 shows simulation results from a wide open throttle (WOT) simulation of the rigid and compliant vehicle model. The stiffness of the compliant vehicle model has been set to roughly twice the typical half shaft stiffness to approach the behavior of the rigid model. The vehicle-level behavior of the two models is nearly identical as can be seen from the vehicle speed and the engine speed comparisons. However, the computational expense is nearly twice as great for the compliant model as illustrated by the CPU time required for the simulation. In particular, note

 



​                                                                                                                                                                                                              

​          Rigid     Compliant          



80



​     ![Підпис: Vehicle speed (mph)](file:///C:/Users/OLEKSA~1/AppData/Local/Temp/msohtmlclip1/01/clip_image021.png)70

60

50

40

30

20

10

00           2

​               ![Підпис: Engine speed (RPM)](file:///C:/Users/OLEKSA~1/AppData/Local/Temp/msohtmlclip1/01/clip_image022.png)     

​                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   



5000



 

4000

3000

2000

1000





 

 

 

 

 

 

4            6            8           10          12          14          16



00           2            4           6            8           10          12          14          16

​                                                                                                                                                                                 1.2

​     ![Підпис: CPU time (seconds)](file:///C:/Users/OLEKSA~1/AppData/Local/Temp/msohtmlclip1/01/clip_image023.png)1.0

0.8

0.6

0.4

0.2



0.00           2            4           6            8

Time (seconds)



10          12          14          16



**FIGURE 22.9** Simulation results from rigid and compliant vehicle model.



Modelica as a Platform for Real-Time Simulation                     **561**

 

the jumps in CPU time corresponding to each shift event in the compliant model. While this evaluation was performed with an open loop WOT test to try and isolate the compliant effects, it should be noted also that the WOT simulation is not nearly as dynamic as a drive cycle where the driver inputs could be changing much more rapidly thus introducing even more shift events and likely resulting in even larger differences in simulation time between the compliant and the rigid models.

While the simple vehicle model shown in [Figure 22.8 ](#_bookmark137)modeled the drivetrain in a flat fashion at the top level of the model without introducing another level of hierarchy, this modeling approach was primarily used to make it easier to illustrate the differences between the rigid and the compliant models. In fact, even this simple model includes enough components and connections that the top level of the model is becoming crowded and would benefit in terms of readability from the grouping of additional components into logical subsystems. As mentioned previously, it may seem that the potential need for the compliant element in the vehicle model is an artifact of the modeling of the half shaft and wheel as two separate inertias instead of a single effective inertia. While it is easy to see the two inertias connected together in the flat model, it would not be as obvious if the two inertias were part of separate subsystems. Another benefit of grouping components into subsystems is to take advantage of an architecture-based modeling and model configuration approach. This topic will be discussed in more detail later in this chapter. An architecture-based modeling approach hinges on the ability to arbitrarily connect components. If the modeling tool cannot handle arbitrarily connected components, one remedy for the underlying conflict between the configuration management and the model mathematics is to insert unphysical interfaces, such as stiff springs in a mechanical system to ensure that the two inertias are not connected together, at the expense of computational efficiency. With no restrictions on component connections in Modelica, Modelica can support architecture-based model configuration while maintaining the natural physical inter-

faces between components, even if those interfaces include rigid connections.

 

**22.1.3**              **s****yMbolic** **M****anipulation**

While acausal models are clearly preferable to block diagram implementations for physical systems modeling, acausal models do introduce simulation challenges. While ODEs are convenient to solve, most physical problems in science and engineering are naturally described by DAEs. Acausal models require the solution of DAEs that include both ODEs and algebraic equations representing the system constraints. The efficient solution of DAEs, particularly high-index DAEs that result from structurally singular systems that have constraints between states, requires a combination of symbolic and numerical approaches and is an active research topic. The Modelica language has been designed to specifically protect for these approaches and optimizations to support the generation of efficient code from DAEs.

While Modelica provides the language to allow the expression of mathematical models, it does not prescribe the method for solving the resulting DAEs. The solution method and solver integration falls into the realm of the Modelica compiler, be it commercial or open source as described previously. This section briefly describes some of the symbolic and numerical techniques used in the solution of DAEs. The intent is



**562**                             Real-Time Simulation Technologies

 

not to focus on the algorithms or techniques but is instead to focus on the Modelica language elements that support them. The interested reader is referred to the works by Cellier et al. [4], Cellier and Kofman [16], Celier [53], and Anderson [17] for more details on the algorithms and numerical techniques briefly introduced here.

The mathematical description of models in Modelica consists of Boolean, discrete, and DAEs. On the basis of a Modelica model, the resulting set of Boolean equations, discrete equations, and DAEs can be obtained. However, there are no general-purpose solvers for these sets of equations. Direct numerical DAE solvers typically result in slow simulations. The standard approach in Modelica-based tools is to translate the DAE into an ODE form for solution. Since a Modelica model preserves the equations that describe the relationships between variables in symbolic form, it is possible to perform symbolic analysis and manipulation to aid in the solution of the resulting set of equations. Symbolic analysis helps determine an efficient way to develop a causal set of equations that can be solved numerically or even symbolically if possible.

To generate a causal set of equations, the first task is to understand the structure of the problem. One way to understand the problem structure is through a structure incidence matrix [16,17]. The rows of the matrix are indexed by the equations and the columns by the variables or unknowns. If an equation contains a given variable, the number one is placed in the corresponding entry in the matrix. Using the information provided in the matrix, a rule-based approach can be used to determine which variable should be solved from each equation. Another method to generate a causal set of equations is an algorithm based on graph theory and first proposed by Tarjan [18]. In this method, a structure digraph shows the equations and unknowns as nodes in vertical columns with lines drawn between nodes if an unknown appears in a given equation. On the basis of the information in the structured digraph, the algorithm defines an approach that can sort the equations into a causal, executable sequence. The resulting equivalent structure incidence matrix is lower triangular, and therefore, there is an equation to compute each of the unknowns from variables that have already been computed. The Pantelides algorithm [5] is a popular causalization algorithm because of its compact recursive implementation [16].

While equation sorting is a key component in the solving of DAEs, it is not entirely sufficient for full triangularization, in particular, in case of cyclic dependencies between variables, or so-called *algebraic loops*. Instead of a true lower triangular incidence matrix, the sorting algorithms result in block lower triangular form with the blocks containing the equations that are part of the algebraic loops. Depending on the nature of the problem, the loop equations could be either linear or nonlinear, and there are many techniques to solve the resulting equations. Blocks containing linear equations can be solved efficiently (and symbolically if they are small enough), but nonlinear equations will generally require Newton iterations.

An approach that has a profound impact on computational efficiency for algebraic loops is tearing. A tearing algorithm seeks to break apart a system of equations by assuming values for variables and then solving the resulting set of equations with residual equations for the torn variables based on the system of equations. By analyzing the structure of the underlying system, it is possible to identify tearing variables that can have a drastic impact on computational efficiency [16]. Tearing often leads



Modelica as a Platform for Real-Time Simulation                     **563**

 

to a reduction in the number of iteration variables for solving the nonlinear equations. It may also result in significant decoupling of simultaneous systems of equations with the potential for more efficient solution of the decoupled equations based on the known value of the tearing variable.

A key element to computationally efficient modeling is the handling of events where logical expressions change value [16]. Event handling is especially important since discontinuous equations or changes in model behavior must be handled as discrete events for numerical integration schemes. Since the integration is typically interrupted to resolve each event, unnecessary events can severely hamper computational speed. Modelica includes language semantics to control the handling of events. The semantics of the *smooth* operator indicate to the Modelica compiler that an expression is continuously differentiable up to the order provided by the user [1]. Since the expression on which the *smooth* operator acts can involve complex branching constructs such as *if* statements, the *smooth* operator aids the Modelica compiler in identifying the structure of the problem regarding continuity of the variables and partial derivatives of the variables in the expression and potentially avoiding unnecessary events at branching conditions since the modeler has guaranteed continuity up to a particular order. The *noEvent* operator in Modelica is also used to avoid the generation of events by controlling the generation of crossing functions from complex expressions with branching conditions based on variables of type real [1].

As noted previously, minimizing the number and size of nonlinear equations that must be solved can also have a significant impact on computational efficiency. The *semiLinear* operator in Modelica is used to help the Modelica compiler identify situations where an expression is linear with respect to a given variable but with two different slopes when the variable is positive and negative [1]. This operator can help the compiler to generate sets of linear equations rather than nonlinear ones. The *semiLinear* operator is symbolic in nature and gives the underlying tool a greater understanding of the modeler’s intent, which can help resolve some ambiguities in certain classes of models. One example of such *semiLinear* operator usage is in the handling of reversing flow in fluid systems where the flow enthalpy is either the upstream enthalpy or the downstream enthalpy based on the direction of mass flow [19].

Another example where symbolic information is very useful is in state selection. For acausal models, state selection is not trivial since variables introduced in completely different subsystems can end up being kinematically coupled through the connection graph. Therefore, it is necessary to symbolically analyze the entire model to identify such cases and resolve a unique set of states. Furthermore, the selection of appropriate states for integration can drastically affect computational efficiency. For example, the modeler might want to control the states that are selected as part of the symbolic manipulation process based on knowledge of the problem or details of the formulation. In thermodynamic problems, the conservation equations are written in terms of mass and energy, but it is typically preferable to select the intensive variables pressure and temperature as states rather than the extensive variables that depend on the size of the system and can vary greatly over a given simulation. Furthermore, consider that property relationships, such as enthalpy and internal energy, are often explicitly written as nonlinear functions of pressure and temperature, and any other state selection would require the solution of a nonlinear



**564**                             Real-Time Simulation Technologies

 

equation to determine the intensive variables. The Modelica language includes the *stateSelect* language element to help the modeler control the selection of states [1]. The *stateSelect* element also allows the modeler to exert varying degrees of control over the state selection. Using the *stateSelect* attribute, it is possible to specify that a given variable is always selected as a state, that it should be preferred as a state, that it should not have any preference with regard to state selection, that it should be avoided as a state, or, finally, that it should never be chosen as a state. The Modelica language even allows initial equations to be specified for variables that are not states. For example, in a thermodynamic system with mass and energy as states, pressure and temperature can be specified for initialization. Another example of the impact of state selection on computational efficiency is in three phase electrical systems where the dq0 or Park transformation [20] can be applied to calculate alternative currents that exhibit more DC-like behavior. The choice of the alternative currents as states can drastically improve computational speed and can be easily achieved in Modelica using the *stateSelect* construct [21].

To illustrate the impact of equation sorting, state selection, and causality on computational efficiency, consider the following electrical example reproduced from the excellent tutorial by Bernhard Bachmann [21] on the mathematical aspects of objectoriented modeling. The model shown in Figure 22.10 is a simple electrical circuit consisting of sinusoidal voltage source, inductor, and a nonlinear resistor implementation. Two equivalent models are formulated for the nonlinear resistor with *i* = *f*(*v*) causality as shown in Equation 22.1 and *v* = *f*(*i*) causality as shown in Equation 22.2:

 

*i* = *a* ´ tanh (*b* ´ *v*)                        (22.1)

 

 

æ 1 + *i* ö



  *v* = 1 log ç    *a* ÷



(22.2)



​    2*b*    ç 1 *i* ÷

 ç    *a* ÷ø

 

 

​            

​          *L* = *L*          

​          +          



​    

![Підпис: sine voltage – ](file:///C:/Users/OLEKSA~1/AppData/Local/Temp/msohtmlclip1/01/clip_image025.png)

​    

![Підпис: Resistor](file:///C:/Users/OLEKSA~1/AppData/Local/Temp/msohtmlclip1/01/clip_image026.png)Inductor



 

 

 

 

 

 

 

 

 

Ground

**FIGURE 22.10** Electrical example model with nonlinear resistor.



Modelica as a Platform for Real-Time Simulation                     **565**

Figure 22.11 shows the simulation results from the circuit with the two resistor implementations. The voltage and the current in the resistor are identical as expected, but the computational expense is significantly higher for the *i* = *f*(*v*) formulation. The explanation for this effect is a result of the interaction between the state selection and the causality of the nonlinear equation. For this model, the typical state selection where differentiated variables are automatically chosen as states results in the current as a state. With the *i* = *f*(*v*) causality, a nonlinear equation must be solved to



 

​     

​                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          



0.4



​          0.3

0.2

​     ![Підпис: Voltage (V)](file:///C:/Users/OLEKSA~1/AppData/Local/Temp/msohtmlclip1/01/clip_image027.png)0.1

0.0

–0.1

–0.2

–0.3

–0.4

–0.5 0                   2                   4

​     

​                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          



0.20



​          0.15

0.10

​     ![Підпис: Current (A)](file:///C:/Users/OLEKSA~1/AppData/Local/Temp/msohtmlclip1/01/clip_image028.png)0.05

0.00

–0.05

–0.10

–0.15

–0.20

–0.25 0                   2                   4

​                                                                                                                                                             

​          *i* = *f* (*v*)     *v* = *f* (*i* )          



0.25



 

​     ![Підпис: CPU time (seconds)](file:///C:/Users/OLEKSA~1/AppData/Local/Temp/msohtmlclip1/01/clip_image029.png)0.20

 

0.15

 

0.10





 

 

 

 

 

 

 

 

 

6                  8                  10

 

 

 

 

 

 

 

 

 

6                  8                  10



 



0.05

 

0.00 0





 

2                   4                   6

Time (seconds)





 

8                  10



**FIGURE 22.11** Simulation results from electrical example with nonlinear resistor.



**566**                             Real-Time Simulation Technologies

 

determine the voltage drop across the resistor. With the *v* = *f*(*i*) causality, a solution of nonlinear equations is not required as the nonlinear equation can simply be evaluated for the voltage drop. Bachmann [21] notes that the causality that results in the most efficient solution depends on the model topology. If the inductor and the resistor were placed in parallel rather than in series as in [Figure 22.10](#_bookmark138), then the *i* = *f*(*v*) implementation would be the more efficient formulation. This example also highlights why it is so important to have symbolic model representations where the formulation details are visible such that these issues can be diagnosed and understood.

 

**22.1.4**              **i****nverse** **M****odels**

Another benefit of acausal modeling is the support for inverse models. An inverse model is formulated by specifying model outputs rather than model inputs. The resulting executable model must then calculate the model inputs such that the model outputs are as prescribed. Causality is reversed in an inverse model since outputs are known and inputs are unknown thus requiring an acausal model formulation. Inverse models are sometimes denoted as backward models as opposed to forward models that are conventionally driven with known or calculated inputs. Inverse models can be used in place of controller logic to support rapid, upfront design concept assessment and feasibility without requiring a detailed controller design and tuning effort that would otherwise be required to reasonably assess the concept design [22]. Inverse models are also extremely useful for providing insight into control system design. A few examples of inverse modeling with Modelica involve the formulation of driver models that perfectly follow a prescribed vehicle speed trace for powertrain simulations [23], energy consumption studies in aircraft equipment systems in response to prescribed load traces [24], and model-embedded control applications [22].

Inverse modeling approaches can also be used to impact computational efficiency. Inverse models can be used to implement perfect control in lieu of proportional– integral–derivative (PID) controller implementations with high gains. While high gains can improve the ability of the system to follow a desired trace, significant tuning is often required to achieve desired control response. A side effect of high gains is the introduction of high-frequency inputs that can excite high-frequency response in the model thus affecting computational efficiency. The situation is especially acute if the high-frequency response is beyond the bandwidth of interest for the simulation. Ultimately, however, the high-gain implementation is simply trying to mimic the perfect control response.

Inverse models can also be used to implement localized perfect control in the context of a complex control architecture where a particular control feature is replaced by a perfect control implementation. One can imagine this model inversion acting as a sort of “perfect control,” which, assuming the system is sufficiently invertible, ensures that the desired response is exactly achieved. By implementing perfect control, one or more states in the model can typically be removed thus reducing the total number of states in the system as well as potentially eliminating eigenmodes that slow down the integration as well. Reduction in the number of states is especially useful for model embedded control applications where the computational expense grows nonlinearly with the number of states in the system [22]. It should be noted



Modelica as a Platform for Real-Time Simulation                     **567**

that, depending on the linearity of the model being controlled, perfect control can result in nonlinear systems that were not present in the forward facing model. The ability of a Modelica compiler to tear nonlinear systems is the key to minimizing the impact of nonlinear systems generated by a perfect control approach. If the nonlinear systems are too extensive or prove difficult to solve, it is certainly possible that the computational efficiency of the perfect control approach could be degraded compared to the forward facing implementation. The trade-off between nonlinear systems and more states with potentially linear systems must be evaluated on a per problem basis.

As an illustration of perfect control in Modelica, consider again the model shown in [Figure 22.2](#_bookmark131). Figure 22.12 shows the original controller implementation with a PID controller and also a perfect control implementation. Note that the PID controller has been replaced by a block from the MSL to handle inverse problems. Simulations were conducted by simply replacing the original controller with the perfect controller using the Modelica language features for model configuration. [Figure 22.13 ](#_bookmark139)shows results from running the simulation with the perfect control. The flow command limits have



   Desired temperature



Gain



*k* = –1



PID PID





 

 

Flow command



Temperature             Gain 1

 

 



 

 

Desired temperature



*k* = –1





(a)



​            

​          Flow     command          

​          Temperature          









(b)

**FIGURE 22.12** PID (a) and perfect control (b) temperature implementations.



**568**                             Real-Time Simulation Technologies

 

​                            

​                                                                                                     Desired load Actual load                                                                                                                                                                                                                                                                                                                                                                                                                                                                



25,000



​     ![Підпис: Power (W)](file:///C:/Users/OLEKSA~1/AppData/Local/Temp/msohtmlclip1/01/clip_image032.png)20,000

15,000

10,000

5,000

​     

​                         0                 200                  400                  600                  800                  1000                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         0                 200                  400                  600                  800                  1000                            



0



 

​     ![Підпис: Battery voltage (V)](file:///C:/Users/OLEKSA~1/AppData/Local/Temp/msohtmlclip1/01/clip_image033.png)     

​                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      



200



​    180

160

140

120

100

 

​     ![Підпис: Battery temperatue (K)](file:///C:/Users/OLEKSA~1/AppData/Local/Temp/msohtmlclip1/01/clip_image034.png)     

​                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 



335



330

325

320

315

310

305

300

​     

​                         0                 200                  400                  600                  800                  1000                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         0                 200                  400                  600                  800                  1000                            



295



 

​         ![Підпис: Flow command (–)](file:///C:/Users/OLEKSA~1/AppData/Local/Temp/msohtmlclip1/01/clip_image035.png)     

​                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      



2.5



2.0

1.5

1.0

0.5

0.0

Time (seconds)

**FIGURE 22.13** Sample simulation results from the motor battery example with perfect controller.

 

been removed to illustrate the commands issued by the perfect controller to achieve the desired battery temperature. With perfect temperature control, the system can also meet the desired load command. It should be noted that the unconstrained perfect control simulation yields the dynamic range necessary by the controller to achieve the desired output response. Thus, the results are not identical to those in [Figure 22.4](#_bookmark133) using the PID controller for which the flow command was limited. Note, however, that there is evidence of some oscillatory behavior in the flow command signal from the PID controller implementation in Figure 22.4. For this sample problem, no effort was expended to tune the controller to potentially reduce or eliminate the oscillatory commands for the PID implementation; obviously, no tuning is required for the perfect control implementation to identically achieve the desired target.



Modelica as a Platform for Real-Time Simulation                      **569**

 

**22.1.5**              **M****odel** **c****onfiguration**

With a distributed, acausal model development approach, system models are constructed through connections between component or subsystem models. While it is possible to assess model fidelity with testing at the component and subsystem level, the impact of individual model implementations on computational efficiency is often not revealed until the system model is assembled and tested. As models transition from desktop simulations to real-time platforms, variants of individual models may be required to support real-time execution.

Model configuration and variant management are key components of effective model management for any model-based systems development effort. The Modelica language includes several language features that directly support model configuration. To support plug-and-play model configuration, the Modelica language allows configuration management through the replaceable language construct. The replaceable semantics allow model variants to be created by replacing individual models with other compatible models. With a strong typing system, compatible models can be easily identified. Returning to the motor battery example, consider the construction of the model with the perfect controller. The perfect controller model variant is constructed by replacing the original controller with the perfect controller (note the replaceable qualifier before the instantiation of the controller component in [Figure 22.3](#_bookmark132)). The Modelica code to create the model variant is shown in Figure 22.14. Since Modelica supports inheritance, the model variant is created by inheriting from the original model shown in Figure 22.3 and simply replacing the original controller implementation with the PID implementation. While this example illustrates configuration of a top-level model component, model configuration through the replaceable construct can occur at any level of the model hierarchy. The ability to create model variants without code duplication increases modeling efficiency and aids in effective model management. The replaceable construct allows plug-and-play configuration of different versions of the same model with selected model variants to support realtime applications.

As shown in the motor battery example, Modelica models can be easily constructed by connecting component models, and model variants can be created using the replaceable construct. The next level in model configuration management uses prewired model architectures of configurable components for plug-and-play construction of model variants. [Figure 22.15 ](#_bookmark140)shows a sample model architecture to support vehicle system modeling [23]. Model architectures offer an even more powerful platform for managing model variants as many different applications can be supported with the same architecture. The same architecture can support models of varying levels of detail, a key feature for real-time modeling.

 

 

model MotorwithThermalBatteryPerfect extends motorWithThermalBattery (redeclare

Implementations.TemperatureControlPerfect controller);

a;

end MotorwithThermalBatteryPerfect;

**FIGURE 22.14** Modelica code for example model with perfect controller.



**570**                             Real-Time Simulation Technologies

​                  

​            Driver            

​            Controller network            

​            Accessories            

​            Powerplant            

​            Transmission            

​            Driveline            

​            Brakes            

​            Chassis            

​            PowertransMount            

​            y            

​            World            

​            Road            

​            Atmosphere            

​            Electrical power      network         ermal network            

​            Cabin            







x

 

**FIGURE 22.15** Vehicle model architecture. (From Batteh, J., and M. Tiller, *Proceedings of the 7th International Modelica Conference*, Como, Italy, pp. 823–32, Modelica Association, 2009. With permission.)

 

**22.1.6**              **r****eal****-t****iMe** **l****anguage** **e****xtensions** **and** **i****nterfaces**

As a result of increased interest in real-time computing and model-based control system development, new language elements have been introduced in Modelica for use in embedded systems. Stemming from the ITEA2 EUROSYSLIB and ITEA2 MODELISAR projects, Modelica language extensions have been designed and included in the Modelica 3.2 Specification [1] that allow models of embedded systems to be partitioned into various elements to support model-in-the-loop, software-in-the-loop (SiL), hardware-in-the-loop (HiL) applications, rapid prototyping, [25,26] and code generation [27]. The language elements facilitate the mapping between the logical system architecture where the functional and logical behavior of the control system are specified and the technical system architecture where the concrete implementation of the logic is defined. The intent is to allow the Modelica tool to automatically translate between the logical and the technical systems given mapping information formally defined in Modelica semantics. A key feature of the implementation allows the mapping to the technical system to be defined without modification of the logical system so that a single logical model can be configured for different embedded system use cases.

The new free Modelica_EmbeddedSystems library [27] provides access to the new language elements. The library provides interfaces and examples to define the partitioning of a distributed model into tasks and subtasks, the appropriate configuration between software and hardware elements, and the communication and I/O interfaces



Modelica as a Platform for Real-Time Simulation                     **571**

 

between various elements. The configuration definition includes specifications for the various tasks, subtasks, sampling rates, target processors, device drivers, integration methods, synchronization, initialization, and so on*.* These features allow a model of an embedded system to integrate both model-based and hardware elements in a state-of-the-art control system development environment. In conjunction with the Modelica_EmbeddedSystems library, the new Modelica_StateGraph2 library

[28] offers improved hierarchical state machines for simulation of hybrid systems and real-time applications.

A related development from the ITEA2 MODELISAR project is the development of the Functional Mockup Interface (FMI), a tool-independent standard for model exchange and cosimulation [29]. The FMI is a result of collaboration between vendors of Modelica and non-Modelica tools to facilitate model exchange between simulation tools. The goal of this effort is to gain acceptance as an open standard in the CAE community to improve model exchange between suppliers and original equipment manufacturers (OEMs). The FMI standard consists of FMI for Model Exchange and FMI for Co-Simulation. The FMI looks to be a very promising development for real-time applications, including planned support for AUTOSAR, the upcoming standard for embedded system software in vehicles.

 

 

**22.1.7**              **t****ool****-s****pecific** **f****eatures**

While the focus of this work is on the Modelica language, a Modelica compiler is required to generate executable code and is thus an integral part of the realtime platform. As such, there are a number of tool-specific features that have been developed to support real-time applications. These features, in conjunction with the Modelica language, are of paramount importance and merit the following overview.

The majority of the published results for real-time simulation of Modelica models were obtained using Dymola [11]. A good discussion of the various symbolic and numerical techniques employed in Dymola to solve DAEs and generate efficient code for real-time simulation is provided in the work by Elmqvist et al. [30]. Dymola has implemented a number of advanced symbolic/numeric techniques to support real-time simulation. A key challenge for multiphysics models is the disparate time scales in a model. Resolving the fastest time scales in stiff models with explicit fixed-step integration schemes requires small step sizes, which negatively impact computational efficiency. Implicit schemes allow larger time steps but require the solution of nonlinear systems of equations. Inline integration attempts to resolve this issue by combining the discretization formulas of the integration method with the model equations [31]. The resulting set of difference equations are then subject to symbolic manipulation in an attempt to generate efficient code for real-time simulation. Mixed-mode integration involves the use of implicit schemes for fast states and explicit schemes for slow states [32]. Event handling for fixed time steps is a challenge as iteration to find zero-crossings can cause computational overruns. Thus, Dymola has implemented several techniques for event handling such as predicting the occurrence of events and step size modification to detect events and



**572**                             Real-Time Simulation Technologies

 

synchronize with real time following event detection. These techniques can have a drastic impact on the ability to satisfy real-time constraints for complex physical systems in Modelica [33].

A common way of addressing real-time computational constraints is the development of model variants with varying complexity and potentially varying structure. Now consider the situation where a given simulation requires a more complex model during some phases of the simulation but a reduced order model can suffice otherwise. This modeling approach results in the potential for variable structure systems with structural changes at runtime, which are difficult to handle because of the semantics of the Modelica language. A derivative language of Modelica called Sol has been developed to provide a development platform for the investigation of technical solutions for variable structure systems [34]. Sol relaxes some of the semantics of the Modelica language regarding the creation and deletion of equations at runtime to more naturally handle variable structure systems. While not a commercial tool, this impressive, open research effort includes a formal definition of the language, a parser, and even a solution platform for numerical simulation. Published results demonstrate the application of the Sol framework to a rotational mechanical system driven by an engine model [34] and on a multibody trebuchet model [35]. The work is aimed at providing guidance and suggestions for potential improvements to the Modelica language. This effort is another example of the power of an open platform to support innovation.

[22.2 <--- ](22_2.md) [   Зміст   ](README.md) [--> 22.4](22_4.md)