[8.4 <--- ](8_4.md) [   Зміст   ](README.md) [--> 8.6](8_6.md)

## 8.5. RELATED WORK

This section groups existing work in the area of simulation of embedded applications into two categories, related to the main features of the Validator: the ability to synchronize with an external plant model for closed-loop simulation (co-simulation) and the special focus on legacy software and its execution time.

У цьому розділі наявна робота в області моделювання вбудованих додатків групується у дві категорії, пов’язані з основними функціями Validator: здатність синхронізуватися із зовнішньою моделлю заводу для моделювання замкнутого циклу (співмоделювання) і особлива увага до застаріле програмне забезпечення та час його виконання.

### 8.5.1 Co-Simulation

The main purpose of co-simulation is validating the functionality of hardware (HW) and software (SW) components by simulating two or more system parts that are described on different levels of abstraction. The challenge is the interface between the different abstraction levels. A simulation of the system should be possible through- out the entire design process where the model of the same component is refined iteratively [11]. Co-simulation as a basis for co-design and system verification can be performed in various manners where typically a trade-off between accuracy and performance must be made [12]. Various commercial and academic co-simulation frameworks have been proposed in literature; surveys can be found in Edwards et al. [12], Huebert [13], and Bosman [14].

Основною метою спільного моделювання є перевірка функціональності апаратних (HW) і програмних (ПЗ) компонентів шляхом моделювання двох або більше частин системи, які описані на різних рівнях абстракції. Проблема полягає в інтерфейсі між різними рівнями абстракції. Моделювання системи повинно бути можливим протягом усього процесу проектування, де модель того самого компонента уточнюється ітеративно [11]. Спільне моделювання як основа для спільного проектування та верифікації системи може бути виконано різними способами, де, як правило, потрібно зробити компроміс між точністю та продуктивністю [12]. У літературі були запропоновані різні комерційні та академічні рамки спільного моделювання; опитування можна знайти в Edwards et al. [12], Huebert [13] і Bosman [14].

In HW/SW co-simulation, the processor model is responsible for connecting hardware and software models. The processor can be modeled at gate level, which is the most accurate but also the slowest solution, with clock cycle accuracy or on an instruction-set level. Faster co-simulation tools do not model the processor but implement a synchronization handshake [15]. Some co-simulation environments also provide a virtual operating system to emulate or simulate the hardware [16].

У апаратно-програмному моделюванні модель процесора відповідає за підключення апаратних і програмних моделей. Процесор може бути змодельований на рівні воріт, що є найточнішим, але також і найповільнішим рішенням, з точністю тактового циклу або на рівні набору інструкцій. Швидші інструменти спільного моделювання не моделюють процесор, а реалізують квиткування синхронізації [15]. Деякі середовища спільного моделювання також надають віртуальну операційну систему для емуляції або імітації апаратного забезпечення [16].

Many approaches use ISS to obtain correct timing information. However, ISS are slow because of the fine granularity of the simulation. Performance issues are addressed for instance with caching [17] and distributed simulation by applying distributed event-driven simulation techniques.

Багато підходів використовують ISS для отримання правильної інформації про час. Однак ISS працюють повільно через дрібну деталізацію моделювання. Питання продуктивності вирішуються, наприклад, за допомогою кешування [17] та розподіленого моделювання шляхом застосування розподілених методів моделювання, керованих подіями.

The co-simulation framework used by the Validator does not provide a model of the central processor unit and does not employ an ISS because of performance reasons. We work with execution time at the source code level. Hardware components are modeled at a higher level of abstraction. The simulation tool was in an original prototype implemented based on Ptolemy. Another Ptolemy-based co-simulation approach can be found in Liu et al. [17].

Структура спільного моделювання, що використовується валідатором, не надає моделі центрального процесора та не використовує ISS з міркувань продуктивності. Ми працюємо з часом виконання на рівні вихідного коду. Апаратні компоненти моделюються на вищому рівні абстракції. Інструмент моделювання був оригінальним прототипом, реалізованим на основі Птолемея. Інший підхід спільного моделювання на основі Птолемея можна знайти у Liu et al. [17].

### 8.5.2 Modeling and Simulating Legacy Code

There are various approaches that generate models from legacy code, but only a few of them include the timing aspect in the modeling. Some software reverse engineering efforts take the software and find equivalent modeling constructs in a modeling language to reconstruct the same behavior as exhibited by the software. An example is provided in Sangiovanni-Vincentelli [18], where C programs are reverse- engineered to Simulink models. This, however, usually leads to complex models that are not understandable and thus do not aid in gaining new insights in the embedded software system.

Існують різні підходи, які генерують моделі із застарілого коду, але лише деякі з них включають у моделювання аспект часу. Деякі спроби зворотного проектування програмного забезпечення використовують програмне забезпечення та знаходять еквівалентні моделі моделювання на мові моделювання, щоб реконструювати ту саму поведінку, яку демонструє програмне забезпечення. Приклад наведено у Сангіованні-Вінсентеллі [18], де програми на С перепроектовані до моделей Simulink. Це, однак, зазвичай призводить до складних моделей, які є незрозумілими і, отже, не допомагають отримати нові знання про вбудовану програмну систему.

Code instrumentation and delaying of task execution to obtain a certain behavior is used by Wang et al. [19]. In this approach, the authors employ code instrumentation to generate deadlock-free code for multicore architectures. Timed Petri nets are generated from (legacy) code by instrumenting the code at points where locks to shared resources are accessed to model blocking behavior of software. A controller is synthesized from the code and used at runtime to ensure deadlock-free behavior of the software on multicore platforms by delaying task executions that would lead to deadlocks. The objective of the Validator is different: to replicate the real-time behavior of a given application (within certain accuracy limits). Thus, the Validator does not alter the functional behavior of the application.

Інструментування коду та затримка виконання завдання для отримання певної поведінки використовується Wang et al. [19]. У цьому підході автори використовують інструментарій коду для створення коду без взаємоблокувань для багатоядерних архітектур. Тимчасові мережі Петрі генеруються з (застарілого) коду шляхом інструментування коду в точках, де здійснюється доступ до блокувань спільних ресурсів, щоб моделювати поведінку блокування програмного забезпечення. Контролер синтезується з коду та використовується під час виконання, щоб забезпечити безблокувальну поведінку програмного забезпечення на багатоядерних платформах шляхом затримки виконання завдань, які можуть призвести до взаємоблокувань. Мета валідатора інша: відтворити поведінку даної програми в реальному часі (в певних межах точності). Таким чином, валідатор не змінює функціональну поведінку програми.

In Sifakis et al. [20], a formal framework is described for building timed models of real-time systems to verify functional and timing correctness. Software and environment models are considered to operate in different timing domains that are carefully related at input and output operations. A timed automaton of the software is created by annotating code with execution time information. The tool presented in that work restricts the control part of task implementations and the plant model to Esterel programs. The authors state that for tasks written in general purpose languages such as C, an analysis must reveal observable states and computation steps. The Validator provides such an analysis and can be used for application code written in C and environment models in Matlab and Simulink.

У Sifakis et al. [20] описується формальна структура для побудови часових моделей систем реального часу для перевірки функціональної та часової правильності. Вважається, що моделі програмного забезпечення та середовища працюють у різних часових областях, які ретельно пов’язані в операціях введення та виведення. Часовий автомат програмного забезпечення створюється шляхом анотування коду з інформацією про час виконання. Інструмент, представлений у цій роботі, обмежує контрольну частину реалізацій завдань і моделі заводу програмами Esterel. Автори стверджують, що для завдань, написаних мовами загального призначення, такими як C, аналіз повинен виявити спостережувані стани та кроки обчислень. Валідатор забезпечує такий аналіз і може використовуватися для програмного коду, написаного на C, і моделей середовища в Matlab і Simulink.

The benefits of modeling all aspects of an embedded system at a suitable level of abstraction are well known and have been addressed in the platform-based design approach. Tools such as Metropolis [21] offer a framework for platform-based design where functionality and platform concerns are specified independently. A mapping between functionality and a given platform must be provided. Representation of components and the mapping between functional and architectural networks is possible at different levels of refinement. The purpose of Metropolis is to support the top-down design process. All system components are modeled in an abstract specification language, which is parsed to an abstract syntax tree and provided to back-end tools for analysis and simulation. Although Metropolis allows the inclusion of legacy components, its main goal is not a bottom-up analysis of legacy systems but a topdown specification of the required behavior and a specification of the platform. In the approach presented here, the behavior of the components such as the data flow or temporal constraints is retrieved from simulation. As opposed to Metropolis, we do not require a specification of the functionality in a metamodel language, which is further translated into SystemC [22] for simulation. Our approach directly includes the software as simulation components. Simulation tools related to the Validator are TrueTime [5] from academia and the commercial tool ChronSim from INCHRON [23]. Compared to these tools, the Validator offers a series of advanced features, as described in the chapter.

Переваги моделювання всіх аспектів вбудованої системи на відповідному рівні абстракції добре відомі та розглянуті в підході проектування на основі платформи. Такі інструменти, як Metropolis [21], пропонують структуру для проектування на основі платформи, де функціональні можливості та проблеми платформи визначені незалежно. Необхідно надати відповідність між функціональними можливостями та певною платформою. Представлення компонентів і відображення між функціональними та архітектурними мережами можливі на різних рівнях уточнення. Метою Metropolis є підтримка процесу проектування зверху вниз. Усі компоненти системи моделюються мовою абстрактної специфікації, яка розбирається до абстрактного синтаксичного дерева та надається у внутрішні інструменти для аналізу та моделювання. Хоча Metropolis дозволяє включати застарілі компоненти, його основною метою є не висхідний аналіз застарілих систем, а специфікація необхідної поведінки та специфікації платформи зверху вниз. У представленому тут підході поведінка таких компонентів, як потік даних або часові обмеження, витягується з моделювання. На відміну від Metropolis, нам не потрібна специфікація функціональності мовою метамоделі, яка далі перекладається на SystemC [22] для моделювання. Наш підхід безпосередньо включає програмне забезпечення як компоненти моделювання. Інструментами моделювання, пов’язаними з валідатором, є TrueTime [5] від академії та комерційний інструмент ChronSim від INCHRON [23]. Порівняно з цими інструментами, Validator пропонує ряд розширених функцій, як описано в цьому розділі.

[8.4 <--- ](8_4.md) [   Зміст   ](README.md) [--> 8.6](8_6.md)