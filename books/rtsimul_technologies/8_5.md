[8.4 <--- ](8_4.md) [   Зміст   ](README.md) [--> 8.6](8_6.md)

## 8.5. RELATED WORK

This section groups existing work in the area of simulation of embedded applications into two categories, related to the main features of the Validator: the ability to synchronize with an external plant model for closed-loop simulation (co-simulation) and the special focus on legacy software and its execution time.

### 8.5.1 Co-Simulation

The main purpose of co-simulation is validating the functionality of hardware (HW) and software (SW) components by simulating two or more system parts that are described on different levels of abstraction. The challenge is the interface between the different abstraction levels. A simulation of the system should be possible through- out the entire design process where the model of the same component is refined iteratively [11]. Co-simulation as a basis for co-design and system verification can be performed in various manners where typically a trade-off between accuracy and performance must be made [12]. Various commercial and academic co-simulation frameworks have been proposed in literature; surveys can be found in Edwards et al. [12], Huebert [13], and Bosman [14].

In HW/SW co-simulation, the processor model is responsible for connecting hardware and software models. The processor can be modeled at gate level, which is the most accurate but also the slowest solution, with clock cycle accuracy or on an instruction-set level. Faster co-simulation tools do not model the processor but implement a synchronization handshake [15]. Some co-simulation environments also provide a virtual operating system to emulate or simulate the hardware [16].

Many approaches use ISS to obtain correct timing information. However, ISS are slow because of the fine granularity of the simulation. Performance issues are addressed for instance with caching [17] and distributed simulation by applying distributed event-driven simulation techniques.

The co-simulation framework used by the Validator does not provide a model of the central processor unit and does not employ an ISS because of performance reasons. We work with execution time at the source code level. Hardware components are modeled at a higher level of abstraction. The simulation tool was in an original prototype implemented based on Ptolemy. Another Ptolemy-based co-simulation approach can be found in Liu et al. [17].

### 8.5.2 Modeling and Simulating Legacy Code

There are various approaches that generate models from legacy code, but only a few of them include the timing aspect in the modeling. Some software reverse engineering efforts take the software and find equivalent modeling constructs in a modeling language to reconstruct the same behavior as exhibited by the software. An example is provided in Sangiovanni-Vincentelli [18], where C programs are reverse- engineered to Simulink models. This, however, usually leads to complex models that are not understandable and thus do not aid in gaining new insights in the embedded software system.

Code instrumentation and delaying of task execution to obtain a certain behavior is used by Wang et al. [19]. In this approach, the authors employ code instrumentation to generate deadlock-free code for multicore architectures. Timed Petri nets are generated from (legacy) code by instrumenting the code at points where locks to shared resources are accessed to model blocking behavior of software. A controller is synthesized from the code and used at runtime to ensure deadlock-free behavior of the software on multicore platforms by delaying task executions that would lead to deadlocks. The objective of the Validator is different: to replicate the real-time behavior of a given application (within certain accuracy limits). Thus, the Validator does not alter the functional behavior of the application.

In Sifakis et al. [20], a formal framework is described for building timed models of real-time systems to verify functional and timing correctness. Software and environment models are considered to operate in different timing domains that are carefully related at input and output operations. A timed automaton of the software is created by annotating code with execution time information. The tool presented in that work restricts the control part of task implementations and the plant model to Esterel programs. The authors state that for tasks written in general purpose languages such as C, an analysis must reveal observable states and computation steps. The Validator provides such an analysis and can be used for application code written in C and environment models in Matlab and Simulink.

The benefits of modeling all aspects of an embedded system at a suitable level of abstraction are well known and have been addressed in the platform-based design approach. Tools such as Metropolis [21] offer a framework for platform-based design where functionality and platform concerns are specified independently. A mapping between functionality and a given platform must be provided. Representation of components and the mapping between functional and architectural networks is possible at different levels of refinement. The purpose of Metropolis is to support the top-down design process. All system components are modeled in an abstract specification language, which is parsed to an abstract syntax tree and provided to back-end tools for analysis and simulation. Although Metropolis allows the inclusion of legacy components, its main goal is not a bottom-up analysis of legacy systems but a topdown specification of the required behavior and a specification of the platform. In the approach presented here, the behavior of the components such as the data flow or temporal constraints is retrieved from simulation. As opposed to Metropolis, we do not require a specification of the functionality in a metamodel language, which is further translated into SystemC [22] for simulation. Our approach directly includes the software as simulation components. Simulation tools related to the Validator are TrueTime [5] from academia and the commercial tool ChronSim from INCHRON [23]. Compared to these tools, the Validator offers a series of advanced features, as described in the chapter.

[8.4 <--- ](8_4.md) [   Зміст   ](README.md) [--> 8.6](8_6.md)