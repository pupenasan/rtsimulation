[16.1 <--- ](16_1.md) [   Зміст   ](README.md) [--> 16.3](16_3.md)

## 16.2. MODELING AND SIMULATING DISCRETE EVENT SYSTEMS

We begin with a DES modeled as an automaton (*X*, *E*, *f*, Γ, *x*0), where *X* is a count- able state space, *E* is a countable event set, *f*:*X* × *E*→*X* is a state transition function, Γ:*X*→2*E* is the active (or feasible) event function so that Γ(*x*) is the set of all events *e* ∈ *E* for which *f*(*x*, *e*) is defined, and it is called the active event set (or feasible event set), and finally, *x*0 is the initial state. The automaton is easily modified to (*X*, *E*, Γ, *x*0, *p*, *p*0) to include probabilistic state transition mechanisms: the state transition prob-

ability *p*(*x*′; *x*, *e*′) is defined for all *x*, *x*′ ∈ *X*, *e*′ ∈ *E* and is such that *p*(*x*′; *x*, *e*′) = 0 for all *e*′ ∉ Γ(*x*); in addition, *p*0(*x*) is the probability mass function (pmf) *P* [*x*0 = *x*], *x* ∈ *X*, of the initial state *x*0. For simplicity, we assume that the DES satisfies the “noninterruption condition,” that is, once an event is enabled, it cannot be disabled;

however, this is not essential to the rest of our discussion.

This model is referred to as an *untimed* automaton,3 since it provides no informa- tion as to which among all events feasible at some state *x* will occur next. To resolve this issue, we define a *clock structure* associated with an event set *E* (which we will

hencefoth assume finite with cardinality *N*) to be a set **V** = {**V**1, … , **V***N*} of *event life- time sequences* **V***i* = {*vi*,1, *vi*,2, …}, one for each event *i* ∈ *E*, with *vi*,*k* ∈ ℝ+. This leads to the definition of a *timed* automaton (*X*, *E*, *f*, Γ, *x*0, **V**), where **V** is a clock structure, and (*X*, *E*, *f*, Γ, *x*0) is an (untimed) automaton. The timed automaton generates a state sequence



*x* ¢ = *f* (*x*, *e*¢)





(16.1)



Concurrent Simulation for Online Optimization

 

driven by an event sequence {*e*1, *e*2, …} generated through

 

​        

​        { }*i*        



*e*¢ = arg min *y*



*i*ÎG(*x* )



**393**

 

 

 

(16.2)



 

with the *clock values yi*, *i* ∈ *E*, defined by

ì*y* - *y**    if  *i* ¹ *e*¢ and *i* ÎG( *x* )

*yi*¢ = ï *i*                                                  *i* ÎG (*x*¢)



í

 î *v*





 

*i*,*N*





 

 

*i* +1



if   *i* = *e*¢ or



*i* ÏG( *x* )



(16.3)



 



where the *interevent time y** is defined as

 

​     

​        { }*i*        



*y** = min *y*



*i*ÎG(*x* )

and the *event scores Ni*, *i* ∈ *E*, are defined by



 

 

(16.4)



ì*Ni*+1    if



*i* = *e*¢ or



*i* ÏG(*x* )





(16.5)



​     

​        *N*        



*Ni*¢ = **í**



î *i*





otherwise



*i* ÎG (*x*¢)



In addition, initial conditions are *yi* = *vi*,1 and *Ni* = 1 for all *i* ∈ Γ(*x*0). If *i* ∉ Γ(*x*0), then

*yi* is undefined and *Ni* = 0.

Note that this is precisely how a discrete event simulator generates state trajec- tories of DES using the event lifetime sequences **V***i* = {*vi*,1, *vi*,2, …} as input. The simulator maintains the *Clock*, the *State x*, and the *Event Calendar* where all feasible

events at state *x* along with their clock values are maintained. The entries of the Event Calendar are ordered so as to determine *y**** through Equation 16.4 and hence deter- mine the “triggering event” *e*′ in Equation 16.2. Once this is accomplished, the simu-

lator updates the State through Equation 16.1 and the Clock by setting its new value to

 

*t* ¢ = *t* + *y**                            (16.6)

Then, since *x*′ is available, Γ(*x*′) is determined, and all Clock values for *i* ∈ Γ(*x*′) are updated through Equation 16.3. This results in an updated Event Calendar and

the process repeats. It is important to note that this state trajectory construction is entirely *event driven* and *not time driven*. In other words, it is the Event Calendar that determines the next State of the system as well as the next value of the Clock. If the Event Calendar ever becomes empty, the process cannot continue, a situation that we often identify as a “deadlock” in the system. This event-driven mechanism is to be contrasted to a time-driven approach where the clock is updated through

*t*′ = *t* + ∆, where ∆ is a fixed time step. This is clearly inefficient, since often there is a large interval between the current event and the next event; during this interval, the

simulator needlessly updates the clock. What is worse, however, is that one or more events may in fact occur within an interval [*t*, *t* + ∆] in which case such a time-driven procedure fails to update the state until *t* + ∆. To counteract that, one might use a

smaller value of ∆, which in turn forces more needless clock updates.



**394**                                       Real-Time Simulation Technologies

 

The final step is to incorporate randomness into a timed automaton by allowing the elements of an event lifetime sequence to be random variables. Furthermore, in a more general setting, the state transition mechanisms can be assumed probabilistic. Thus, we define a *stochastic clock structure* associated with an event set *E* to be a set

of distribution functions *G* = {*Gi*: *i* ∈ *E*} characterizing the stochastic clock sequences. This leads to the definition of a STA (*E*, *X*, Γ, *p*, *p*0, *G*), where (*E*, *X*, Γ, *p*, *p*0) is an automaton with a probabilistic state transition mechanism and *G* is a stochastic clock

structure. The STA generates a stochastic state sequence {*X*0, *X*1, …} (i.e., a sample path) through a transition mechanism (based on observations *X* = *x*, *E*′ = *e*′):

*X* ¢ = *x*¢ with probability *p*(*x*¢; *x*, *e*¢)

 

and it is driven by a stochastic event sequence {*E*1, *E*2, …} generated through the same process as Equations 16.2 through 16.5 with *E* replacing *e*, *Yi* replacing *yi*, and *Vi*,*k* replacing *vi*,*k*. In addition,

 

{*V**i*,*k* } ~ *G**i*

where the tilde (∼) notation denotes “with distribution” and initial conditions are *X*0 ∼ *p*0(*x*), and *Yi* = *Vi*,1 and *Ni* = 1 if *i* ∈ Γ(*X*0). If *i* ∉ Γ(*X*0), *Yi* is undefined and *Ni* = 0. For simplicity, for the remainder of the chapter, we will assume a STA with deter- ministic state transition functions (*E*, *X*, *f*, Γ, *G*) where the source of randomness is

the stochastic nature of event lifetimes.

 

**Example**

 

To illustrate the definition of a STA, let us apply it to a simple single-server queueing system with a sequence of arriving tasks waiting in a First-In-First-Out (FIFO) queue with infinite capacity. This is normally written as “*G*/*G*/1,” where the first two *G*s denote the probability distribution characterizing the arrival process and the service process, respectively: the letter *G* stands for “General” to indicate that neither distribu- tion is assumed known. The number 1 indicates that there is a single server processing

arriving task requests. In this case, we set *X* = {0, 1, …} to be the state space, so that *x* ∈ *X* is the number of tasks in the system (including one in process), and *E* = {*a*, *d*} to denote an arrival and a departure event, respectively. Clearly, Γ(*x*) = {*a*, *d*} for all *x* ∈ *X* except for Γ(0) = {*a*}, since a departure from an empty system is infeasible. Since all state transitions are deterministic, we revert to the usual state transition mechanism *x*′ = *f*(*x*, *e*′), and we have *x*′ = *x* + 1 if *e*′ = *a* and *x*′ = *x* − 1 if *e*′ = *d* and *x* > 0.

A *G*/*G*/1/*K* queueing system is one where the queueing capacity is limited to *K* tasks. In this case, the model above is modified so that X = {0, 1, … , *K*} and *x'* = *x* + 1 if *e'* = *a*, *x* < *K*, while *x'* = *x* if *e'* = *a*, *x* = *K*. If, in addition, there is some information

regarding the distribution functions of the arrival and service processes, then these are specified through stochastic clock structure *G* = {*Ga*, *Gd*}. For example, if the arrival process is Poisson with rate λ, we have *Ga*(*t*) = 1 *− e*−λt, *t* ≥ 0 with *Ga*(*t*) = 0 for *t* < 0,

and if the service process is uniformly distributed over [0, 1], we have *Gd*(*t*) = *t* for *t* ∈

[0, 1], *Gd*(*t*) = 0 for *t* < 0, and *Gd*(*t*) = 1 for *t* > 1. In this case, the queueing system is represented by the notation *M*/*U*/1/*K*.

[16.1 <--- ](16_1.md) [   Зміст   ](README.md) [--> 16.3](16_3.md)