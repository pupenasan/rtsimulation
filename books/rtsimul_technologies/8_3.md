[8.2 <--- ](8_2.md) [   Зміст   ](README.md) [--> 8.4](8_4.md)

## 8.3. SETUP OF A SIMULATION WITH THE VALIDATOR

The current version of the Validator basically supports the co-simulation of a plant represented as a variable-step model in MATLAB and Simulink with the control- ler software written in C. As an advanced feature for reengineering existing con- troller tasks or adding controller tasks, these tasks can be modeled in MATLAB and Simulink and the Validator then simulates the behavior of both the existing unchanged tasks and the modified or new controller tasks. The only constraint is that the modified or new controller tasks are modeled with discrete time semantics in MATLAB and Simulink. Let us now focus on the typical use case, that is, the co- simulation of a plant represented as variable-step model in MATLAB and Simulink with the controller software written in C.

 

**8.1.1**            **T****aRgeT** **P****laTFoRm** **s****PeciFicaTion**

For an accurate simulation of the controller tasks on a virtual platform, the Validator must have configuration information about the target platform, which is provided by setting properties of the corresponding model components. To specify this informa- tion, we use Ptolemy’s front end, as the original research prototype of the Validator was implemented harnessing Ptolemy’s discrete event simulation. The screenshot in Figure 8.8 exemplifies the specification of the behavior of an interrupt service routine (ISR).

​                                                    

**FIGURE 8.8** Specification of interrupt service routine behavior with the Ptolemy front end.



Validator Tool Suite                                         **207**

 

An ISR is represented as a so-called actor in Ptolemy. The actor-oriented programming model is in essence a dataflow-based programming model in which data flows from actor to actor. When activated, each actor performs its specific data processing. An actor-oriented environment such as Ptolemy must account for the execution order of actors. The Validator library, which is used to specify the target platform, comprises various kinds of actors:

 

•   Hardware actors model functionality and timing of common hardware parts such as interrupt controllers, timers, bus controllers, hardware sensors, and hardware actuators.

•   Operating system actors, which implement the functionality of the operating system on the target platform, including scheduling, resource management, and communication between tasks. Currently, the Validator provides actors for the OSEK operating system.

 

Note that actors are best understood as plug-ins to the discrete event simulation of the Validator, providing the various platform details.

 

**8.1.2**            **T****ask** **s****ouRce** **c****ode** **a****nnoTaTion**

In addition to specifying the target platform, the source code of the controller tasks must be instrumented with callbacks to the simulation in the Validator. Details on which aspects require a callback is available in other work [7]. All the spots in the source code are instrumented with callbacks. An example of a type of spot is access to global variables. Between each pair of spots, the execution time must be determined. This is another crucial aspect of target platform information that the Validator must have to achieve its accuracy. From the Validator user point of view, it is only relevant that both the instrumentation and execution time estimation can be automated. Overall, a preparation of the controller tasks for a simulation with the Validator involves the following steps:

 

\1.  Execution time analysis of the application code. This is performed with existing program analysis tools such as AbsInt’s Advanced Analyzer (a3) tool [8]. To increase the accuracy of the estimates, generally details about the architecture of the execution platform must be made available to such tools.

\2.  Instrumentation of the code with execution time information.

\3.  Instrumentation with callbacks to pass control to the Validator simulation engine for the execution of the tasks.

\4.  Generation of what we call the Validator interface code between the Validator simulation engine and the tasks.

 

In the Validator, these steps are mostly automated by a tool set that achieves a straightforward preparation process. Nevertheless, this automation requires infor- mation about the hardware/software architecture, such as the list of lines of code where global variables are accessed.

[8.2 <--- ](8_2.md) [   Зміст   ](README.md) [--> 8.4](8_4.md)