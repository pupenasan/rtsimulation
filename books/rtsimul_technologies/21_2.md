[21.1 <--- ](21_1.md) [   Зміст   ](README.md) [--> 21.3](21_3.md)

**21.1**     **INTRODUCTION** **TO** **AUTOSAR**

AUTOSAR was created to develop an open industry standard with a common software infrastructure based on standardized interfaces for SWC specification and integration at different layers. In agreement with the move toward an integrated architecture, the AUTOSAR goal is to enable the definition of SWCs that can execute independently from their placement in a complex, distributed platform.

The AUTOSAR architecture has three major domains. In the first, at the level of the *Virtual Functional Bus* (VFB), the system is described as a collection of application SWCs, cooperating over ports in a purely functional architecture (top part of Figure 21.1, which outlines the tool-assisted match between the AUTOSAR functional model and the execution platform). The VFB consists of the set of logical connections linking the interfaces of the cooperating SWCs. AUTOSAR separates communication from computation and synchronization. The component interface is defined as a collection of ports, and the execution of the procedures of a component is represented by a set of *runnables*, activated in response to events and defined in a *behavior level*.

At runtime, the set of SWCs is executed on a standard software abstraction layer. This layer is automatically generated according to the specification of the (possibly distributed) execution platform supporting the computations and according to the specifications of the VFB layer and the behaviors of the components. The software

 

 

 

 

 

 

 

 

 

​                                                                

​          SW                SW                SW     component 1      component 2      component 3          

​          ECU     descriptions          

​          Virtual Function Bus (VFB)          

​          Deployment     tools          

​          ECU 1          

​          ECU 2          

​          component     1     RTE     Basic     software          

​          SW          

​          component 2     component 3 RTE     Basic software          

​          SW             SW          



System constraint description



 

 

 

 

 

 

 

 

 

**FIGURE 21.1** The AUTOSAR functional model and a deployment onto a distributed architecture.



Specification and Simulation of Automotive Functionality               **527**

​                  

​            Application layer AUTOSAR      Run-time environment      Services layer (includes OS)            

​            ECU abstraction layer            

​            Complex device drivers            

​            Microcontroller abstraction layer             Hardware            







**FIGURE 21.2** The AUTOSAR standard software platform.

 

layer between the platform and the realization of the SWCs using the standard API is called RTE (run-time environment). The RTE is the runtime implementation of the VFB and has the responsibility of implementing the virtual communication occurring over the component ports redirecting it to a concrete communication protocol. The concrete implementation differs according to the task mapping and the ECU allocation of the communicating runnables. In addition, the RTE generates events resulting from the component interactions and is responsible for the generation of periodic events.

The RTE, in turn, runs on a standardized architecture of additional abstraction layers, device drivers, and operating system functions, which is collectively referred to as *BSW* (an outline of the standard SW platform is in Figure 21.2).

The third element of the specification is the AUTOSAR process itself, or better the definition of a basic workflow that connects the main development stages, with the expected results and the definition of the tools to be used in each stage.

 

**21.1.1**             **VFB** **L****eVeL**

The first level for the definition of an AUTOSAR system is the Functional Model, where SWCs encapsulating sets of system-level functions are connected and cooperate over a VFB ([Figure 21.1](#_bookmark126)). Later, they are bound to an execution platform consisting of ECUs connected by communication buses. AUTOSAR components may be defined hierarchically. At the bottom of the hierarchy, components are “atomic,” meaning that each instance is assigned to one ECU (cannot be distributed).

In AUTOSAR, a component defines its required and provided interface through ports, which are the only means to interact with other components. Ports may provide or require access to data or services. A port defining a provided point of access is defined as a P-Port, and a required port is called R-Port. An Interface, attached to each port, may be of type client/server, defining the signatures of the operations that are invoked or provided, or of type sender/receiver, defining a model of the data structures



**528**                                       Real-Time Simulation Technologies

​                  

​            DCAM            

​            Validity            

​            ACAM      Cam_validity wdog_ack            

​            Watchdog      acam_life            

​            Edge_angle            

​            Cam_edge_angle            

​            SyncMgmt      RPM_signal            

​            Calib_table            

​            Service      acam_KT            

​            Sync_RPM            

​            RPM_phase                      Sys_Phase       Setting            

​            Data port            

​            Parameter port            

​            Service      port (P-Port)            

​            Service      port (R-Port)            

​            Data port (nonvolatile)            

​            Mode port            







**FIGURE 21.3** AUTOSAR components and ports.

 

that are written or read. The formal description of the interface is in the *software component template*, an XML file, which includes the formal specification of the data types and the description of the communication behavior, as specified by attributes.

Those attributes define (among others) the length of the queues for the data ports and the behavior of receivers (blocking, nonblocking, etc.) and senders (send cyclic, etc.). Figure 21.3 shows an example of AUTOSAR components interacting over sender/receiver ports and client/server ports.

The port syntax identifies several types of data ports: regular data type, parameter ports, and nonvolatile ports. Furthermore, the language syntax identifies special ports for the definition of mode switches and also provides for a distinction between application ports and ports that connect application components to AUTOSAR services.

 

**21.1.2**              **B****ehaVioraL** **L****eVeL**

In AUTOSAR, the behavior of atomic SWCs is represented by a set of *runnable entities* (*runnables* for short) that are in essence entry points of procedures or, as stated in the standardization documents, atomic schedulable units (sequential segments of code, to be executed under the control of a scheduler), communicating with each other over the component *ports*. AUTOSAR provides several mechanisms for runnables to access the data items in the ports for *sender/receiver* communication and the services of *client/server* communication ports. In particular, access to ports of type Send/Receive can be *implicit* or *explicit*. In the case of an explicit access, it is the job of the developer to insert calls to the standard RTE API functions for reading from and writing into ports inside the runnables. If a port is accessed in an implicit way by a runnable, then the port contents are copied from the port automatically by the RTE before starting the runnable code (for receive ports) or written at the end of the runnable execution (for sender ports). The activation model, the communication among runnables, and the synchronization in the execution of runnables (local and remote) is specified in a middle-level RTE layer.



Specification and Simulation of Automotive Functionality               **529**

 

**21.1.3**              **rTe L****eVeL**

The run-time environment (RTE) is the runtime implementation of the VFB. The RTE is local to each ECU. It is a complex layer that must provide location independence in the request of services and data communication among components. The RTE also takes care of the management and forwarding of events to runnables (for triggering their execution or releasing them from wait points). In practice, in the case of local communication, service requests are simply remapped to local function calls. In the case of remote services, the RTE forwards the call to a stub that performs marshalling of parameters in a message, selects the appropriate communication network and the corresponding device driver, transmits the message, and waits for the reply message. When the reply message arrives, the RTE extracts the returned value and closes the remote service request by returning to the caller and generating (if requested) the appropriate event.

The available RTE events are the following:

 

•   *Timing Event* triggering periodical execution of runnables.

•   *DataReceivedEvent* upon reception of a sender/receiver communication.

•   *OperationInvokedEvent* for the invocation of client/server service.

•   *DataSendCompleteEvent* upon sending a sender/receiver communication.

 

Each runnable must be associated with at least one RTE event, defining its activation. The scope of each RTE event is limited to the component. For example, two periodic events with the same period activating runnables on different components are not guaranteed to be synchronous. Actually, their relative phase is unspecified unless explicitly modeled by using synchronization components (typically at the BSW level). In case a runnable is activated by more than one event, it must be reentrant or the developer must take care of protecting its internal state variables. A *WaitPoint* can be used to block a runnable while waiting for an event. Runnables that may block during their execution are called type 2, as opposed to the others, defined as type 1 (this definition impacts the selection of the operating system scheduler and of the scheduling policies). For instance, for an operation defined as part of a component interface, the behavior specifies which runnable is activated as a consequence of the operation invocation event.

The only possible definition of an AUTOSAR MoC emerges from the composition of the behavior options that are attached to each interface and runnable specifications, with no guarantee of consistency. The concept of time and time-related events, which is necessary for the formal definition of an MoC, has only appeared in release 4.0 of the standard. The time model is briefly addressed and discussed in Section 21.2.5.

Finally, there is the description of components/runnables at the implementation level. The language for the description of the internal behavior of runnables is not part of AUTOSAR. AUTOSAR does not require a model-based development flow: a component may be handwritten or generated from a model. For the definition of the models of the runnables, it relies on external tools such as Simulink and ASCET, which brings the issue of the composition of heterogeneous models. The lowest (most



**530**                                       Real-Time Simulation Technologies

 

concrete) level of description specifies a reference to the code files implementing the runnables of the components and the resource consumption of SWCs. This resource requirements model includes the worst-case execution time of runnables, for which a special section is reserved in the implementation description of the runnables.

AUTOSAR defines the methodology and tool support to build a concrete system of ECUs. This includes the configuration and generation of the runtime environment (RTE) and the BSW (including the real-time operating system) on each ECU. The generation of the RTE and BSW layer is the responsibility of the *deployment tools*, which define the mapping of the function to the architecture and the generation of code based on the model of the execution platform, defined (in XML format) by the ECU *description files*.

Finally, the definition and realization of components is not limited to the application level. Designers can define runnables and components at the level of the BSW as well, with less restrictive rules. These runnables and components are included in the code automatically generated by the deployment tools and can be directly activated by events generated at the operating system level (interrupt handlers, counters, and alarms in AUTOSAR).

 

**21.1.4**             **aUToSar P****roceSS**

AUTOSAR requires a common technical approach for selected steps in the development process, from the system-level configuration to the generation of the executables for each ECU. The AUTOSAR Methodology (a graphical representation is in Figure 21.4) is the description of these activities, with their inputs and outputs. The AUTOSAR Methodology is formally not a true process description since it does not prescribe the order in which the activities should be performed, neither the actors involved.

The first step is the creation of the *System Configuration Input*, which defines the SWCs, the hardware execution platform, and the system constraints that apply to the

​                  

​            System             System      Con gure          System Con guration     System       Con guration      Input                      Description            

​            Extract ECU-Speci c Information      ECU             ECU-Related               ECU      Extract of Con gure ECU Con guration Generate         ECU      Templates              System      Templates ECU       Description     Executables Executable                    Component            

​            Component-Related Implement      Implemented Templates      Component       Component            







**FIGURE 21.4** The AUTOSAR process.



Specification and Simulation of Automotive Functionality               **531**

 

mapping of the components onto the ECUs. The format for the formal description is defined in a standard XML schema and includes the following templates.

 

•   *Software Components*: Each SWC is described in terms of its ports and interfaces, including the data types and the port attributes.

•   *ECU Resources*: Each ECU requires specifications regarding the processor unit(s), the available memory, and the available peripheral devices, including sensors and actuators.

•   *System Constraints*: Regarding the mapping of the signals into bus messages as well as the mapping of the component runnables into tasks and the allocation of tasks into the ECUs.

 

The System Configuration Input includes or references various constraints. These constraints are very simple and mostly consist of forced or forbidden mapping configurations. In reality, the template allows for the definition of estimates on the availability of resources on ECUs, thereby providing less intuitive constraints to mapping configurations.

The *Configure System* activity has the responsibility to map all the SWCs to ECUs and also to define the system communication matrix. This matrix describes the message frames exchanged over the system networks, that is, the mapping of the signal information (the data exchanged over ports) into the frames. Deriving such a mapping is extremely complex and consists of a system optimization problem, in which system metrics of interest, including performance and possibly reliability, extensibility, and composability should be maximized considering constraints on resources and timing requirements [4,5]. In the mind of the AUTOSAR developers, this synthesis and optimization process should be assisted by a set of tools, defined as *System Configuration*. The output of this activity is the *System Configuration Description* including system information (e.g., bus mapping and topology) and the mapping of SWCs to ECUs.

Further steps must be performed for each ECU in the system. The activity denoted as *Extract ECU-Specific Information* extracts the information from the System Configuration Description for a specific ECU, thereby generating the *ECU Extract of System Configuration*. This step is rather simple since it consists of a projection of the elements of the System Configuration Description that are allocated to a specific ECU. At the ECU level, the system configuration stage is mirrored by the *Configure ECU* activity, where the RTE and the BSW modules are configured for each ECU. This includes the definition of the task model (the assignment of runnables to tasks) and the configuration of the scheduler and of the BSW components (driver included). The result of the activity is included in the *ECU Configuration Description*. The configuration is based on the information extracted from the *ECU Extract of System Configuration*, the definition of the *Available SWC Implementations*, and the *BSW Module Description*. The latter contains the vendor-specific information for the

ECU configuration.

This activity defines the detailed scheduling information, the configuration of the communication module, the operating system, and other AUTOSAR services. Moreover, this is the time when an implementation must be provided for



**532**                                       Real-Time Simulation Technologies

 

each atomic SWC. In contrast to the extraction of ECU-specific information, the configuration activity is actually a complex design synthesis and optimization step.

In *Build Executable* (last step), an executable is generated based on the configuration of the ECU. This step typically involves generating code (e.g., for the RTE and the BSW), compiling code (compiling generated code or compiling SWCs available as source code), and linking everything together into an executable.

Parallel to these steps are several steps performed for every application SWC (to be integrated later into the system), including the generation of the component’s API and the implementation of the component’s functionality.

The initial work in this context starts with providing the necessary parts of the SWC description. That means at least the *Component Internal Behavior Description* as part of the SWC-related templates has to be filled in. The internal behavior describes the scheduling-relevant aspects of a component, that is, the runnable entities and the events they respond to. Furthermore, the behavior specifies how a component (or more precisely which runnable) responds to events like receiving data elements. However, it does not describe the detailed functional behavior of the component, which is only filled in later, when the *Component Implementation* (typically the C sources) is provided, together with additional implementation-specific information and information about the further build process steps (e.g., compiler settings, optimizations, etc.).

 

**21.1.5**              **aUToSar T****iming** **m****odeL**

Starting from version 4.0, AUTOSAR includes a *Specification of Timing Extensions* [6]: a language overlaid on top of the existing AUTOSAR concepts with the primary purpose of enabling the definition of timing contracts and the (worst-case) schedulability analysis of the timing behavior of a system. Unfortunately, the keywords “simulation,” “model of computation,” or “model-to-model transformation” never appear among the list of the requirements for the timing model, which is indeed lacking with respect to the needs of a formal semantics for simulation and verification.

With respect to the AUTOSAR process, the timing specification extends the AUTOSAR metamodel, without necessitating a separate template. Also, the extension is introduced without the indication of any additional process steps. Hence, the description of the previous subsection remains fundamentally unchanged.

In the specification of timing extensions for AUTOSAR, the event is the basic entity. It is used to refer to an observable behavior within a system (e.g., the activation of a *RunnableEntity* and the transmission of a frame) at a point in time. The AUTOSAR timed event is formally derived from a generic abstract concept defined as *TimedDescriptionEvent*. Unfortunately, timed events are not specializations of RTE events, but define a partly independent structure of timing annotations and constraints. As a consequence, it becomes problematic to maintain and enforce the consistency between the RTE events defining the behavior semantics (i.e., the activation and the synchronization among runnables) and the timed events providing time attributes and constraints that apply to the behaviors. The description of the timing elements follows the organization of the AUTOSAR-level views ([Figure 21.5](#_bookmark127)).



Specification and Simulation of Automotive Functionality               **533**

​                  

​            TimingDescriptionEvent            

​            TDEventVfb      + isExternal: Boolean            

​            TDEventCom            

​            TDEventBsw            

​            TDEventBswInternalBehavior      + tdEventBswlnternalBehaviorType: tdEventBswInternalBehaviorTypeEnum             TDEventSwcInternalBehavior      +      tdEventSwcInternalBehaviorType: tdEventSwcInternalBehavior TypeEnum            







**FIGURE 21.5** Types of events by modeling level.

​                  

​            TDEventVfb      + isExternal: Boolean            

​            TDEventVariableDataPrototype      + tdEventVariableDataPrototypeType: tdEventVariableDataPrototypeTypeEnum             TDEventOperation      +      tdEventOperationType: tdEventOperationTypeEnum            

​            <<enumeration>> tdEventOperationTypeEnum      OperationCalled OperationCallReceived OperationCallResponseSent OperationCallResponseReceived            

​            TDEventModeDeclaration      +      tdEventModeDeclarationType: tdEventModeDeclarationTypeEnum            

​            <<enumeration>>      tdEventV               TypeEnum            

​            ariableDataPrototype            

​            <<enumeration>> tdEventModeDeclarationTypeEnum      ModeDeclarationSwitchInitiated ModeDeclarationSwitchCompleted            

​            VariableDataPrototypeSent VariableDataPrototypeReceived      +variableDataPrototype 1                     +operationPrototype 1        +modeDeclarationGroup      Prototype 1            

​            *AtpInstanceRef*      InstanceRefs: VariableDataPrototypeInComponentInstanceRef            

​            *AtpInstanceRef*      InstanceRefs: OperationInComponentInstanceRef            

​            *AtpInstanceRef*            

​            InstanceRefs: ModeDeclarationGroupPrototypeInComponentInstanceRef            







**FIGURE 21.6** Timed events defined for the virtual functional bus level.

 

Timing events and constraints can be applied to a *VFB-level view*. Functional end-to-end timing constraints (including possibly the physical sensors and actuators) can be captured in this view. Of course, the VFB view is independent of the platform design and of the allocation of the execution resources. Therefore, the analysis does not include any timing issues from resource scheduling, nor the description of platform overheads. Also, the internal behavior of components is not considered. In conclusion, the constraints that can be defined and analyzed are execution intervals, as opposed to deadlines, defined between events on component ports. As shown in Figure 21.6, the timed events allowed at this level mirror the corresponding RTE events on ports (such as, for example, the time at which data is sent or received, an



**534**                                       Real-Time Simulation Technologies

 

operation called, or an operation call received). When adding the *internal behavior description*, timed events can refer to the activation, start, and termination (see Figure 21.7) of the execution of RunnableEntities. This specification still mostly applies to the definition, and possibly verification, of end-to-end deadline constraints. After the BSW and ECU generation stage, more information is available on the resources of the execution platform, and the allocation of runnables to tasks and of tasks to ECUs. Also, the model now includes the specification of schedulers and the composition of the message frames. Therefore, the events that are defined at these levels also apply to tasks and message frames. This is the level where schedulability analysis can be performed and also the level where timed events could be leveraged

to simulate the impact of platform-dependent delays.

In general, at all levels, the occurrence of a timing event can be described by an *Event Triggering Constraint*. AUTOSAR offers four basic types of event triggering constraints as described in [Figure 21.8](#_bookmark128): *periodic events*, *sporadic events*, which are characterized by a minimum interarrival time, and *bursty events*, in which the specification defines periodic bursts occurring with a given period, and the composition of each burst in terms of number of events and minimum interarrival time. Finally, streams determined by the *position in time of each event and fully arbitrary patterns* complete the available categories.

In addition, the extension defines constraints and properties that apply to pairs or sets of events (their relations). One notable example of a relation among events is the event chain, with which the concept of end-to-end timing constraint is associated ([Figure 21.9](#_bookmark128)). For the purposes of simulation, an important requirement is the possibility of defining causality dependencies, that is, to enforce a partial order of execution among the system actions and the possibility of enforcing synchronization among the actions. Before the timing extensions, expressing a causal dependency and synchronizing the events triggering the execution of runnables was extremely difficult if even possible at all (an example of this difficulty is provided in the following section

dealing with model-to-model transformations).

Unfortunately, the new timing extensions only provide a partial solution. Causality constraints can indeed be expressed by an *Execution Order Constraint*, which is used to express the functional dependency between ExecutableEntities (runnables) and to restrict their order of execution at runtime. The AUTOSAR

 

​                  

​            TimingDescriptionEvent            

​            TDEventSwcInternalBehavior      + tdEventSwcInternalBehaviorType: tdEventSwcInternalBehaviorTypeEnum            

​            +component            

​            *AtpInstanceRef*            

​            0..1 InstanceRefs::ComponentInCompositionInstanceRef            

​            1 +runnable      *ExecutableEntity*      SwcInternalBehavior::RunnableEntity      + canBelnvokedConcurrently:Boolean      + symbol:CIdentifier            

​            runnableEntityActivated runnableEntityStarted runnableEntityTerminated            

​            <<enumeration>> tdEventSwcInternalBehaviorTypeEnum            







 

**FIGURE 21.7** Timed events that apply to the behavior description.



Specification and Simulation of Automotive Functionality                **535**

​                  

​            TimingConstraint            

​            EventTriggeringConstraint            

​            PeriodicEventTriggering            

​            BurstPatternEventTriggering      + maxNumberOfOccurrences:Integer            

​            ArbitraryEventTriggering            

​            SporadicEventTriggering            

​            ConcretePatternEventTriggering            







**FIGURE 21.8** Metamodel of timing events in AUTOSAR 4.0.

​                  

​            TimingDescription            

​            +Stimulus            

​            TimingDescriptionEventChain            

​            TimingDescriptionEvent            

​            {stimulusl=response}            

​            Constraints            

​            1      1            

​            {for each segment there exists one path from stimulus to response}      +Segment 1..*            

​            +Response            







**FIGURE 21.9** Metamodel of timing event chains in AUTOSAR 4.0.

 

*Synchronization Timing Constraint*, however, is not intended to be used to define a consistent time base for timed events and, in turn, for the system behavior. The definition of a set of system-wide synchronized timed events could have allowed the AUTOSAR modeling of discrete-time systems and the translation of synchronous models in AUTOSAR. However, the original purpose of the specification is different and synchronization constraints do not apply to sets of individual events but to event chains, with the possibility of synchronizing the initial stimulus or the final response times. The motivation for the current definition of timed events is to reduce the pessimism in the worst-case analysis of end-to-end response times. Indeed, the synchronization constraint is intended to be defined together with a tolerance, indicating a true specification constraint on the runtime behavior of complex chains of reactions rather than (for example) a method for enforcing a discrete-time framework.



**536**                                       Real-Time Simulation Technologies

 

Another set of constraints can be used for the purpose of synchronization: the offset constraints. These constraints are somewhat more suited to the synchronization of events since they explicitly target individual events rather than chains. However, an offset always refers to a single pair of events (a source and a target), which once again makes its use cumbersome for a system-wide synchronization of reactions.

In conclusion, it is worth noting that version 4.0 of the standard is very recent and still not supported by commercial tools. The hope is that future evolve and become more suited to the goals of simulation and allow for better integration (meaning on formal grounds) of heterogeneous models.

 

**21.1.6**             **aUToSar** **T****ooLS** **and** **The** **r****oLe oF** **T****ooLS**

From the description of the AUTOSAR process, it is very clear how the use of tools is recommended or even mandatory in several activities, such as the code generation and configuration stages. Indeed, there are currently several AUTOSAR tools available on the market. In addition, the AUTOSAR consortium members realized that there is a common or core module that is required by all tool providers. This core module includes the functions for the management of the metamodel and the enforcement of its rules in the construction of a model, the representation of the model in memory, the generation and parsing of the input and output files at each stage of the AUTOSAR process in the standard ARXML format, and basic capabilities for model editing.

The consortium members launched a common initiative to create an open project (Artop, an open source project, although open for contribution and use by the consortium members only [7]) that leverages the metamodeling and modeling features of the Eclipse platform [8] to develop a common foundation that could be exploited by all AUTOSAR tools developers, vendors, and users. The code of the Artop project is available to the members of the consortium that can contribute to its development and use it in the form they see fit, either directly (in the case of OEMs and Tier 1 suppliers) or, more likely, as a common starting point for the development of commercial tools in the case of tool vendors. Artop does not have simulation and analysis capabilities and does not include code generators or the mapping synthesis capability for matching a functional model to an execution platform. These components are intended to be developed as custom extensions by tool vendors.

Currently, tool vendors tend to specialize in the different process activities that are requested by the standard. Several companies offer tools for the design of AUTOSAR models. Examples of products in this area are SystemDesk by dSPACE [9], DaVinci by Vector [10], and AUTOSAR Builder by Geensoft [11]. These tools include RTE generators, but not the configuration of the BSW. Also, they offer (somewhat limited) simulation capabilities (mostly at the VFB and behavior level as discussed in more detail in the following section).

Other companies provide products, such as Tresos from Elektrobit [12], specialized in the stages of BSW generation and configuration, including the operating system.

In general, the mapping of the functional model into the execution platform is quite far from being a synthesis process supported by an optimization engine. Currently, tools typically provide a default configuration of the task model and require a complete user specification with respect to the mapping of the tasks onto the ECUs.



Specification and Simulation of Automotive Functionality               **537**

 

Limited support for AUTOSAR is also offered by other modeling tools, including, for example, Simulink. The support does not include full model-to-model transformation capabilities (not surprisingly, given the sematics distance between the two models), but focuses on these areas:

 

•   Integration of code generated from a Simulink model with the RTE generated by AUTOSAR tools

•   Generation of a component or runnable specification by wrapping a (virtual) Simulink subsystem to allow its inclusion in an AUTOSAR model

•   Importing an AUTOSAR component specification into Simulink by automatically generating an equivalent subsystem interface model

[21.1 <--- ](21_1.md) [   Зміст   ](README.md) [--> 21.3](21_3.md)