[8 <--- ](8.md) [   Зміст   ](README.md) [--> 8.2](8_2.md)

## 8.1. SOLID SYSTEM VERIFICATION AND VALIDATION NEEDS IMPROVED SIMULATION SUPPORT

An embedded system operates in a physical environment with which it interacts through sensors and actuators. An important class of real-time embedded systems is represented by control systems. In this case, the embedded software consists of a set of (controller) tasks and the physical system under control is referred to as the plant. [Figure 8.1 ](#_bookmark46)sketches the typical architecture of an embedded control system.

Simulation is an approach for testing embedded systems before they are deployed in real-world operation. In simulation, the plant is represented by a software model executed on a host computer, typically a personal computer. In a hardware-in-the- loop (HIL) simulation, the entire embedded system (embedded software consisting of the controller tasks executing on the target platform) is operated in closed loop with the plant model, which is executed in real time on a dedicated computer [1]. Since the embedded software is executed in real time on the target platform, HIL simulations can be used to verify the real-time properties of the embedded system. Thus, any difference between the behavior of the embedded system in a HIL simula- tion and the corresponding behavior in the real world is due to the abstractions made in plant modeling.

In a software-in-the-loop (SIL) simulation, the embedded software consisting of the controller tasks is executed on a host computer other than the target plat- form, in closed loop with the plant model. Both simulations (of the controller and the plant model) are typically executed on the same host computer. The SIL model of an embedded system contains the embedded software and an abstraction of the target platform. This abstraction determines how close the software execution in the SIL simulation is to the HIL simulation, provided that the same plant model is used. It ranges from a minimal representation of the target platform that enables only testing of functional (transformational or processing) properties of the software, to full-fledged hardware simulators (called instruction set simulators, ISS), which lead to system behavior close to a HIL simulation, while offering better observability of software executions. Pure functional simulations are fast, but do not allow the testing of timing properties of the embedded system. ISS can be used for timing analysis [2], but they are extremely slow and expensive. [Figure 8.2](#_bookmark46)* summarizes the characteristics of conventional SIL, ISS-based SIL, and HIL simulations.

[Figure 8.3](#_bookmark47) summarizes the features and the advantages and disadvantages of state-of-the-art SIL and HIL simulations in comparison with a Validator simulation. Note that the Validator replaces the ISS-based simulation.

[Figure 8.4 ](#_bookmark47)refines the comparison between the Validator and SIL/HIL approaches. The Validator unifies characteristics of both a SIL and a HIL simulation. The Validator has the flavor of a SIL simulation as it does not require a target platform for executing the embedded software. On the other hand, the Validator separates the simulation of plant and controller tasks as in a HIL simulation.

​     

\* Parts of the picture are taken from [http://www.mathworks.com/products/xpctarget/ ](http://www.mathworks.com/products/xpctarget/)and are courtesy of MathWorks.



Validator Tool Suite                                         **201**



 

 

 

 

 

 

 

​                                                                

​          Plant     (e.g.,     combustion     engine)          



Set of sensors







 

 

 

 

 

 

Set of tasks





 

 

 

 

 

 

Set of actuators



**FIGURE 8.1** Typical architecture of an embedded system.

 

​                  

​            Conventional SIL simulation            

​            SIL simulation      Instruction set simulator (ISS)            

​            HIL simulation            

​            • Test functionality            

​            • Test timing behavior and functionality            

​            • Test real-time behavior and functionality            

​            + Cheap      + Fast      – Imprecise            

​            + Precise      – Tedious and extremely slow      – Expensive            

​            + Precise      – Tedious      – Expensive            







Validator simulation replaces and signi cantly improves ISS-based simulation

**FIGURE 8.2** Conventional software-in-the-loop, instruction set simulators-based software- in-the-loop, and hardware-in-the-loop simulations.

 

**8.1.1**           **R****eal****-T****ime** **B****ehavioR in The** **v****alidaToR**

An important aspect is the simulation of real-time behavior. A simple example that illustrates in which respect the Validator is better than typical SIL simulation tools is shown in [Figure 8.5](#_bookmark48). Consider three concurrent tasks, called DynamicsController (DC), MotorController (MC), and ParkingController (PC), that communicate through a shared (global) variable called *angle*. The code of the tasks is sketched in Figure 8.5a. The tasks DC and MC are periodic with periods equal to 5 and 1 ms, respectively. The task PC is event-triggered. Assume that they are deployed on a real-time operating system with fixed priority preemptive scheduling, where the pri- orities of the periodic tasks are assigned by a rate monotonic policy. Thus, the MC



**202**                                       Real-Time Simulation Technologies

 



 

 

Conventional SIL simulation





SIL simulation                                       HIL simulation

 

   Validator simulation



 

 

 

 



• Test functionality

 

 

\+ Cheap

\+ Fast

– Imprecise



• Test timing behavior and functionality

• Advanced debugging

± Reasonable costs

\+ Fast

\+ Precise



• Test real-time behavior and functionality

 

\+ Precise

–  Tedious

–  Expensive



 

**FIGURE 8.3** Validator: advanced software-in-the-loop simulation in between conventional software-in-the-loop and hardware-in-the-loop simulations.

 

 



 

 

Conventional SIL simulation



SIL simulation                                        HIL simulation

 

   Validator simulation



 

 

 

 



 

 

Protocol,



Plant                                    Plant

Cable + protocol



 

 

Plant and controller simulation in one tool (e.g., MATLAB and Simulink)



e.g., via TCP/IP

Separate simulations, but typically on same PC:

Plant simulation: e.g., MATLAB and Simulink

 

Controller simulation: Validator





Separate simulations:

 

Plant on PC (e.g., MATLAB and Simulink)

 

Controller on target platform



 

**FIGURE 8.4** Structure of a simulation with the Validator.

 

task has a higher priority than the DC task. Moreover, consider that the PC task has highest priority.

A snapshot of real-time behavior of the application is depicted in Figure 8.5b, which indicates the sequence of accesses to the variable *angle* by the three tasks. Note that task DC is triggered first, at 5 ms, and then it is preempted by MC at 6 ms, before writing



Validator Tool Suite                                         **203**

​                  

​            (a) Legacy code deployed on RTOS      Task with period      5 ms      void      DynamicsController ( )      { ...            

​            ...            

​            write (angle) ;            

​            Task with      period 3 ms              Event-triggered task      void MotorController (      )  void ParkingController ( )      { ...          { ...            

​            ...            

​            read (angle) ;            

​            ...            

​            read (angle) ;            

​            (b) Real-time behavior            

​            (c) Pure functional SIL simulation            

​            (d)      Task-level timed simulation            

​            PC MC      DC            

​            PC MC      DC            

​            PC MC      DC            

​            5       6      7 time(ms)            5       6       7 time(ms)           5       6      7 time(ms)      read    write read                   write read    read                   read    read write            







**FIGURE 8.5** Examples of mismatch between simulated and real-time behaviors.

 

into the variable *angle*. Thus, MC reads from *angle* first. Thereafter, DC resumes and writes the angle, then it is preempted by PC, which reads the variable. Figure 8.5c shows the behavior of the application in a pure functional simulation, where each func- tion is completely executed at the triggering time. In other words, the code is executed in logically zero time. Such a simulation can be obtained in Simulink® [3], for example, by importing the C code as so-called S-function(s) in Simulink. Figure 8.5d presents a timed-functional simulation, where each task has a specified execution time and shar- ing of processor time among tasks in the system is also simulated. A timed-functional model includes a scheduling component to decide when a triggered task obtains access to the processor. When the task is started, its code is still executed in zero time, thus using the inputs available at that moment; however, the outputs of the task are made available after the specified execution time has elapsed. Examples of SIL simulation environments that offer task-level timed simulation are the Timed Multitasking Ptolemy domain [4] and TrueTime [5]. Notice that the order in which the three tasks access the variable *angle* is different in the two simulations compared to the real-time case.

On the other hand, a simulation with the Validator would reflect the same order of accesses as in the real-time behavior shown in Figure 8.5b. This requires a detailed execution time analysis and a corresponding instrumentation of the embedded software by the Validator support tools as described in Section 8.3.2.

[8 <--- ](8.md) [   Зміст   ](README.md) [--> 8.2](8_2.md)