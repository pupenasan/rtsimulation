[4 <--- ](4.md) [   Зміст   ](README.md) [--> 4.2](4_2.md)

## 4.1. INTRODUCTION

Real-time simulation is characterized by the strong constraints that must be respected regarding the time spent simulating an activity. Usually we can run simulation faster than real time, and we synchronize with virtual time with techniques that are now mastered by many engineers [1]. Sometimes, the simulation can execute at a higher rate than the actual system evolves; in this case, all that is necessary is delaying the simulation so that virtual time stays synchronized to the expected wall clock real time. However, when the simulation involves heavy computation or the simulated activities are very short-lived, meeting the deadlines may imply optimizing certain parts of the simulation to reduce its execution time. A simulation run that is slower than real time can occur when dealing with detailed physical models. For instance, we experienced this when simulating the details of particles for physical studies in nuclear medicine [2,3]. In these works, we faced modeling cases where it was impossible to meet the real-time constraints. Medical scanning experiments that last 20–30 minutes can be simulated in a few seconds with analytical models. However, the results obtained can be very imprecise for small tumors (up to 100% error for tumors lesser than 1 cm in diameter). To be more precise, we must build 3D spatial stochastic models, which run for more than 9 hours on our current computer, and many replicates are necessary to reduce the error (less than 10% error achieved in 3 days of computing using the European Computing Grid) [4].

Симуляція в реальному часі характеризується сильними обмеженнями, яких необхідно дотримуватися щодо часу, витраченого на симуляцію діяльності. Зазвичай ми можемо запускати симуляцію швидше, ніж у реальному часі, і ми синхронізуємо віртуальний час за допомогою методів, які зараз освоюють багато інженерів [1]. Іноді симуляція може виконуватися з вищою швидкістю, ніж фактична система розвивається; у цьому випадку все, що необхідно, це затримка моделювання, щоб віртуальний час залишався синхронізованим із очікуваним настінним годинником реального часу. Однак, коли симуляція передбачає важкі обчислення або змодельована діяльність дуже короткочасна, дотримання термінів може означати оптимізацію певних частин симуляції, щоб скоротити час її виконання. При роботі з детальними фізичними моделями може відбуватися симуляція, яка виконується повільніше, ніж у реальному часі. Наприклад, ми відчули це під час моделювання деталей частинок для фізичних досліджень у ядерній медицині [2,3]. У цих роботах ми зіткнулися з випадками моделювання, коли неможливо було виконати обмеження реального часу. Медичні скануючі експерименти, які тривають 20–30 хвилин, можна змоделювати за кілька секунд за допомогою аналітичних моделей. Однак отримані результати можуть бути дуже неточними для невеликих пухлин (до 100% похибки для пухлин менше 1 см у діаметрі). Якщо бути більш точним, ми повинні побудувати тривимірні просторові стохастичні моделі, які працюють більше 9 годин на нашому поточному комп’ютері, і для зменшення помилки необхідно багато копій (менше 10% помилки досягнуто за 3 дні обчислень за допомогою European Computing Сітка) [4].

Even in simpler cases, achieving real-time simulation can be complicated. We have met such a case when dealing with fire spreading simulations following detailed physical experiments where physicists wanted to meet strong requirements in terms of both performance and precision. When a fixed spatial precision is set for the predictions obtained with fire spreading modeling, efficient models and highperformance computations are required [5]. The efficiency of discrete event simulators is now receiving significant attention [6–9].

Навіть у простіших випадках досягнення моделювання в реальному часі може бути складним. Ми зіткнулися з таким випадком, коли мали справу з моделюванням розповсюдження вогню після детальних фізичних експериментів, де фізики хотіли відповідати суворим вимогам як щодо продуктивності, так і точності. Коли встановлено фіксовану просторову точність для прогнозів, отриманих за допомогою моделювання поширення пожежі, потрібні ефективні моделі та високопродуктивні обчислення [5]. Зараз приділяється значна увага ефективності симуляторів дискретних подій [6–9].

In this chapter, we present a set of software engineering techniques for improving performance through code generation and metaprogramming for greater runtime efficiency. The gain obtained through such techniques enables reconsidering some simulation applications where it would be a distinct benefit to have precise humanin-the-loop simulations that are currently too slow to be considered for real-time applications. There are a number of optimization techniques that can be applied; in Section 4.2, we focus on what can be achieved with code generation and metaprogramming. After the introduction of several metaprogramming techniques, we propose a comparison to show the different benefits they provide regarding performance and design. Section 4.3 applies C++ Template Metaprogramming (TMP) to the Discrete Event System Specification (DEVS) in the simulation domain. We then close with some conclusions in Section 4.4.

У цьому розділі ми представляємо набір методів розробки програмного забезпечення для підвищення продуктивності за допомогою генерації коду та метапрограмування для підвищення ефективності виконання. Виграш, отриманий за допомогою таких методів, дозволяє переглянути деякі додатки моделювання, де було б явною перевагою мати точне моделювання людського циклу, яке наразі є надто повільним, щоб розглядатися для додатків у реальному часі. Існує ряд методів оптимізації, які можна застосувати; у розділі 4.2 ми зосереджуємося на тому, чого можна досягти за допомогою генерації коду та метапрограмування. Після представлення кількох методів метапрограмування ми пропонуємо порівняння, щоб показати різні переваги, які вони надають щодо продуктивності та дизайну. Розділ 4.3 застосовує шаблонне метапрограмування C++ (TMP) до Специфікації системи дискретних подій (DEVS) у домені моделювання. Потім ми завершуємо деякими висновками в розділі 4.4.

 

[4 <--- ](4.md) [   Зміст   ](README.md) [--> 4.2](4_2.md)