[13.3 <--- ](13_3.md) [   Зміст   ](README.md) [--> 13.5](13_5.md)

## 13.4. INTERACTIVE FLIGHT CONTROL SYSTEM DEVELOPMENT TEST BED

One of the key requirements for an integrated development process is the “plug-and-play” capability, which enables decoupled component (subsystem) design and integrated testing based on the same model. Therefore, design decisions are gradually finalized through iterations between component-level and system-level developments. For com- plex control systems development, strategies have been proposed or developed includ- ing the computer-automated multiparadigm modeling, actor-oriented control system design approach, cosimulation, code integration, model encapsulation, and model trans- lation ([8] and the references therein). Generally speaking, not only are these efforts time-consuming, but they are also still facing technical difficulties to reach seamless integration. Furthermore, the auto-generated code is often not sufficiently optimized to be used in a production environment. As the complexity of the system is increasing rapidly, these challenges become more and more evident. In this section, we introduce an interactive design and simulation platform for flight vehicle systems development. The proposed platform adopts the cosimulation concept and avoids code generation challenges faced by other integration approaches. It enables the component design “plug-and-play” in a systems simulation environment, thereby bringing the “systems simulation” into the “control design” for integrated development. Moreover, the seam- less interactive design and simulation is achieved by an adaptive “connect-and-play” capability. The following presentation is based on the work by Liu and Berndt [8].

A popular approach in FCS development follows the concept of *code encapsulation* in principle. The controller is designed and validated in isolation by desktop off-line simulation. The controller algorithm codes are generated (in C code as one example).



Interactive Flight Control System Development                      **335**

Then, encapsulated as a monolithic submodel, it is integrated into the model of an enclosing system for systems validation and verification. The challenges of the code- generation-based integration approaches include the level of automation, compatibil- ity, and synchronization of the models and simulations. Since design codes are used as the media, one must ensure that the generated codes can work on heterogeneous simulation platforms, with proper interfaces. If so, it is expected that the code genera- tion can be processed automatically, to avoid tedious manual labor and errors. These challenges are still open research topics. In this section, instead, we adopt a different integration strategy that is similar to cosimulation in principle. As shown in Figure 13.1a, this proposed interactive platform allows the component model to be simulated (plug-and-play) in a different, system-level environment. Moreover, the platform is adaptable such that the systems simulator can “connect” to the design model directly. We believe that this “connect-and-play” capability is one significant improvement over the “plug-and-play” capability. Since there is only one physical design model that takes residence at the component level, one can work with this model to make modifica- tions and perform testing “online” without the intermediate code-generation process. Obviously, the “connect-and-play” property and the adaptability make the design and simulation platform truly interactive and integrated in development. Under the pro- posed platform (Figure 13.1b), the integrated FCS results in a multiparadigm control framework. It represents a standard FCS block diagram with some special features.

The blocks with a drop-down shadow represent “swapping” features. The guidance and command block represents the flight path generation (guidance) or command inputs (for controller design). The actuation and sensor blocks can be replaced by



​                                                                

​          Model     Design          

​          Model     Simulation          



Component level (control design)





System level (systems simulation)



(a)

​                  

​            Guidance command            

​            Flight control            

​            Actuators            

​            Vehicle dynamics            

​            Sensors            

​            HIL            

​            Flight simulation            







(b)

**FIGURE 13.1** (a) An illustration of cosimulation concept; (b) Interactive flight control system design and simulation platform.



**336**                             Real-Time Simulation Technologies

 

software modules with different levels of fidelity or even hardware equipment. The vehicle dynamics module can also be replaced by different software modules for different simulation purposes. A simplified linearized dynamics model is used for control system design, while full-scale nonlinear flight equations will be used for high- fidelity simulations such as flight simulations. To emulate the reality that different flight systems components are physically installed in different locations and their interactions are communicated through mechanical links or electrical bus, the proposed framework allows for a distributed modeling structure. Each block can be individually modeled, as one software module in different processors. Therefore, it is possible to distribute differ- ent parts of a computing task across individual processors operating at the same time, or “in parallel,” and thus reduce the overall time to complete the task. Furthermore, the distributed modeling structure makes it feasible to “swap” different modules of the same block, including the HITL simulation. Because of the distributed modeling and “swapping” feature, it is possible to replace block modules developed under differ- ent platforms, and even to run simulations on machines from different manufacturers. Therefore, the proposed framework supports heterogeneous simulations.

To demonstrate the proposed FCS framework and the interactive design and simulation platform, an experimental test bed is set up. A real-time systems simulator and a flight training device (RTSS-FTD) are equipped to provide a suitable proof-of- concept facility, as shown in Figure 13.2.

The RTSS facility is a networked cluster of high-end COTS computers. Its core computing features include three host computers, each having dual-Pentium processors running Windows 2000 OS; four real-time computers, each having dual-Pentium pro- cessors running the QNX real-time operating system; and real-time nodes that are directly connected by 400 Mbit/s FireWire and communicate with hosts over a dedi- cated 100-Mbit/s Ethernet network. Furthermore, the system consists of a 108 multiple channel input/output (I/O) system for HITL simulation. The RTSS is also connected through a 1.25 Gb/s Giganet to a similar facility to share data and sources, and it is connected to a 56-alpha-processor high-power computer for off-line computing and

​     

**FIGURE 13.2** Integrated flight control system development test bed.



Interactive Flight Control System Development                      **337**

 

simulation, as well as data storage. This configuration provides the following key capabilities to support our proposed framework.

A separate FTD is set up for flight simulation. It simulates the operation of a generic jet aircraft within the tolerances and conditions set out by the Transport Canada Authority. The major aircraft subsystems include the automatic controls; the auxiliary power unit (APU); doors; the engine indication and crew alerting system (EICAS); the electrical systems; the environmental control systems; flight controls and flight instruments; the fuel, pneumatic, and hydraulic systems; the landing gear; the lighting; and the navigation and communications systems. The design of the FTD is such that all the simulated functionality is concentrated in the software model run- ning on the host computer. This software model contains all the mathematical and logic modeling to make the FTD behave like the Generic Jet aircraft. All the other computers and hardware are I/O interfaces between the pilot/copilot and the model software running on the host computer. The control loading is handled by a PC on the network. It communicates with the host on the Ethernet switch. This computer has digital wiring running to the primary flight controls in the cockpit. The computer systems are networked through a 100 Mbaud Ethernet switch. All the simulated air- craft panels are intelligent; they each contain an embedded CPU that manages their local I/O and communicates with the host computer through a CAN bus network. The aircraft flight and subsystem models are developed using the C programming language. The visual database is developed using the MultiGen paradigm ([www.](http://www.presagis.com/) [presagis.com](http://www.presagis.com/)). The control system is developed under the MATLAB® (version 7.6) and Simulink® (version 7.1) platform. Both MATLAB and Simulink are software packages provided by MathWorks Inc. ([www.mathworks.com](http://www.mathworks.com/)). A fully functional FTD also includes an instructor operation station (IOS).

In summary, the RTSS is able to simulate the aircraft systems and flight maneu- vers. The features of reconfigurability, modeling, and customization of cockpit displays are critical to our systems integration research. The FTD presents a more complete and realistic aircraft model, which includes factors not taken into account in the RTSS development. It offers a different perspective as the flight mission may be observed from a cockpit with out-the-window visual and instrument displays. The RTSS and FTD facilities are connected through Ethernet cables to form a networked RTSS-FTD test bed for integrated modeling and simulation activities.

To use the FTD as a test bed for interactive controller design and simulation, a net- work connection is established for “connect-and-play.” As introduced before, the con- trol development environment uses the MATLAB and Simulink platform that offers an application programming interface called “S-function” that can be used to integrate blocks with user-defined behavior into a Simulink block diagram. The idea is to let an S-function for MATLAB and Simulink work as a network I/O layer, which outputs the current state vector of the FTD and takes control commands as inputs, as it is com- monly done with HITL approaches ([Figure 13.3](#_bookmark79)). Note that the control input can carry additional payload, if necessary. In particular, the S-function allows for three values of wind components, which, if given, will be used to overwrite the built-in wind model. It was then decided that a transmission control protocol and Internet protocol (TCP/IP) connection offers the robustness needed for controller operation. The packet format used for the network connection is simple, yet extensible. A fixed-length



**338**                             Real-Time Simulation Technologies

​        

​          Controller, implemented in     MATLAB and Simulink, running on any computer inside the ight control system (FCS) network. Uses information about the current state to calculate appropriate control     commands.          







 

​                        Controls

​        

​          MATLAB and Simulink S-function representing the FTD          







 

​        

​          (IOS two network cards): (1) IOS acts as a gateway for the model computer router for; (2) IOS acts as a the FCS network, forwarding selected incoming     packets to the model computer.          







 

​           State

​        

​          Model computer: Built-in autopilot     commands are overwritten with received control commands.          







**FIGURE 13.3** Network communication.

 

integer specifying the total packet length is followed by an arbitrary number of tri- ples specifying an identifier, a value, and a delimiter. The S-function is written in the programming language C and can be further customized at compile time using pre- processor macros. This way, among other preferences, maximum allowable packet length and floating point data formats can be adjusted.

[13.3 <--- ](13_3.md) [   Зміст   ](README.md) [--> 13.5](13_5.md)