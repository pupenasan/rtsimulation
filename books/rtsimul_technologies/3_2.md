[3.1 <--- ](3_1.md) [   Зміст   ](README.md) [--> 3.3](3_3.md)

## 3.2. BACKGROUND

DEVS was originally defined in the 1970s as a mechanism for specifying discrete event models specification [3]. It is based on dynamic systems theory, and it allows one to define hierarchical modular models. A system modeled with DEVS is described as a composite of submodels, each of them being behavioral (atomic) or structural (coupled). Each model is defined by a time base, inputs, states, outputs, and functions to compute the next states and outputs. A DEVS atomic model is formally described by

DEVS спочатку був визначений у 1970-х роках як механізм для специфікації специфікації моделей дискретних подій [3]. Він базується на теорії динамічних систем і дозволяє визначати ієрархічні модульні моделі. Система, змодельована за допомогою DEVS, описується як сукупність підмоделей, кожна з яких є поведінковою (атомарною) або структурною (з’єднаною). Кожна модель визначається часовою базою, входами, станами, виходами та функціями для обчислення наступних станів і виходів. Атомна модель DEVS формально описана

![image-20220819232121931](media/image-20220819232121931.png) 

A DEVS atomic model is the most basic DEVS component. The behavior of a DEVS model is defined by transition functions in atomic components. An atomic model M can be affected by external input events *X* and can generate output events *Y*. The state set *S* represents the state variables of the model. The internal transition function δint and the external transition function δext compute the next state of the model. When an external event arrives at elapsed time *e* (which is less than or equal to ta(*s*) specified by the time advance function), a new state *s*′ is computed by the external transition function. Otherwise, if ta(*s*) finishes without input interruption, the new state *s*′ is computed by the internal transition function. In this case, an output specified by the output function λ can be produced based on the state *s*. After a state transition, a new ta(*s*′) is computed, and the elapsed time *e* is set to zero. A DEVS coupled model is composed of several atomic or coupled submodels. The property of closure under coupling allows atomic and coupled models to be integrated to form a model hierarchy. Coupled models are formally defined as follows:

Атомна модель DEVS є основним компонентом DEVS. Поведінка моделі DEVS визначається функціями переходу в атомарних компонентах. На атомарну модель M можуть впливати зовнішні вхідні події *X* і вона може генерувати вихідні події *Y*. Набір станів *S* представляє змінні стану моделі. Внутрішня функція переходу δint і зовнішня функція переходу δext обчислюють наступний стан моделі. Коли зовнішня подія настає за час, що минув *e* (який менший або дорівнює ta(*s*), визначеному функцією випередження часу), зовнішня функція переходу обчислює новий стан *s*′. В іншому випадку, якщо ta(*s*) завершується без переривання введення, новий стан *s*′ обчислюється внутрішньою функцією переходу. У цьому випадку вихід, визначений функцією виведення λ, може бути отриманий на основі стану *s*. Після переходу стану обчислюється новий ta(*s*′), а час, що минув *e*, встановлюється на нуль. Зв’язана модель DEVS складається з кількох атомарних або пов’язаних підмоделей. Властивість замикання під зв’язком дозволяє інтегрувати атомарні та пов’язані моделі для формування ієрархії моделей. Поєднані моделі формально визначаються таким чином:

![image-20220819232149389](media/image-20220819232149389.png) 

where 

*X* is the set of input ports and values.

*Y* is the set of output ports and values.

*D* is the set of the component names (an index of submodels).

EIC is the set of External Input Couplings, which connects the input events of the coupled model itself to one or more of the input events of its components.

EOC is the set of External Output Couplings, which connects the output events of the components to the output events of the coupled model itself.

IC is the set of Internal Couplings, which connects the output events of the components to the input events of other components.

Select: 2*D* → *D* is a tie-breaking function, which defines how to select an event from a set of simultaneous events.



*X* — набір вхідних портів і значень.

*Y* — набір вихідних портів і значень.

*D* — набір імен компонентів (індекс підмоделей).

EIC — це набір зовнішніх вхідних зв’язків, який з’єднує вхідні події самої пов’язаної моделі з одним або кількома вхідними подіями її компонентів.

EOC — це набір зовнішніх вихідних зв’язків, який з’єднує вихідні події компонентів із вихідними подіями самої зв’язаної моделі.

IC — це набір внутрішніх з’єднань, який з’єднує вихідні події компонентів із вхідними подіями інших компонентів.

Виберіть: 2*D* → *D* — це функція визначення зв’язку, яка визначає, як вибрати подію з набору одночасних подій.



CD++ [10] allows defining models following these specifications. The tool is built as a hierarchy of models, and each of the models is related to a simulation entity. CD++ includes a graphical specification language, based on DEVS Graphs [11], to enhance interaction with stakeholders during system specification while having the advantage of allowing the modeler to think about the problem in a more abstract way. DEVS graphs can be formally defined as [12]

CD++ [10] дозволяє визначити моделі відповідно до цих специфікацій. Інструмент побудований як ієрархія моделей, і кожна з моделей пов’язана з об’єктом моделювання. CD++ містить графічну мову специфікації, засновану на DEVS Graphs [11], щоб покращити взаємодію із зацікавленими сторонами під час специфікації системи, маючи при цьому перевагу, дозволяючи модельєру думати про проблему більш абстрактно. Графи DEVS можна формально визначити як [12]

 ![image-20220819232223371](media/image-20220819232223371.png)

CD++ uses this formal notation to define atomic models, as seen in [Figure 3.1](#_bookmark8). A unique identifier defines each model, which can be completely specified using a graphical specification based on the formal definition above. That is, states are represented by bubbles including an identifier and a state lifetime, state variables can be associated with the transitions, and there are two types of transitions: external and internal.

CD++ використовує цю формальну нотацію для визначення атомарних моделей, як показано на Рис. 3.1. Унікальний ідентифікатор визначає кожну модель, яку можна повністю вказати за допомогою графічної специфікації на основі формального визначення вище. Тобто стани представлені бульбашками, включаючи ідентифікатор і час життя стану, змінні стану можуть бути пов’язані з переходами, і існує два типи переходів: зовнішні та внутрішні.

![image-20220819232245230](media/image-20220819232245230.png)

**FIGURE 3.1** An atomic model defined as a DEVS graph.

The DEVS graph in Figure 3.1 shows a simple component for a packet routing model. As we can see, there are three states in this DEVS atomic model: *waiting*, *discardPacket*, and *sendPacket.* The model uses two input/output ports (corresponding to the *XM* and *YM* sets in the formal specification): *packageIn* and *packetOut*. Three variables are defined for this model and initialized: *msg*, *failRate*, and *r*. Internal transitions are shown with dashed arrow lines. The internal transition *sendPacket* → *waiting* uses the output function, which is defined to send the value of the variable *msg* to output port *packetOut.* The external transitions are shown with solid arrow lines, with a condition that would enable that transition only if it is evaluated to true, and an expression to update some of the model variables (when needed). For instance, the transition from *waiting* to *sendPacket* is activated when a packet is received on *packageIn* (*Any(Value(packageIn, 1))*) and the *failRate* is greater than a random value *r* (*Greater(r, failRate)*). In that case, the model changes to state *send- Packet* and also assigns the value of the packet to the *msg* intermediate variable. It also computes a new random value.

Графік DEVS на малюнку 3.1 показує простий компонент для моделі маршрутизації пакетів. Як ми бачимо, у цій атомарній моделі DEVS є три стани: *очікування*, *discardPacket* і *sendPacket.* Модель використовує два порти введення/виведення (відповідає наборам *XM* і *YM* у формальна специфікація): *packageIn* і *packetOut*. Для цієї моделі визначено та ініціалізовано три змінні: *msg*, *failRate* і *r*. Внутрішні переходи показані пунктирними лініями-стрілками. Внутрішній перехід *sendPacket* → *waiting* використовує функцію виводу, яка визначена для надсилання значення змінної *msg* на вихідний порт *packetOut.* Зовнішні переходи показані суцільними лініями зі стрілками з умовою, що буде увімкнути цей перехід, лише якщо він оцінюється як істинний, і вираз для оновлення деяких змінних моделі (за потреби). Наприклад, перехід від *waiting* до *sendPacket* активується, коли пакет отримано на *packageIn* (*Any(Value(packageIn, 1))*) і *failRate* перевищує випадкове значення *r * (*Greater(r, failRate)*). У цьому випадку модель змінює стан на *send-Packet*, а також призначає значення пакета проміжній змінній *msg*. Він також обчислює нове випадкове значення.

Each DEVS graph is translated into an analytical definition that the runtime engines use to execute. The internal transitions employ the following syntax:

Кожен графік DEVS перетворюється на аналітичне визначення, яке використовують для виконання механізми виконання. Внутрішні переходи використовують такий синтаксис:

```c
int: source destination [outport!value]* ( { (action;)* } )
```

Here, *source* and *destination* represent the initial and final states associated with the execution of the transition function. As the output function should also execute before the internal transition, an *output* value can be associated with the internal transition. One or more *actions* can be triggered during the execution of the transition (changing the values of state variables). External transitions are defined as follows:

Тут *джерело* і *призначення* представляють початковий і кінцевий стани, пов’язані з виконанням функції переходу. Оскільки функція виводу також має виконуватися перед внутрішнім переходом, значення *виводу* можна пов’язати з внутрішнім переходом. Під час виконання переходу (зміна значень змінних стану) можуть бути викликані одна або кілька *дій*. Зовнішні переходи визначаються наступним чином:

```
ext : source destination ( { (action;)* } )? expression
```

In this case, when the expression is true (which includes inputs arriving from input ports), the model will change from state *source* to state *destination*, while also executing one or more actions. These notations are generated as a direct translation from the graph represented in Figure 3.1.

У цьому випадку, коли вираз є істинним (що включає вхідні дані, що надходять із вхідних портів), модель змінить стан *джерело* на стан *призначення*, одночасно виконуючи одну або більше дій. Ці позначення генеруються як прямий переклад із графа, представленого на рисунку 3.1.

### 3.2.1 Труднощі формальної перевірки DEVS

DEVS formal definitions for atomic models are the most generic DEVS [3]. The first difficulty in DEVS formal verification, is that model-checking techniques are only decidable for finite state systems. In case of infinite-state systems, irrelevant details must be abstracted to obtain a finite state system before applying model-checking techniques. Another difficulty is the nondeterminism in DEVS behavior. This can be caused by stochastic behavior in a DEVS model due to the use of a probabilistic function in the definition of the external transition function δext or time advance function δint [13]. Another major difficulty in applying automatic formal verification techniques such as model checking to DEVS models is that the DEVS time advance function can take values of irrational real numbers. These values cannot be represented in a finite reachability graph that is used in model-checking algorithms, and thus, the algorithm will not be able to terminate, hence rendering the verification problem undecidable.

Формальні визначення DEVS для атомарних моделей є найбільш загальними DEVS [3]. Перша складність формальної верифікації DEVS полягає в тому, що методи перевірки моделі доступні лише для систем із кінцевим станом. У випадку систем із нескінченним станом перед застосуванням методів перевірки моделі потрібно абстрагувати нерелевантні деталі, щоб отримати систему з кінцевим станом. Іншою складністю є недетермінізм поведінки DEVS. Це може бути викликано стохастичною поведінкою в моделі DEVS через використання імовірнісної функції у визначенні зовнішньої функції переходу δext або функції випередження часу δint [13]. Ще одна серйозна складність у застосуванні методів автоматичної формальної перевірки, таких як перевірка моделі, до моделей DEVS полягає в тому, що функція випередження часу DEVS може приймати значення ірраціональних дійсних чисел. Ці значення не можуть бути представлені в графі кінцевої досяжності, який використовується в алгоритмах перевірки моделі, і, отже, алгоритм не зможе завершити роботу, отже, роблячи проблему перевірки нерозв’язною.

Several techniques have been introduced to overcome these problems and provide reasonable approximation to DEVS while enabling formal verification. As will be discussed in the following paragraphs, the techniques range from formal model checking of restricted classes of DEVS, the generation of test traces from DEVS models for simulation testing, the specification of high-level system requirements in TA and verifying DEVS model against those requirements, and introducing clock constructs to DEVS to conform with TA.

Було введено кілька методів, щоб подолати ці проблеми та забезпечити розумне наближення до DEVS, уможливлюючи при цьому формальну перевірку. Як буде обговорюватися в наступних параграфах, методи варіюються від перевірки формальної моделі обмежених класів DEVS, генерації тестових трас із моделей DEVS для симуляційного тестування, специфікації системних вимог високого рівня в TA та перевірки моделі DEVS на ті вимоги та введення конструкцій годинника в DEVS для відповідності TA.

One approach, called *real-time DEVS* (RT-DEVS) introduces a time advance function that maps each state to a range with maximum and minimum time values and introduces an activity associated with every system state [14]. This work also introduced an RT-DEVS *executive* that executes these models in RT. RT-DEVS was also used to design RT controllers as shown in Ref. [15] for a train-gate system. Further work on verifying RT-DEVS was introduced in Refs. [16,17], where the authors relied on TA as used by UPPAAL and defined (although not formally proved) a transformation method from RT-DEVS to UPPAAL. This transformation allows weak synchronization between components of the TA model as RT-DEVS semantics uses weak synchronization.

Один підхід, який називається *DEVS* у реальному часі (RT-DEVS), вводить функцію випередження часу, яка відображає кожен стан на діапазон із максимальними та мінімальними значеннями часу та вводить дію, пов’язану з кожним станом системи [14]. Ця робота також представила RT-DEVS *executive*, який виконує ці моделі в RT. RT-DEVS також використовувався для розробки контролерів RT, як показано в Ref. [15] для системи поїзд-ворота. Подальша робота з перевірки RT-DEVS була представлена в Refs. [16,17], де автори покладалися на TA, що використовується UPPAAL, і визначили (хоча формально не підтверджено) метод трансформації від RT-DEVS до UPPAAL. Це перетворення дозволяє слабку синхронізацію між компонентами моделі TA, оскільки семантика RT-DEVS використовує слабку синхронізацію.

Other approaches use a limited version of DEVS that can be verified. For instance, a method based on Finite and Deterministic DEVS (FD-DEVS) was introduced [8] where the time advance function maps states into rational numbers and the external transition function cannot use the elapsed time value. The verification relies on reachability analysis, similar to TA algorithms. FD-DEVS is limited, thus it may not fit some applications that require the full expressiveness of DEVS. Likewise, although reachability analysis algorithms have been defined (and verification is possible), there are no tools available that implement these algorithms.

Інші підходи використовують обмежену версію DEVS, яку можна перевірити. Наприклад, був представлений метод, заснований на кінцевих і детермінованих DEVS (FD-DEVS) [8], де функція випередження часу відображає стани в раціональні числа, а зовнішня функція переходу не може використовувати значення часу, що минув. Перевірка ґрунтується на аналізі досяжності, подібному до алгоритмів TA. FD-DEVS обмежений, тому він може не відповідати деяким програмам, які вимагають повної виразності DEVS. Так само, хоча алгоритми аналізу досяжності були визначені (і перевірка можлива), немає доступних інструментів, які реалізують ці алгоритми.

To avoid these limitations, other approaches tried to map DEVS models to TA [18]. The conversion method mapped a DEVS model through its components and its simulator. The approach suggests trace equivalence as the basis for parallel DEVS and TA model equivalence. This work did not consider some DEVS features that may not map to TA, such as irrational values in DEVS transition functions. Moreover, some limitations also exist for relying on trace equivalence between DEVS and TA, as we will show in Section 3.3. A similar approach presented in Ref. [19] uses TA to specify the high-level system requirements, after which these requirements are modeled as a DEVS model. The system requirements are then verified through simulation of the DEVS model.

Щоб уникнути цих обмежень, інші підходи намагалися зіставити моделі DEVS з TA [18]. Метод перетворення відображав модель DEVS через її компоненти та симулятор. Підхід передбачає еквівалентність трасування як основу для паралельної еквівалентності моделей DEVS і TA. У цій роботі не розглядалися деякі функції DEVS, які можуть не відображатися на TA, наприклад ірраціональні значення у функціях переходу DEVS. Крім того, також існують деякі обмеження щодо еквівалентності трасування між DEVS і TA, як ми покажемо в розділі 3.3. Подібний підхід, представлений у Ref. [19] використовує TA для визначення системних вимог високого рівня, після чого ці вимоги моделюються як модель DEVS. Після цього системні вимоги перевіряються шляхом моделювання моделі DEVS.

The work by Hernandez and Giambiasi [20] showed that the verification of general DEVS models through reachability analysis is undecidable. The authors based their deduction on building a DEVS simulation Turing machine. Since the halting problem in Turing machines is undecidable (i.e., with analysis only, we cannot know in which state a Turing machine would be), they concluded that this is also true for DEVS models. In other words, we cannot recognize if we have reached a particular state starting from an initial state, and consequently, reachability analysis for general DEVS is impossible. Based on this result, reachability analysis may be possible only for restricted classes of DEVS. This result was based on introducing state variables with infinite number of values into the DEVS formalism. Therefore, limiting the number of states of a DEVS model is mandatory for decidable reachability. Hence, further work [21] introduced a new class of DEVS called time-constrained DEVS (TC-DEVS), which expanded the definition of DEVS atomic models with multiple clocks incremented independently of other clocks. Classic DEVS atomic models can be seen as having only one clock that keeps track of the elapsed time in a state and is reset on each transition. TC-DEVS also added clock constraints similar to TA (to function as guards on external and internal transitions). However, it is different from UPPAAL TA in that it allows clock constraints in state invariants to include clock differences. TC-DEVS is then transformed into an UPPAAL TA model. This work, however, did not include a transformation of TC-DEVS state invariants to UPPAAL TA when the model has invariants with clock differences, as this is not allowed in UPPAAL TA.

Робота Hernandez і Giambiasi [20] показала, що перевірка загальних моделей DEVS за допомогою аналізу досяжності є невирішальною. Автори заснували свій висновок на створенні симуляційної машини Тьюринга DEVS. Оскільки проблему зупинки в машинах Тьюринга неможливо вирішити (тобто лише за допомогою аналізу ми не можемо знати, в якому стані буде машина Тьюрінга), вони дійшли висновку, що це також справедливо для моделей DEVS. Іншими словами, ми не можемо розпізнати, чи досягли ми певного стану, починаючи з початкового стану, і, отже, аналіз досяжності для загального DEVS неможливий. На основі цього результату аналіз досяжності може бути можливим лише для обмежених класів DEVS. Цей результат був заснований на введенні змінних стану з нескінченною кількістю значень у формалізм DEVS. Тому обмеження кількості станів моделі DEVS є обов’язковим для вирішуваної доступності. Отже, подальша робота [21] представила новий клас DEVS під назвою DEVS з обмеженим часом (TC-DEVS), який розширив визначення атомарних моделей DEVS кількома тактовими сигналами, що збільшуються незалежно від інших годинників. Класичні атомарні моделі DEVS можна розглядати як такі, що мають лише один годинник, який відстежує час, що минув у стані, і скидається при кожному переході. TC-DEVS також додав обмеження годинника, подібні до TA (щоб функціонувати як охоронці зовнішніх і внутрішніх переходів). Однак він відрізняється від UPPAAL TA тим, що дозволяє обмеженням годинника в інваріантах стану включати різницю годинника. Потім TC-DEVS перетворюється на модель UPPAAL TA. Ця робота, однак, не включала перетворення інваріантів стану TC-DEVS в UPPAAL TA, коли модель має інваріанти з різницею годинника, оскільки це не дозволено в UPPAAL TA.

For large and more complex DEVS models, where formal verification is not feasible, testing would be the only choice. Techniques have been presented to generate testing sequences from model specifications that can then be applied against the model implementation to verify the conformance of the implementation to specifications [22,23].

Для великих і більш складних моделей DEVS, де формальна перевірка неможлива, тестування буде єдиним вибором. Було представлено методи генерації тестових послідовностей із специфікацій моделі, які потім можна застосувати до реалізації моделі для перевірки відповідності реалізації специфікаціям [22,23].

### 3.2.2 Rational Time-Advance DEVS

RTA-DEVS was proposed to provide the system modeler with a formalism that is expressive and sufficient to model complex systems behavior, while being verifiable by formal model-checking techniques. RTA-DEVS is a subclass of DEVS that has removed the main difficulties of the formal model verification discussed in Section 3.2.1; yet, it is sufficiently powerful to model complex system behavior.

RTA-DEVS було запропоновано, щоб надати розробнику системного моделювання формалізм, який є виразним і достатнім для моделювання поведінки складних систем, при цьому його можна перевірити за допомогою формальних методів перевірки моделі. RTA-DEVS є підкласом DEVS, який усунув основні труднощі верифікації формальної моделі, розглянуті в розділі 3.2.1; однак він достатньо потужний, щоб моделювати поведінку складної системи.

As in classical DEVS, we must define RTA-DEVS atomic models. The main difference is that RTA-DEVS employs a different definition for the time advance function, ta, and for the external transition function, δext. The Atomic Rational Time- Advance is defined as follows:

Як і в класичному DEVS, ми повинні визначити атомарні моделі RTA-DEVS. Основна відмінність полягає в тому, що RTA-DEVS використовує інше визначення для функції випередження часу, ta, і для функції зовнішнього переходу, δext. Atomic Rational Time- Advance визначається наступним чином:

 ![image-20220819232509034](media/image-20220819232509034.png) 

Coupled RTA-DEVS models are defined as in classic DEVS, as discussed in Section 3.2.

Поєднані моделі RTA-DEVS визначаються як у класичному DEVS, як обговорювалося в розділі 3.2.

A coupled RTA-DEVS model *M* can be simulated with an equivalent atomic RTA-DEVS model, whose behavior is defined as follows:

Поєднану модель RTA-DEVS *M* можна змоделювати за допомогою еквівалентної атомарної моделі RTA-DEVS, поведінка якої визначається наступним чином:

![image-20220819232541924](media/image-20220819232541924.png) 

[3.1 <--- ](3_1.md) [   Зміст   ](README.md) [--> 3.3](3_3.md)

