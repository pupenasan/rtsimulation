[12 <--- ](12.md) [   Зміст   ](README.md) [--> 12.2](12_2.md)

## 12.1. INTRODUCTION

Model-based engineering (MBE) [1] approaches support the use of models throughout the development process from requirements elicitation, to architecture specification, to system analysis, and deployment. Models can be leveraged in a variety of ways. During requirements elicitation, models help in defining the problem domain and communicating with stakeholders. During development, models can be used to define clear interfaces between components developed by separate suppliers. Modeling can also provide support for system synthesis by using model transformations and automatic code generation. For analysis, models can be used to verify system properties before the system is actually deployed. Moreover, models can also be used at runtime to monitor the system behavior and identify compliance to behavior interfaces and QoS properties.

Notably, modeling languages are most useful when they fulfill some key requirements. Two important requirements for modeling real-time embedded systems are a clear definition of the semantics of models together with the ability to guarantee that models are consistent. In fact, without a consistent set of models and a precise and complete semantics it is impossible to leverage models to synthesize code or to verify properties of the modeled system, which are two important activities in MBE of embedded systems. It is worth noting that consistency and semantics are two closely related aspects of a language. In fact, without a formal semantics it is impossible to prove the absence of inconsistencies.

The OMG’s Unified Modeling LanguageTM (UML®) [2,3] is a general-purpose modeling language widely used across application domains. It is a family of graphical notations underpinned by a single metamodel [4]. It provides 14 types of diagrams, which support modeling structural (i.e., static) and behavioral (i.e., dynamic) views of a system. The UML provides a built-in extension mechanism through profiles, which allows tailoring the UML for a particular domain or target platform. The recent UML profile for Modeling and Analysis of Real-Time and Embedded Systems (MARTE) [5] allows specifying timing properties, supports componentbased architectures and different computational paradigms, allows for modeling of both software and hardware platforms along with their nonfunctional properties, and supports schedulability and performance analysis.

In Chapter 5, we presented the modeling capabilities of UML and MARTE and discussed how ensuring consistency and defining a formal semantics is still an open issue in UML. In this chapter, we discuss various approaches to model consistency and we present an innovative solution. We picked the topic of model consistency to explore in detail because we believe it is paramount for a comprehensive modeling methodology.

In the following paragraphs, we discuss the consistency problem in UML and give an example of inconsistent models.

### 12.1.1 Multiview Models and Consistency Challenges

To tackle complexity, MBE approaches support multiple perspectives with associated modeling languages, each focusing on a particular subset of system properties. Each perspective can cover a separate aspect of the same part of the system or depict the same aspect with different notations to clarify or stress a modeling concept. For instance, we could use a sequence diagram to show the communication protocol between two class instances and two state-machine diagrams to describe the proper ordering of the method calls upon each class. These two perspectives clearly overlap. This overlapping requires that all models are consistent.

The UML standard from the Object Management Group® (OMG®) comprises many languages (14 types of diagrams), each emphasizing a different structural or behavioral modeling aspect. The most recent version is UML 2.3, whose specification consists of the UML Superstructure [3] defining the notation and semantics for diagrams and the UML Infrastructure [2] defining the language on which the Superstructure is based. Constraints can be expressed in the textual Object Constraint Language [6].

When using multiple modeling perspectives, the central question from an engineering point of view is this: Is the modeled system realizable? However, UML does not provide a complete formal semantics, which leaves issues such as model consistency unsolved.

In this chapter, we will focus on the issues related to consistency of UML models. We discuss the UML consistency problem in detail, explain how it originates or is worsened by the trade-offs in the language design, and propose an avenue to solve it. We chose this problem for its importance not only in the real-time systems domain but also in most areas where MBE is applied. One important example is the field of feature modeling. In this field, different software functionalities (features) are modeled separately and programs are generated by composing features. A recent article [7] argues that model consistency is still an open and important issue in this area. Furthermore, Model-Driven Architecture® (MDA®) [8] is an MBE approach that distinguishes between a platform-independent model (PIM) and a platformspecific model (PSM). PIM captures the core system entities and their interactions without specifying how these are implemented. PIM can be mapped to multiple PSMs, each capturing all aspects of a particular deployment architecture. UML is the language choice of MDA, where both PIM and PSM are expressed as UML models. The distinction between PIM and PSM also introduces a requirement for model consistency.

The first issue to solve when discussing model consistency for UML is to clearly define what kind of consistency we are interested in and how to effectively determine whether or not a UML model is consistent. Of course, UML is a broad-spectrum language with an informally defined semantics, which serves the goal to be inclusive with respect to modeling styles and domains. However, this creates the first hurdle we have to overcome in our consistency definition. Any approach aiming at defining consistency needs to explicitly or implicitly define a more precise semantics for UML. A rich body of work exists in the literature on defining multiview or multiperspective consistency based on UML semantics definitions. In Section 12.2, we will examine this related work.

Although the consistency problem has been extensively studied in the literature, a solution has been elusive—especially in the context of the UML with its rich set of interrelated description techniques for system structure and behavior. Existing approaches to defining UML model consistency lead to complex definitions of the notion of consistency or address only a subset of the available modeling notations. Our goal is to create a consistency checking approach that is flexible enough to be able to target the full UML language. However, we do not want the engineer to be forced to fully define the semantics of all UML notations, only the semantics of a subset (profile) of the UML language used in the specification should be defined.

The main novelty of the consistency checking approach we present in this chapter is in the comprehensive, yet simple mechanism we introduce for specifying consistency rules. Instead of analyzing the semantics of the UML at the metamodel level and extracting consistency rules between different diagram types, we define a simple execution framework (similar to a “virtual machine”), based on a target ontology whose concepts map one-to-one to elements of the system class we are interested in modeling, i.e., distributed, reactive systems. All UML diagram types are then treated as model generators for this virtual machine; each diagram selects entities of the virtual machine and constrains their structure or behavior. Model consistency is then simply defined as the presence of virtual machine behaviors under the specified constraints.

### 12.1.2 Inconsistency Example

We revisit the example from the Bay Area Rapid Transit (BART) [9] system, introduced in Chapter 5, Sections 5.3.2.3 and 5.4.2.3. BART is the commuter rail train system in the San Francisco Bay area. The BART system automatically controls over 50 trains on a large track network with several different lines. We show three modeling perspectives of BART using UML 2.3 and the MARTE profile: component, sequence, and state-machine diagrams (see [Figure 12.1](#_bookmark69)). We present an inconsistency that can arise when modeling behavior in the different diagrams, namely sequence and state-machine diagrams.

We focus on the Advanced Automatic Train Control (AATC) system, which controls the train movement for BART. The AATC system consists of computers at train stations, a radio communications network that links the stations with the trains, and AATC controllers on board of each train. Most of the control computation is done at the stations. Each station is responsible for controlling all trains in its area. Trains receive acceleration and brake commands from the station via the radio communication network. The train controller is responsible for operating the brakes and motors of all cars in the train. Controlling the trains must occur efficiently with a high throughput of trains on the congested parts of the network, while ensuring train safety. The station’s control algorithm takes the track information, train speed and acceleration, train position estimation, and information from the neighboring stations into account to compute new commands that never violate the safety conditions. To ensure this, each station computer is attached to an independent safety control computer that validates all computed commands for conformance with the safety conditions.

The component diagram for AATC is depicted in Figure 12.1a. It has three nodes: two for the train station and one for the train. The first node, Fast Computer, represents the station computer that computes the commands to be sent to all trains under the control of that station. It contains two components: one represents the Station AATC control system and the other called Environmental Model, which models the physical environment of a station. The Station AATC uses the Environmental Model to compute commands to send to trains. The second node, Slow Safety Computer, contains the Safety Control component, which checks all commands sent by the Station AATC for safety before forwarding them to each train. The safety computation is based on a simpler model than the one used to compute commands and, therefore, requires less computation resources. However, the Slow Safety Computer is required to have high reliability. The third node in the figure is the Train. It has two components: the Train Controller manages the train accelerations and decelerations, and the Emergency Brake is activated only in case of an emergency and stops the train as quickly as possible.

![image-20220822205751178](E:\san\Технології\моделиров\gitver_rtsimul\books\rtsimul_technologies\media\image-20220822205751178.png)

**FIGURE 12.1** Three different perspectives of the Bay Area Rapid Transit (BART) case study: (a) component diagram defining the structure, (b) sequence diagram describing the train commands computation and delivery, and (c, d) state-machine diagrams describing the Emergency Brake system.

The AATC system operates in half a second cycles. In each cycle, the station receives train information, computes commands for all trains under its control, and forwards these commands to the train controllers. The Station AATC system obtains the status information regarding train speed, acceleration, and range by using the radio network, which allows the system to track train positions. The Station AATC system computes the train position from the status information and updates its Environmental Model. Then, the Station AATC interacts with the Environmental Model and the Safety Control components to compute and send the new commands, as depicted in the sequence diagram from Figure 12.1b. The behavior specified in the diagram is the following:

•   Station AATC sends a request to Environmental Model to compute the commands for the train.

•   Environmental Model computes the commands, taking into account all parameters such as passenger comfort (e.g., not too strong braking and acceleration changes), train schedule, engine wear, and most importantly safety.

•   After receiving the commands from Environmental Model, Station AATC sends the commands to Safety Control to ensure the commands computed are safe.

•   Safety Control checks that the commands do not exceed maximum bounds for safety. If the commands are safe, Safety Control forwards them to Train Controller.

•   Train Controller informs Emergency Brake that the commands have been received.

•   Emergency Brake acknowledges the commands received.

•   Finally, Train Controller controls the train engine according to the commands received.

The model in Figure 12.1b is annotated with MARTE time constraints to specify the real-time requirements of the BART case study. We annotated two time instants *t*0 and *t*1 using TimedInstantObservations as defined in MARTE, which is indicated by the graphical representations @*t*0 and @*t*1. A TimedInstantObservation denotes an instant in time associated with an event occurrence (e.g., send or receive of a message) and observed on a given clock. *t*0 is the instant when the message Compute Commands is *sent* by Station AATC, whereas *t*1 is the time instant when the message Commands Received is *received* by Emergency Brake. Because the system operates in cycles, the notation *t*0[*i*] and *t*1[*i*] represents the generic *i*th instantiation of the interaction scenario.

Given those two instants, we leverage MARTE to define three time constraints in our system. Commands to trains become invalid after 2 seconds. If a train does not receive a valid command within 2 seconds, it goes into emergency braking. Therefore, with the time constraint (*t*1[*i*] − *t*0[*i*]) < (2000, ms), we limit the duration of each iteration of this scenario to 2 seconds. The AATC control algorithm needs to take this timing constraint, track information, and train status into account to compute new commands that never violate the trains’ safety.

The second constraint, (*t*0[*i* + 1] − *t*0[*i*]) > (500, ms), imposes that between each instantiation of the scenario at least half a second passes. Finally, the last constraint, jitter(*t*0) < (10, ms), limits the jitter of the *t*0 event enforcing that between each iteration of the event at *t*0 there are between 500 and 510 ms.

In normal operations, the AATC system computes the train commands in fixed time cycles. However, in case of a detected emergency condition, the system has to react immediately and take appropriate measures to ensure maximum safety of passengers and equipment. Figure 12.1c and Figure 12.1d present state-machine diagrams for the Emergency Brake component. A train will continue to exercise a command until a new one arrives or until that command expires, 2 seconds after the originating time. The state-machine diagram for the Emergency Brake has states for waiting for commands and entering emergency mode if the timer of 2 seconds expires. When commands are received, the timer is reset. These state machines are two different versions of the same perspective where the one in Figure 12.1d is a refined version that enables restarting the system after an emergency brake. If we consider the three graphs from Figure 12.1a, 12.1b, and 12.1c together, we have an inconsistent model: the state-machine diagram Figure 12.1c does not acknowledge the Commands Received call from Train Controller—contrary to what the sequence diagram from Figure 12.1b demands. Replacing the diagram from Figure 12.1c with Figure 12.1d, we obtain a consistent model. 

### 12.1.3 Outline

In the preceding paragraphs, we discussed the role of modeling, multiview models in UML, and the problem of consistency management. We also presented an example of inconsistent models, which we will use later in the chapter as an example for applying our consistency checking solution.

The remainder of the chapter is structured as follows. In Section 12.2, we identify a set of core requirements to address the consistency problem of UML adequately and we analyze related approaches in the literature. Because none of the approaches fully addresses all requirements, we propose an innovative approach to UML consistency in Section 12.3. Our approach is based on defining (1) an explicit ontology that captures the target domain we are modeling and (2) a simple execution framework based on this target ontology. Sections 12.4 and 12.5 contain discussions and outlook.

 

[12 <--- ](12.md) [   Зміст   ](README.md) [--> 12.2](12_2.md)